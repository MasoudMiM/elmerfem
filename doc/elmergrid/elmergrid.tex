\chapter{Overview of ElmerGrid}

\section{Introduction}

ElmerGrid is a simple mesh generator and 
mesh manipulation utility. 
It is an appropriate tool for generating structured meshes for 
simple 2D and 3D geometries. 
It can also read meshes generated by other mesh generators and 
manipulate them. Among the possible operations are
scaling, changing of element type, 
defining boundaries, or partitioning the mesh for parallel solution, 
for example.

ElmerGrid was originally a side product of research done in the area
of silicon carbide crystal growth.
The main goal was to write a simple mesh generator for multiphysical
problems where different meshes based on the same geometry were needed for different physical problems.
Since that the software has been modified to meet the 
needs of Elmer development.
Thus the name has been changed from Quickmesh to ElmerGrid.
Because ElmerGrid was never designed to be an stand-alone mesh generator 
it has been developed in on uncontrolled manner. The data structures 
are not optimal for all the added features. Therefore the software may
at times cause problems.

This chapter shortly describes the main 
capabilities of the program.


\section{Usage}
The executable binary of the program is named {\tt ElmerGrid}.
It may be started with no arguments at
all. Then the following help text is automatically 
displayed.

\verbatiminput{ElmerGrid.info}

As may be seen the user may choose between several 
input and output formats. The format is specified 
by an integer number (or an appropriate string) and the filename that is given may 
or may not have the appropriate suffix.


\section{Input formats}

The ElmerGrid code has two different operation modes.
In the one all the information is read from a command file.
Alternatively all necessary data may be read from 
from the inline arguments. 

The native formats of the code are thus the command file 
with the suffix \texttt{.eg} and the 
native geometry format that has the suffix \texttt{.grd}. 
Note that most commands that may be given in the command file 
may also be given in the geometry format. 

Additionally there are several other input formats
that helps in linking the Elmer software with other pre- and 
postprocessors. 
The other formats may
not always be used to create a complete
model with boundary conditions. Also their functionality 
does not include all the possible commands.

\begin{description}
\item \texttt{1)  .grd      : ElmerGrid file format} \\
The native ElmerGrid format is  described in a separate section.

\item \texttt{2)  .mesh.*  : Elmer output format} \\
Input format for ElmerSolver consisting of separate header,
node, coordinate and topology files.

\item \texttt{3)  .ep      : Elmer input format} \\
This format is the same that
ElmerSolver uses in saving the results to be 
postprosessed with ElmerPost. 

\item \texttt{4)  .ansys    : Ansys input format} \\
This format is the input format 
created by the preprosessor of Ansys using a special
Ansys macro.
An example is given in later chapters.

\item \texttt{5)  .inp    : Abaqus input format by Ideas} \\
This format is the input format 
created by Ideas preprocessor for Abaqus.

\item \texttt{6)  .fil    : Abaqus output format} \\
This format is the output format 
created by the solver of Abaqus.

\item \texttt{7)  .FDNEUT  : Fidap neutral file} \\
Also created by Gambit, the preprocessor of Fluent.

\item \texttt{8) .unv : Universal mesh file format} \\
A subset of the universal mesh file format commands may be read by ElmerGrid.

\item \texttt{9)  .mphtxt   : Comsol mesh format} \\
The phhtxt format created by Comsol Multiphysics. 

\item \texttt{10)  .dat      : Fieldview format} \\
This may be used with Gridgen preprocessor.

\item \texttt{11) .node,.ele: Triangle 2D mesh format} \\
Read in meshes created by Triangle 2D Delaunay mesh generator.

\item \texttt{.mesh     : Medit mesh format} \\
Format of Medit mesh generation program.

\item \texttt{13) .msh      : GID mesh format} \\
Format of GID mesh generation program.

\item \texttt{14) .msh      : Gmsh mesh format} \\
Format of Gmsh mesh generation program.

\item \texttt{15) .ep.i     : Partitioned ElmerPost format} \\
Partitioned Elmer results created by parallel computing. 
\end{description}

\section{Output formats}
The supported output formats are all different 
formats of Elmer software. Additionally, there are some undocumented formats.
Thus, if you need to export some data from Elmer format you may
ask for the possibilities. 


\begin{description}

\item \texttt{1)  .grid     : ElmerGrid file format} \\
The native format, may be used to refresh the input file if it becomes
corrupted or outdated.

\item \texttt{2)  .mesh.*   : ElmerSolver file format} \\
Format that may be used in Elmer calculations.
In a single-processor version 
the input is divided to four different files with 
suffixes, \texttt{mesh.boundary}, \texttt{mesh.elements},
\texttt{mesh.header} and \texttt{mesh.nodes}.

The command-line parameters \texttt{-part} and \texttt{-metis} 
activate the partitioned 
input format for the ElmerSolver. 
The ending is \texttt{.part.*} and the 
files are saved to 
subdirectory with suffix \texttt{.part.n}, where
\texttt{n} is the running number of the partition.

\item \texttt{3)  .ep       : ElmerPost file format} \\
Format for Elmer postprosessing. This is particularly handy for tuning the
mesh before it is used in the solution. Then the only variable that is saved is 
the node index referred to by field variable \texttt{Number}.

\end{description}



\section{ElmerGrid command-line arguments}

ElmerGrid has a lot of simple functionalities that may be activated 
with the right command-line arguments. Most of them may operate on
all meshes, some or limited to 2D meshes, for example. 

In the command-line operation mode
there are only three mandatory arguments: The input format,
the output format, and the name of the input file.
All other arguments are optional.

\sifbegin
\sifitem{-out}{String}
Gives an alternative name for the output file or directory. 
The default name is the same as the name of the input file
attached with an appropriate suffix. 
%
\sifitem{-in}{String}
Sometimes there are may be more than one input mesh. 
Then the name of the secondary input file may be given 
after this keyword.
%
\sifitem{-decimals}{Integer}
The number of decimals for Elmer mesh is by default set to 6.
Sometimes more decimals may be needed and this command may then
be used. This could be the case, for example, if the elements are 
small compared to the absolute values of the coordinates.
The size of the ascii file is affected by the number of 
decimals and therefore the default is quite small.
%
\sifitem{-triangles}{}
The meshes consisting of rectangles may be divided into 
triangles. This operation may be performed on all 2D meshes, 
not only to the ones created using ElmerGrid format.
%
\sifitem{-merge}{Real}
Sometimes when creating the computational mesh the 
different domains are not properly joined. Then it is possible to 
use this option, where nodes that are close to each other are
fused. The value given for the node separation should be smaller than
the smallest element size. Otherwise there is a risk of ruining the mesh.

For optimal computational efficiency the merging of nodes is done 
in two stages. In the first stage the nodes are ordered and in the second
stage the nodes close to each other are checked for distance. 
If distance is smaller than the critical one the nodes are given one
common coordinate and the other node is eliminated from the holes mesh.
%
\sifitem{-order}{Real[DIM]} 
The nodes may be ordered if the original ordering is uneconomical.
The three components gives the direction in which the nodes are reordered.
More accurately, the nodes are ordered using the 
dot product $\vec{c}\cdot\vec{r}$ as a measure.
%
The reordering of the degrees of freedom is usually performed 
within ElmerSolver and therefore 
it is usually not necessary to renumber the nodes within ElmerGrid.
%
%\sifitem{-autoorder}{}
%This uses heuristic ordering methods to optimize the bandwidth. The same
%optimization method is used consecutively and the best choice is kept. 
%This seems, however, usually be inferior to the algorithm in 
%ElmerSolver.
%
\sifitem{-scale}{Real[DIM]}
This simply scales the coordinates of the mesh by 
multiplying with the given constants, i.e.
$x:=c_x x$, $y:=c_y y$ and $z:=c_z z$.
This is useful, for example, if the mesh is in other units that is 
preferable. 
%
\sifitem{-translate}{Real[DIM]} 
This option translates the mesh with a given vector by
simly adding the given values to the original coordinates,
i.e. $\vec{r} := \vec{r} + \vec{r}_0$.
%
\sifitem{-rotate}{Real[3]} 
The mesh may be rotated around the main axis. 
The rotation is done consecutively in all three angles.
This feature may be handy in the debugging of some equation --
in cartesian grids the solution should be rotation invariant.
%
\sifitem{-clone}{Integer[DIM]}
The mesh may be copied so that the same 
structure is repeated over and over. The number of copies in 
each coordinate direction may be given independently.
The total number of individual copies is their product.
%
\sifitem{-clonesize}{Real[DIM]} 
By default the copies of the mesh are performed so that the 
new meshes are set directly besides the old ones. This flag may be used to define
a larger size for the mesh which enables empty space being left 
between the meshed.
%
\sifitem{-mirror}{Integer[DIM]} 
The mesh may be mirrored over the main axis. The arguments 
tell over which axis the mesh should be mirrored. If all three axis
are active then the original mesh will be eight times the size of the original one.
Note that the origin is assumed to be at zero in all directions.
%
\sifitem{-unite}{}
This option unites the ElmerGrid meshes. In every other format its currently
not possible to create more than one mesh at a time.
%
\sifitem{-polar}{Real}
This option maps the 2D mesh an a cylindrical shell with the radius
given as a parameter.
%
\sifitem{-cylinder}{}
This option assumes that the original 3D mesh was given in 
cylindrical coordinates $(r,\theta,z)$ and maps them to cartesian 
coordinates $(x,y,z)$.
%
\sifitem{-reduce}{int[2]} 
This feature reduces the element order of materials at the interval
defined by the two parameters. It may be used to lower the element order 
only in parts of the geometry. For example, in fluid-structure-interaction the 
fluid could be modeled with linear elements while the 
structure might need second order elements.
%
\sifitem{-increase}{} 
Increase the element order in all the elements from one to two.
This may be used to improve computational accuracy of existing 
linear meshes by making the quadratic.
%
%\sifitem{-pelem}{Integer[3]}
%ElmerGrid usually assumes elements of Lagrange type where 
%the element degree is increased by introducing intermediate nodes
%in the element. The other option is just to use a higher polynomial basis
%with the existing nodes -- the p-elements. 
%This option is used to make p-elements for materials at the interval given by
%the first two parameters. The desired power is given by the third parameter.
%The p-elements are only seen in the Elmer mesh -format.
%
\sifitem{-bcoffset}{Integer}
Adds on offset to the boundary condition numbering. This may be usefull for multimesh
computations where it is advisable that the same boundary numbers are not defined in 
different meshes. 
%
\sifitem{-discont}{Integer}
Sometimes the field variables behave discontinuously over a short distance.
For example, in solving the heat equation there may be a small gap between
different bodies. To account for such discontinuities the mesh should
have duplicate nodes over the discontinuity. This feature does exactly that
and saves the boundary conditions for both sides.
%
\sifitem{-connect}{Integer}
Makes the boundary to have internal connections between among its elements. This
will enable connections in the resulting finite element matrices. The feature could 
be used in setting constraints in the finite element solution. 
%
\sifitem{-removelowdim}{}
Removes boundary elements that are two or more dimensions lower than the 
highest dimensional bulk elements. 
%
\sifitem{-bulkorder}{}
Renumbers the body indexes so that every number is used. This feature may be handy 
particularly when importing meshes that have a very wild numbering of bodies.
%
\sifitem{-boundorder}{}
Renumbers the boundary element types so that every number is used. This feature may be handy 
particularly when importing meshes that have a very wild numbering of boundary elements types.
%
\sifitem{-autoclean}{}
This flag activates several of the above procedures that simplifies the mesh
for solution purposes. The lower dimensional boundary elements are removed, 
and the body and boundary element types are renumbered.
%
\sifitem{-bulkbound}{Integer[3]}
Sometimes the geometry does not include all the necessary boundary conditions. 
Then this inline parameter may be used to define a new boundary 
(first parameter) on the interval of the two given materials.
%
\sifitem{-boundbound}{Integer[3]}
Sometimes the geometry does not include all the necessary boundary conditions. 
Then this inline parameter may be used to define a new boundary 
(first parameter) on the interval of two already existing boundaries.
This makes it possible to define lines or even single points 
in 3D geometry that has only surfaces defined.
%
\sifitem{-bulktype}{Integer[3]} 
Sometimes there is a multitude of bodies that may be united with this option.
It may be easier to perform the further analysis if the number of bodies 
is not too large.
For example, in ElmerPost a very lengthy list of bodies or 
boundaries is difficult to visualize. 
%
\sifitem{-boundtype}{Integer[3]}
This option does exactly the same as the above but now for the boundary
 elements.
Again the advantage may be that the command-file will be more economical as 
if the number of boundaries is reduced.
%
\sifitem{-layer}{Integer[2] Real[2]} 
This option may be used to create boundary layers on an existing 2D mesh.
The given boundary is extruded with the given number of layers. Also the total
thickness of the layer and the desired ratio between first and last element
is given.
%
\sifitem{-layermove}{int}
This option activates a filter that is used to map the node coordinates 
so that the boundary layers are fitted within the original geometry.
%
\sifitem{-divlayer}{Integer[2] Real[2]} 
This option may be used to create boundary layers on an existing 2D mesh.
The layer is created by splitting the trinagles or quadrilaterals 
along the boundary to give a structured boundary laer mesh.
%
\sifitem{-3d / -2d / -1d}{}
This option is usually not needed as the files most often have the information
of the space dimension. The exception is the creation of an example file.
3D is the default, thus the \texttt{-2d} should be used if one wants to create
a 2D example file. Also some command-line parameter lists are by default assumed to have 
three values if 2D dimension is not given.
%
\sifitem{-isoparam}{}
In creating mapped meshes by ElmerGrid the higher-order nodes may sometimes be 
oddly displaced. This utility sets the intermediate nodes to lie on the connecting lines
between the corner nodes. 
%
\sifitem{-nobound}{}
Disable the saving of boundary elements.
This may sometimes be useful if there are a lot of boundaries and one is just interested 
in the bulk elements.
\sifend
%
There are a number of in-line parameters that are related only to the parallel Elmer computations.
%
\sifbegin
\sifitem{-partition}{Integer[DIM+1]} 
There are two methods to partition geometry for parallel computing. This
method takes each coordinate direction and divides the mesh in the number
of slices given in the parameter list. For example option
\texttt{-part 2 3 5} would split the mesh into $2\times 3 \times 5 = 30$ partitions. 
Each split is done so that the number of elements in each partition
is almost equal. The method is best suited for simple geometries 
where more generic strategies usually do not work as well.

The last flag is an optional flag which defines whether the geometric division is done 
primarily for the nodes or the elements. For value 0 the partition is first done for elements and
thereafter for nodes, while for value 1 the order is opposite.
%
\sifitem{-partorder}{Real[DIM]} 
The simple partitioning is done by dividing the elements
into subgroups. The division is done by first ordering the nodes. This
keyword is followed by the normal vector of the desired ordering.
%
\sifitem{-metis}{Integer[2]}
This utility does the partitioning utilizing the Metis library, see
\URL{ttp://www-users.cs.umn.edu/~karypis/metis/}. Metis has subroutines
for basic linear elements. Also higher order elements may be partitioned
by first neglecting the higher order nodes.

The first integer defines the number of partitions while the second relates
to the partitioning routine of Metis. The following subroutines may be used when ablicable,
\begin{enumerate}
\item[0:]    METIS\_PartMeshNodal
\item[1:]    METIS\_PartMeshDual
\item[2:]    METIS\_PartGraphRecursive
\item[3:]    METIS\_PartGraphKway
\item[4:]    METIS\_PartGraphVKway
\end{enumerate}

In partitioning a major problem is to save just the right information
needed by each processor. There are some very complicated dependencies that
result from the parallel solution of the matrix equations. To simplify these
the communication, ElmerGrid does some load-balancing so that each processors
owns roughly as many shared nodes. Also on the interfaces of more than two
partitions the ownership is optimized so that nodes cannot be 
indirectly related to each other in a way that is in conflict with 
the parallel solution algorithm. 

Note that this option may not be active if the code has been compiled
without the Metis library.

\sifitem{-halo}{}
This flag creates a halo for the partitioning. This must be provided, for example, in
discontinuous Galerkin computations where at the boundaries the gradient information 
must also be computed. 

\sifitem{-indirect}{}
Creates the indirect connections in the partitioning. These are connections in 
a finite element matrix that exist between two nodes but would not be apparent if
only the partition in question would be studied.  

\sifitem{-periodic}{Integer[3]} 
If the solution of the mesh is known to be periodic ElmerSolver uses
a special kind of boundary condition. Also in partitioned meshes
used in parallel computation the periodic boundaries must be known
as they require the flow of information between opposing sides.
This option finds periodic boundaries in the given directions 
given by 0/1 logical values. If periodic boundary is found it is taken into
account in saving and partitioning the mesh.
The determination of the periodic nodes only works when there is one-to-one mapping
between the nodes on the boundaries. 
%

\sifend



