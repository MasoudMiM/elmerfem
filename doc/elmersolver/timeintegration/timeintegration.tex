\newcommand{\ExampleOperator}{\mathcal{K}}

\chapter{Integration of time-dependent systems}
\noindent

\section{Introduction}

Solving time-dependent systems is becoming more and more common 
%in engineering, physics and mathematics, 
in various branches of computational science,
as the computer resources grow steadily.
Elmer Solver may be adapted to solve such systems. The first order time 
derivatives may be discretizated by using the following methods:
\begin{itemize}
\item the Crank-Nicolson method
\item the Backward Differences Formulae (BDF) of several orders
\end{itemize}
In the case of the first order BDF scheme adaptive time-stepping strategy may also
be used. 

The second order time derivatives are approximated by either using the Bossak 
method or reformulating the second order equations as equivalent systems
of first order equations. 

%All the algorithms are implicit in time, no explicit schemes are provided.
%Adaptive time integration in time is also provided.

\section{Time discretization strategies}

%Let the system be described by 
Consider the numerical solution of the evolutionary field equation 
\begin{equation}\label{EvolutionaryModelProblem1}
\frac{\partial \phi}{\partial t} % - \nabla\cdot(k\nabla \phi) +
+\ExampleOperator\phi = f,
\end{equation}
where the differential operator $\ExampleOperator$ does not involve 
differentiation with respect to time $t$ and $f$ is a given function of spatial 
coordinates and time. The spatial discretization of (\ref{EvolutionaryModelProblem1}) 
leads to the algebraic equations 
\begin{equation}\label{EqToTimeDiscretizate}
M\frac{\partial \Phi}{\partial t} + K\Phi = F,
\end{equation}
where $M$, $K$ and $F$ result from the discretization of the identity operator,
the operator $\ExampleOperator$ and $f$, respectively. 
The vector $\Phi$ contains the values of the unknown field $\phi$ at nodes.  

The applications of the first three BDF methods to discretizate the time derivative term
in (\ref{EqToTimeDiscretizate}) yield the following systems:
\begin{equation}\label{BDF1}
\left (\frac{1}{\Delta t}M+K\right )\Phi^{i+1} = F^{i+1} + \frac{1}{\Delta t}M\Phi^{i},
\end{equation}
\begin{equation}
\left (\frac{1}{\Delta t}M+\frac{2}{3}K\right )\Phi^{i+1} = \frac{2}{3}F^{i+1} + \frac{1}{\Delta t}M
\left( \frac{4}{3}\Phi^{i}-\frac{1}{3}\Phi^{i-1}\right ),
\end{equation}
\begin{equation}
\left (\frac{1}{\Delta t}M+\frac{6}{11}K\right )\Phi^{i+1} = \frac{6}{11}F^{i+1} + \frac{1}{\Delta t}M
\left( \frac{18}{11}\Phi^{i}-\frac{9}{11}\Phi^{i-1}+\frac{2}{11}\Phi^{i-2}\right ),
\end{equation}
where $\Delta t$ is the time step and $\Phi^{i}$ is the solution at time step $i$.
Similarly, $F^{i}$ is the value of $F$ at time step $i$.

All the BDF methods are implicit in time and stable. The accuracies of the
methods increase along with the increasing order. The starting values for the
BDF schemes of order $n>1$ are computed using the BDF schemes of order $1,...,n-1$
as starting procedures. It should be noted that the BDF discretizations of order $n>1$ 
do not allow the use of variable time-step size. 
Adaptive time-stepping strategy may also be used in the case of the first order BDF scheme.

The adaptive time-stepping is accomplished by first solving the system
using a trial time step and then using two time steps the lengths of which equal to the 
half of that of the trial time step and comparing the results. 
If the difference between the results is found to be sufficiently small, the use of
the trial time step is accepted. Otherwise a new trial time step is defined by dividing
the previous trial time step into two steps of equal length and then the procedure 
is repeated. One may define one's own criterion for determining whether the use of 
the current time step is accepted.
The default criterion is that the norms of the solutions to each system of field equations 
do not differ more than the given threshold value.

The time discretization of the second order equation
\begin{equation}\label{EqToTimeDiscretizate2}
M\frac{\partial^2\Phi}{\partial t^2} + B\frac{\partial\Phi}{\partial t} + K\Phi = F
\end{equation}
using the Bossak method leads to the system
%
\begin{equation}
\begin{split}
\left (\frac{1-\alpha}{\beta(\Delta t)^2}M + 
\frac{\gamma}{\beta\Delta t} B + K\right )\Phi^{i+1} =
F^{i+1} + M\left ( \frac{1-\alpha}{\beta(\Delta t)^2} \Phi^{i} + 
\frac{\gamma}{\beta\Delta t}V^i + 
 \frac{(1-\alpha)}{2\beta}A^i\right ) + \cr
B\left (
\frac{\gamma}{\beta\Delta t}\Phi^i + 
\left(\frac{\gamma}{\beta}-1\right)V^i+
\left(1-\frac{\gamma}{2\beta}\right)\Delta tA^i\right), 
\end{split}
\end{equation}
%
where
\begin{equation}
\begin{split}
V^{i+1} = V^i + \Delta t\left ((1-\gamma)A^i+\gamma A^{i+1}\right ), \cr
A^{i+1} = \frac{1}{\beta(\Delta t)^2}(\Phi^{i+1}-\Phi^i)-\frac{1}{\beta\Delta t}V^i+
\left( 1-\frac{1}{2\beta}\right )A^i,  \cr
\beta = \frac{1}{4}(1-\alpha)^2, \quad \gamma = \frac{1}{2} - \alpha.
\end{split}
\end{equation}
In the following the matrices $M$ and $B$ are referred to as the mass and damping
matrix, respectively.


\section{Keywords related to time discretization}

All the keywords related to the time discretization may be given in Simulation section of 
the solver input file (.sif file). A number of keywords may also be given in Solver section,
so that each system of field equations may be discretizated using independently chosen 
time-stepping method.
%In addition the keywords related to selection of the time-stepping method may
%be given individually in each of the Solver sections. 
If keywords are not given in the Solver
section, the values of the keywords are taken to be those given in the Simulation section.
It should be noted that certain keywords such as those controlling the number of time steps, 
time-step sizes etc. may only be given in the Simulation section.

\sifbegin
\sifitem{Timestepping Method}{String}
This keyword is used to declare the time discretization strategy for the 
first order equations. The value of this keyword may be set to be either {\tt ''BDF''}
or {\tt ''Crank-Nicolson''} and may be given in 
either Simulation section or Solver section of the solver input file.

\sifitem{BDF Order}{Integer}
This keyword is used to define the order of the BDF method and may take 
values 1,...,5. This keyword may be given in either Simulation section or 
Solver section of the solver input file.

\sifitem{Time Derivative Order}{Integer}
If a second order equation is discretizated,
this keyword must be given the value 2 in the Solver section of the solver input
file. It should be noted that the second order time derivatives are always discretizated 
using the Bossak method.

\sifitem{Bossak Alpha}{Real [-0.05]}
This keyword is used to define the value for $\alpha$ in the Bossak method used
in the time discretization of second order equations.
This keyword may be given in either Simulation section or Solver section
of the solver input file.

\sifitem{Timestep Intervals}{Integer array}
This keyword is used to define the number of time steps. 
It may be array-valued so that different time-step lengths may be used
for different time intervals of the entire simulation. For example,  
if one wishes to take first 50 time steps and then to use a
different time-step length for the following 100 time steps, one may     
define
\ttbegin
Timestep Intervals(2) = 50 100
\ttend
and use the {\tt Timestep Sizes} keyword to define time-step lengths for 
the two sets of time steps. 

\sifitem{Timestep Sizes}{Real array}
This keyword is used to define the length of time step. 
If the value of the {\tt Timestep Intervals} keyword is array-valued,
the value of this keyword must also be an array of the same size.      
For example, if one has defined
\ttbegin
Timestep Intervals(2) = 50 100
\ttend
the declaration
\ttbegin
Timestep Sizes(2) = 0.1 1.0
\ttend
sets the time-step length for the first 50 time steps to be 0.1 and for the remaining
100 time steps 1.0.

\sifitem{Timestep Function}{Real}
Instead of using the {\tt Timestep Sizes} keyword the length of time step
may be defined by using this keyword.  The value of this keyword is evaluated
at the beginning of each time step. A variable time-step length may conveniently be 
defined using a MATC or Fortran function. 

\sifitem{Output Intervals}{Integer array}
This keyword is used to define the time-step interval for writing the results on disk.
As in the case of the {\tt Timestep Sizes} keyword the size of the value of this keyword
must be compatible with that of the {\tt Timestep Intervals} keyword. 

\sifitem{Lumped Mass Matrix}{Logical [false]}
The use of a lumped mass matrix may be activated by setting the value of this 
keyword to be {\tt True} in the Solver section of solver input file. 
The default lumping is defined by
\begin{equation}
M'_{ii} = M_{ii}\frac{\sum_i\sum_j M_{ij}}{\sum_i M_{ii}}.
\end{equation}
\sifend

\noindent
The keywords related to the adaptive time-stepping may only be given in the Simulation section
of the solver input file. When the adaptive time-stepping strategy is used, a set of trial 
time steps is defined using the keywords introduced above. 
The adaptive procedure is executed for each of these trial steps. Note that
the adaptive time-stepping is possible only in the case of the first order BDF scheme.

\sifbegin
\sifitem{Adaptive Timestepping}{Logical [false]}
The value of this keyword must be set to be {\tt True} if 
the adaptive time integration is to be used.

\sifitem{Adaptive Time Error}{Real}
This keyword is used to define the threshold value for the criterion for
determining whether the use of the current time step is accepted.

\sifitem{Adaptive Error Measure}{Real}
Using this keyword one may define one's own measure for evaluating the difference
between the computed results. This measure and the threshold value, which is
given using the {\tt Adaptive Time Error} keyword, may be used to define  
a user-defined criterion for determining whether the use of the current time step is 
accepted. The value of the {\tt Adaptive Error Measure}
keyword is evaluated twice for each trial time step. 
For the first time the value
of the keyword is evaluated after the system is solved using the trial time step. 
The second time is after the system is solved using two time steps the lengths of 
which equal to the half of that of the trial time step.
The absolute value of the relative difference between these two values
is compared to the threshold value given by the {\tt Adaptive Time Error} keyword
to determine whether the use of the current time step is 
accepted. If several systems of field equations are solved, all the solutions must
satisfy the similar criterion.
If this keyword is not used, the default criterion is based on comparing 
the norms of the solution fields. 

\sifitem{Adaptive Min Timestep}{Real}
Using this keyword one can limit the subsequent division of the trial time steps 
by giving the minimum time-step length which is allowed.

\sifitem{Adaptive Keep Smallest}{Integer [1]}
By default the adaptive scheme tries to double the length of the time step 
after the acceptable time step is found. If a value $n>1$ is given for this keyword,
the adaptive scheme tries to increase the step length after taking n steps which are at 
most as long as the step length accepted.
\sifend

\section{On the treatment of time derivatives in Elmer Solver code}

In the following a number of issues that may be useful if one is writing a code
to solve one's own application are explained. 

By default Elmer Solver does not 
generate or use global mass or damping matrices in the solution of time-dependent 
systems. Mass and damping matrices need to be computed only element-wise, as  
the linear system resulting from the time discretization, such as (\ref{BDF1}),
is first formed element-wise and this local contribution is later assembled to the
global system. In the case of the first order equation (\ref{EqToTimeDiscretizate}) 
the local linear system may be formed by using the subroutine call
\ttbegin
 CALL Default1stOrderTime( M, K, F ),
\ttend
where $M$ is the element mass matrix, $K$ is the element stiffness matrix 
and $F$ is the element force vector. In a similar manner,
in the case of the second order equation (\ref{EqToTimeDiscretizate2}) 
one may use the subroutine call
\ttbegin
 CALL Default2ndOrderTime( M, B, K, F ),
\ttend
where $B$ is the element damping matrix.

Note that these subroutines must also be called for the local matrices and vectors
that result from the discretization of neumann and newton boundary
conditions. If the boundary conditions do not contain any time derivatives,
the $M$ and $B$ matrices should be set to be zero before calling the above subroutines.

If the global mass matrix is required, it may be generated by using the subroutine call
\ttbegin
 CALL DefaultUpdateMass( M )
\ttend
Similarly, the global damping matrix may be generated by using the subroutine call
\ttbegin
 CALL DefaultUpdateDamp( B ).
\ttend
Global mass (and possibly damping) matrices are required, for example, in the
solution of eigenvalue problems. One may also implement one's own time-stepping
scheme at the global level using these matrices.
   



\bibliography{elmerbib}
\bibliographystyle{plain}

