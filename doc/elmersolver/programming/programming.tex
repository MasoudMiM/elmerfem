\chapter{Basic Programming}
\noindent
%+++++++++++++++++++++
\section{Introduction}
The Elmer distribution contains a large set of different solvers and also the possibility to declare dependence of material properties or boundary conditions on certain variables (e.g., using the MATC language). Nevertheless, there always may occur certain physical problems that are too difficult to be handled via the solver input file. Such problems can be coped by introducing new user functions or even complete new solvers. Elmer is very flexible if certain models have to be added by the user providing her/his own code. 

This chapter shall provide a brief introduction to basic programming of user functions as well as solvers that can be added to Elmer. This will be done by mainly using certain examples and explaining the programming steps occurring in these. 

The Elmer Solver source is written in the programming language Fortran 90. Since the Elmer Solver binaries are compiled as shared objects, it is sufficient to just newly compile the code contributed by the user as an executable of a shared object (\texttt{.so} in UNIX and \texttt{.dll} in Windows) that dynamically is linked to the rest of the distribution. In order to provide Elmer with the needed information to be able to load an external function or solver, the following entry in the solver input file (suffix \texttt{.sif}) has to be given:
\ttbegin
  Procedure "filename" "procedure"
\ttend
Where the file \texttt{filename} is the above mentioned executable that should contain the Fortran 90 subroutine or function \texttt{procedure}. The file \texttt{filename} should reside in the same directory where the solver input file is. Else, the relative or absolute path to that file should be added in front of the entry \texttt{filename}.

\section{Basic Elmer Functions and Structures \label{programming:defUtils}}
In order to provide a better understanding for the following mainly example-based explanation some of the most often needed functions and routines provided by Elmer shall be discussed in this section. Most of these routines and functions are defined in the Fortran~90 module \texttt{DefUtils}. It has to be included in the code provided by the user giving the keyword
\ttbegin
USE DefUtils
\ttend

It is important to notice that -- due to the nature of the Finite Element Method -- the basic data structure in the Elmer Solver is the single element, rather than single points. That simplifies data manipulation in solver subroutines, but makes things a little bit more difficult if dealing with the coding of pointwise defined boundary and initial condition as well as body forces and parameter functions. In the Elmer Solver the type \texttt{Element\_t} contains information on elements.
%--------------------------------------------------
\subsection{How to Read Values from the Input File}
In the Elmer Solver the entries of each section of the solver input file -- such as material, body force and initial condition --  are accessed via pointer of the defined data type \texttt{ValueList\_t}, further referred to as ``list''. A list provides access to all the information that has been passed to the Elmer Solver from the solver input files, related to the specific section. 

The principal connection between the solver input file and the access from a user function is depicted in Fig. \ref{fig:sif_code}
\begin{figure}[tbhp]
\begin{center}
\epsfig{figure=sif_code.eps, width=\textwidth,angle=0}
\caption{\label{fig:sif_code} Scheme of the access of structures in the solver input file from a Fortran~90 user subroutine. The example shows, how a string is read in from the \texttt{Solver} section.}
\end{center}
\end{figure}
\subsubsection{How to Access Different Sections}
The following table shows the definition of the functions defined in the module \texttt{DefUtils} to provide the correct list for parameters and constants concerning the simulation and solvers
\begin{center}
\begin{tabular}{l l}
\textbf{function} & \textbf{corresponding section}\\[2ex]
\texttt{GetSimulation()} & \texttt{Simulation} \\
\texttt{GetConstants()} & \texttt{Constants} \\
\texttt{GetSolverParams()} & \texttt{Solver \textit{1,\ldots}}
\end{tabular}
\end{center}
For instance, the following source code lines provide access to the entries in the simulation section of the solver input file
\ttbegin
! variable declaration for pointer on list
TYPE(ValueList_t), POINTER :: Simulation
\ldots
! assign pointer to list
Simulation => GetSimulation()
\ldots
\ttend
Lists that provide information connected to a certain element are
\begin{center}
\begin{tabular}{l l}
\textbf{function} & \textbf{corresponding section}\\ [2ex]
\texttt{GetMaterial(  Element, Found )} & \texttt{Material \textit{1,\ldots}} \\
\texttt{GetBodyForce( Element, Found )} & \texttt{Bodyforce \textit{1,\ldots}} \\
\texttt{GetEquation( Element, Found )} & \texttt{Equation \textit{1,\ldots}}\\
\texttt{GetBC( UElement )} & \texttt{Boundary Condition  \textit{1,\ldots}}\\
\end{tabular}
\end{center}
In the first three of these functions shown above the optional variable \texttt{Found} of type \texttt{LOGICAL} is set to \texttt{.TRUE.} upon successful search in the solver input file. Hence, it can be used for error handling. The arguments \texttt{Element} and \texttt{UElement} are of type \texttt{Element\_t}. If writing a solver, the current element is known and hence can directly be passed to the functions listed above. Else, this argument may also be omitted. However, Elmer Solver needs to have the information upon the element in order to inquire the number of the material/bodyforce/equation/boundary condition section from the solver input file. Hence, if this function argument is dropped, Elmer Solver falls back to the structure \texttt{CurrentModel \% CurrentElement}, which by the active solver has to be assigned to the address of the current element (see section \ref{programming:howtosolver}).

The functions for input of different values from the solver input file  need the assigned pointer to the corresponding to the specific section.
\subsubsection{Reading Constants from the Solver Input File}
The following value types are defined for the solver input file:
\begin{center}
\begin{tabular}{c p{0.44\textwidth}}
\textbf{Value in Input File} & \textbf{Variable in Elmer Solver}\\[2ex]
\texttt{Real} & \texttt{Real(KIND=dp)}\\
\texttt{Integer} & \texttt{INTEGER}\\
\texttt{Logical} & \texttt{LOGICAL}\\
\texttt{String} & \texttt{CHARACTER(LEN=MAX\_NAME\_LEN)}\\
\texttt{File} & \texttt{CHARACTER(LEN=*)}\\
\end{tabular}
\end{center}
The defined interface of such a function is
\ttbegin
FUNCTION \textit{FunctionName}( List, Name, Found ) Result(x)
   TYPE(ValueList_t), POINTER :: List
   CHARACTER(LEN=*) :: Name
   LOGICAL, OPTIONAL :: Found
\ttend
The arguments have the following purpose
\begin{center}
\begin{tabular}{c p{0.75\textwidth}}
\texttt{List} & List from which the value has to be read. This pointer has to be obtained by one of the previously introduced functions\\
\texttt{Name} & The keyword in the particular section for the value\\
\texttt{Found} & Optional boolean variable that contains the value \texttt{.TRUE.} upon successful read in
\end{tabular}
\end{center}
The type of the returned of value, \texttt{x}, is depending on the function.
The following functions are declared in the \texttt{DefUtils} module:
\begin{itemize}
\item A value of type \texttt{REAL} is read in using the function
\ttbegin
REAL(KIND=dp) :: r
\ldots
r = GetConstReal( List, Name, Found )
\ttend

\item A variable of type \texttt{INTEGER} is read in using the function
\ttbegin
INTEGER :: i
\ldots
i = GetInteger( List, Name, Found )
\ttend

\item A string is read into a user function or solver by the following code line
\ttbegin
CHARACTER(LEN=MAX_NAME_LEN) :: str
\ldots
str = GetString( List, Name, Found )
\ttend
\end{itemize}
It is important to note that these routines are only meant for reading in constant values. Consequently, these values must not be dependent on other variables.
\subsubsection{Reading Mesh-values from the Solver Input File}
The previously introduced function \texttt{GetConstReal} is defined for reading in a constant value of type \texttt{REAL(KIND=dp)}. In the case if values have to be obtained for nodes of an element defined on the mesh (e.g., an initial condition, a boundary condition or a material parameter), the following function has to be used
\ttbegin
FUNCTION GetReal( List, Name, Found, UElement ) RESULT(x)
   TYPE(ValueList_t), POINTER :: List
   CHARACTER(LEN=*) :: Name
   LOGICAL, OPTIONAL :: Found
   TYPE(Element_t), OPTIONAL, TARGET :: UElement
   REAL(KIND=dp) :: x(CurrentModel \% CurrentElement \% Type \% NumberOfNodes)
\ttend
The returned value, \texttt{x}, is a one-dimensional array of type \texttt{REAL(KIND=dp)} with entries for every node of the either given element \texttt{UElement} or alternatively the default structure \texttt{CurrentModel \% CurrentElement}. For instance, reading in the material parameter \texttt{Viscosity} from an already assigned pointer of type \texttt{ValueList\_t} for a given element, \texttt{Element}, is done by the following code lines
\ttbegin
REAL(KIND=dp), ALLOCATABLE :: viscosity(:)
INTEGER :: NoNodes
TYPE(ValueList_t), POINTER :: Material
TYPE(Element_t), POINTER :: Element
LOGICAL :: Found
\ldots
\textit{allocate} viscosity\textit{, set pointers} Material \textit{and} Element
\ldots
NoNodes = GetElementNOFNodes(Element)
\ldots
viscosity(1:NoNodes) = GetReal(Material, 'Viscosity', Found, Element)
\ttend
The user has to make sure that the array that later contains the nodal values is of sufficient size. This, for instance, can be guaranteed by allocating it to the maximal occurring number of nodes for an element in the model
\ttbegin
ALLOCATE(viscosity(CurrentModel \% MaxElementNodes))
\ttend
\subsubsection{Physical Time as Argument of User Function}
If a user function needs physical time as an input, it can be passed as an argument. For instance, if a boundary condition for the normal component of the velocity would have the physical time as the input variable, the function call in the solver input file then would look as follows (see section \ref{programming:UDF} for more details on user functions)
\ttbegin
Boundary Condition \textit{BCNo}
  Name = "time_dependent_outlet"
  Target Boundaries = \textit{BoundaryNo}
  Normal-Tangential Velocity = True
  Velocity 2 = 0.0
  Velocity 1
   Variable Time
   Real Procedure  "\textit{executable}" "timeOutletCondition"
  End
End
\ttend
Here the entries \texttt{\textit{BCNo}} and \texttt{\textit{BoundaryNo}} have to be replaced by the correct boundary condition and boundary target number. The file \texttt{\textit{executable}} should contain the compiled user function \texttt{timeOutletCondition}.
%-----------------------------------------------------------------
\subsection{How to Communicate with Structures Inside Elmer Solver\label{programming:solvercommunication}}
Often it is necessary to get information from inside the Elmer Solver, such as mesh coordinates or field variables associated to another solver procedure. If writing a solver subroutine, all information of that kind is accessible via the type \texttt{TYPE(Solver\_t) :: Solver}. In the case of a user function (boundary condition, initial condition, material parameter), the default structure \texttt{CurrentModel \% Solver} has to be used.
\subsubsection{Inquiring Information on the Element}
As mentioned earlier, most of the pre-defined functions and subroutines inside Elmer Solver apply on the whole element rather than on single nodes. Information on elements can be accessed via the pre-defined type \texttt{Element\_t}. We list the functions/subroutines for the mostly needed purposes:
\begin{itemize}
\item Setting the active element (bulk):
\ttbegin
TYPE(Element_t), POINTER :: Element
Type(Solver_t), Target :: Solver
INTEGER :: ElementNumber
\ldots
Element => GetActiveElement(ElementNumber)
\ttend
The argument \texttt{Solver} is optional. If it is not given, \texttt{CurrentModel \% Solver} is used. This function also automatically sets the pointer \texttt{CurrentModel \% CurrentElement} to the element with the given element number \texttt{ElementNumber}. This is important if sub-sequentially called functions rely on this default value to be set.

The total number of active bulk elements for a specific solver is to be inquired using the value \texttt{Solver \% NumberOfActiveElements}.
\item Setting the active element (boundary):
\ttbegin
TYPE(Element_t), POINTER :: BoundaryElement
INTEGER :: ElementNumber
\ldots
BoundaryElement => GetBoundaryElement(ElementNumber)
\ttend
This routine also sets the structure \texttt{CurrentModel \% CurrentElement} to the boundary element.

In contrary to the domain (i.e., bulk) it is a priory not known which boundary element is part of a boundary condition of a specific solver. This information may be obtained using the function
\ttbegin
Type(Element\_) :: BoundaryElement
LOGICAL :: IsActiveBoundary
\ldots
IsActiveBoundary = BoundaryElement(BoundaryElement,Solver)
\ttend
where both arguments are optional. If they are omitted, Elmer Solver takes the values \texttt{CurrentModel \% CurrentElement} and \texttt{CurrentModel \% Solver}, respectively. The boundary element number, \texttt{ElementNumber} may vary between 1 and the maximum value 
\begin{verbatim}
Solver % Mesh % NumberOfBoundaryElements
\end{verbatim}

\item Inquire number of nodes in an element: 
\ttbegin
INTEGER :: N
TYPE(Element_t) :: Element
\ldots
N = GetElementNOFNodes( Element )
\ttend
The argument \texttt{Element} is optional. The default value is \texttt{CurrentModel \% CurrentElement}
\item Get nodal coordinates for element:
\ttbegin
TYPE(Nodes_t) :: ElementNodes
TYPE(Element_t) :: Element
TYPE(Solver_t) :: Solver
\ldots
CALL GetElementNodes( ElementNodes, Element, Solver )
\ttend
The arguments \texttt{Element} and \texttt{Solver} are optional. The default values are \texttt{CurrentModel \% CurrentElement} and \texttt{CurrentModel \% Solver}, respectively. The argument \texttt{ElementNodes} is of the pre-defined type \texttt{Nodes\_t}. The different components of the coordinates for the i-th node can be accessed by
\ttbegin
REAL(KIND=dp) :: Xcoord, Ycoord, Zcoord
\ldots
Xcoord = ElementNodes \% x(i)
Ycoord = ElementNodes \% y(i)
Zcoord = ElementNodes \% z(i)
\ttend
They correspond to the axes of the defined coordinate system in the solver input file.
\item Get local coordinates of the \texttt{i}-th node for assigned element:
\ttbegin
REAL(KIND=dp) :: U, V, W
TYPE(Element_t), POINTER :: Element
INTEGER :: i
\ldots
U = Element \% Type \% NodeU(i)
V = Element \% Type \% NodeV(i)
W = Element \% Type \% NodeW(i)
\ttend
Local coordinates are corresponding to the position inside the prototype element that is used inside the Elmer Solver. They are important if parameter values have to be obtained by summation over the basis functions.
\item Get normal vector at the \texttt{i}-th node of the assigned boundary element: 
\ttbegin
REAL(KIND=dp) :: U, V, Normal(3)
TYPE(Element_t), POINTER :: BoundaryElement
LOGICAL :: CheckDirection
\ldots
U = BoundaryElement \% Type \% NodeU(i)
V = BoundaryElement \% Type \% NodeV(i)
Normal = NormalVector( BoundaryElement, Nodes, U, V, CheckDirection ) 
\ttend
The function needs the boundary element as well as the local coordinates of the point, where the surface (edge) normal shall be evaluated. The optional last argument, \texttt{CheckDirection}, is a boolean variable. If set to \texttt{.TRUE.}, the direction of the normal is set correctly to the rules given in section \ref{programming:boundaryUDF}. The surface normal is returned in model coordinates and is of unity length.
\end{itemize}
\subsubsection{Inquiring Nodal Values of Field Variables}
Nodal values for an element of a scalar variables are read by the subroutine
\ttbegin
SUBROUTINE GetScalarLocalSolution( x,name,UElement,USolver )
     REAL(KIND=dp) :: x(:)
     CHARACTER(LEN=*), OPTIONAL :: name
     TYPE(Solver_t)  , OPTIONAL, TARGET :: USolver
     TYPE(Element_t),  OPTIONAL, TARGET :: UElement
\ttend
The returned value is an array containing the nodal values of the variable \texttt{name}. If this variable name is not provided, it is assumed that the corresponding solver \texttt{USolver} has only one variable with a single degree of freedom. If the optional parameters \texttt{USolver} and \texttt{UElement} are not provided, then the default values \texttt{CurrentModel \% Solver} and \texttt{CurrentModel \% CurrentElement}, respectively, are used.

For instance, the following code lines read in the nodal element values for the variable \texttt{Temperature} (from the heat solver)
\ttbegin
REAL(KIND=dp), ALLOCATABLE :: localTemp(:)
ALLOCATE(localTemp(CurrentModel \% MaxElementNodes))
\ldots
CALL GetScalarLocalSolution(localTemp, 'Temperature')
\ttend
In the case of a vector field variable, the analog function\linebreak \texttt{GetVectorLocalSolution} has to be used. For instance, if the user wants to read in the local velocity of an deforming mesh (from the MeshSolver), the following syntax has to be applied
\ttbegin
REAL(KIND=dp) , ALLOCATABLE :: localMeshVelocity(:,:)
ALLOCATE(localMeshVelocity(3,Solver \% Mesh \% MaxElementNodes)
\ldots
CALL GetVectorLocalSolution( MeshVelocity, 'Mesh Velocity')
\ttend
\subsubsection{Inquiring Values of Field Variables for the Whole Mesh}
Sometimes, the user also would like to have values for a field variable of the complete domain accessible. This is done by assigning a pointer to the variable using the function \texttt{VariableGet}
\ttbegin
VariablePointer => VariableGet(Solver \% Mesh \% Variables, '\textit{Variable}' )
\ttend
The argument \texttt{\textit{Variable}} has to be replaced by the variable name. The returned pointer is of type \texttt{Variable\_t}. This type contains the following components
\begin{center}
\begin{tabular}{p{0.45\textwidth}  p{0.45\textwidth}}
\textbf{component}                            & \textbf{purpose}\\[2ex]
\texttt{INTEGER, POINTER :: Perm(:)} & Contains permutations for the variable. Since Elmer Solver tries to optimize the matrix structure, the numbering of the nodal values of the variable usually does not coincide with the numbering of the mesh-nodes. The is used to identify the mesh-node for a variable-entry. Hence, the field \texttt{VariablePointer \% Perm(i)} contains the nodal number of the \texttt{i}-th value of the field variable \texttt{\textit{Variable}}. \\
\texttt{INTEGER :: DOFs} & Contains the amount of vector components of the variable. \texttt{DOFs} is 1 in case of a scalar, 2 or 3 in case of a two- or three-dimensional vector field.\\
\texttt{REAL(KIND=dp), POINTER :: Values(:)} & contains the values of the field variable
\end{tabular}
\end{center}
For instance, in order to get access to the temperature field (similar as in the example above), the following code lines may be used
\ttbegin
TYPE(Variable_t), POINTER :: TempVar
INTEGER, POINTER :: TempPerm(:)
REAL(KIND=dp), POINTER :: Temperature(:)
INTEGER :: ElmentNo, N
REAL(KIND=dp), ALLOCATABLE :: localTemp(:)
ALLOCATE(localTemp(CurrentModel \% MaxElementNodes))
TYPE(Element_t), POINTER :: Element
\ldots
TempVar => VariableGet( Solver \% Mesh \% Variables, 'Temperature' )
IF ( ASSOCIATED( TempVar) ) THEN
  TempPerm    => TempVar \% Perm
  Temperature => TempVar \% Values
!!!! stop if temperature field has not been found !!!!
ELSE IF 
  CALL Fatal('MyOwnSolver', 'No variable Temperature found')
END IF
\ldots
DO ElementNo = 1,Solver \% NumberOfActiveElements
   Element => GetActiveElement(ElementNo)
   N = GetElementNOFNodes()
   NodeIndexes => Element \% NodeIndexes
   localTemp(1:N) = Temperature(TempPerm(Element \% NodeIndexes))
END DO
\ttend
It is recommended to check whether the pointer to the variable has been assigned correctly. In our little example the call of the routine \texttt{Fatal} would stop the simulation run if the assessment would lead to a negative result.
\subsubsection{Inquiring the Current Time}
In certain situations in transient simulations the physical time might be needed in a user function. In Elmer Solver the physical time is treated as a variable and hence has to be read in using the type \texttt{Variable\_t}
\ttbegin
TYPE(Variable\_t), POINTER :: TimeVar
Real(KIND=dp) :: Time
\ldots
TimeVar => VariableGet( Solver \% Mesh \% Variables, 'Time' )
Time = TimeVar \% Values(1)
\ttend
\subsubsection{How to Post Messages}
Including \texttt{PRINT} or \texttt{WRITE} statements to stdio in numeric-codes can lead excessive output (large number of iterations and/or large model sizes) and consequently to a reduction in performance. It is recommended to use stdio-output routines provided by Elmer Solver, for which to a certain extend the amount of output can be controlled via the solver input file. The three pre-defined subroutines for output of messages are:
\begin{itemize}
\item \texttt{Info} is used for displaying messages (e.g., upon convergence) on the screen. The syntax is
\ttbegin
CALL Info('FunctionName','The displayed message', level=\textit{levelnumber})
\ttend
The first string shall indicate which function the displayed message comes from. The second entry is a string that contains the message itself. The integer value  \texttt{\textit{levelnumber}} indicates the importance of the message, starting from 1 (most important). The maximum level of messages being displayed can be determined in the simulation section  of the solver input file
\ttbegin
max output level = 3
\ttend
\item \texttt{Warn} is used for displaying warnings. Warnings are always displayed and should be used if conditions in the code occur that might lead to possible errors
\ttbegin
CALL Warn('FunctionName','The displayed warning')
\ttend
\item \texttt{Fatal} is used to terminate the simulation displaying a message. Consequently, it is used in conditions in the code where a continuation of the computation is impossible
\ttbegin
CALL Fatal('FunctionName','The displayed error message')
\ttend
\end{itemize}
Of course the strings do not have to be hard-coded but can be composed during run-time, using the \texttt{WRITE} command. The string variable \texttt{Message} is provided for that purpose
\ttbegin
WRITE(Message,\textit{formatstring}) \textit{list, of, variables}
CALL Info('FunctionName',Message, level=3)
\ttend
The format-string has to be set according to the list of variables. 
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Writing a User Function\label{programming:UDF}}
User functions can be used to provide a pointwise (not element wise!) value for a certain property. They are used for setting values of material properties inside the domain and/or to set values for certain variables on boundary conditions at the domain boundary.

The defined interface for a user function looks as follows
\ttbegin
FUNCTION myfunction( model, n, var ) RESULT(result)
  USE DefUtils
  IMPLICIT None
  TYPE(Model_t) :: model
  INTEGER :: n
  REAL(KIND=dp) :: var, result

  \ldots \textit{contents of the function}
  \textit{leading to a value for variable} result \ldots

END FUNCTION myfunction
\ttend
The function returns the value \texttt{result}. If this is supposed to be a nodal value of a material property or a variable condition, the variable type in Elmer has to be real double precision, hence, \texttt{REAL(KIND=dp)}.\newline
The first argument passed to the function, \texttt{model}, is of the declared type \texttt{Model\_t}. It is basically the interface to all information accessible at runtime, such as variable values, mesh coordinates and boundary conditions.\newline
The second argument, \texttt{n}, is the integer number of the node for which the function  - i.e., the value \texttt{result} -  is is evaluated.
Through the last argument, \texttt{var}, a value of an input variable  on which the result depends is passed to the function. In the solver input file this variable is indicated using the \texttt{Variable}-keyword. For instance (see examples later in this chapter), if the user wants to provide the function above with the result being the density which -- in this particular case -- depends on the temperature, the syntax looks as follows
\ttbegin
Density  = Variable Temperature
  Procedure "filename" "myfunction"
\ttend
Mind that there always \underline{has to be} an input variable to be given using this keyword. In the case that there is no need for an input, this may occur as a dummy argument in the function.
%------------------------------------------------
\subsection{User Functions for Domain Properties\label{programming:UDF_bulk}} 
In the following we will give an outline of the main issues concerning the preparation of a user function for a domain property. This might be of use if a material parameter (from material section of the solver input file), an initial condition (from solver input file initial condition section) or a body force (from solver input file body force section) of somewhat higher complexity has to be defined for the domain.

Some basic aspects concerning the syntax of such functions shall be explained by the following examples:

\subsubsection{Example: Viscosity as a Function of Temperature}
This example demonstrates the following topics:
\begin{itemize}
   \item definition of a material property dependent on one input variable
   \item how to read in a value from the material section of the solver input file
\end{itemize}
\noindent We want to implement the following relation for the dynamic viscosity, $\mu$, of a fluid
\begin{equation}
  \label{eq:viscosityTemp}
  \mu(T) = \mu_{293 \textrm{K}}\, \exp\left[C\cdot\left(\frac{293}{T} - 1\right)\right]
\end{equation}
where $T$ is the temperature. The parameters $\mu_{293 \textrm{K}}$ (i.e., the reference viscosity at 293 Kelvin) and $C$ have to be read into our function from the material section of the solver input file. Thus, the material section looks as follows:
\ttbegin
! Material section (ethanol)
! --------------------------
Material 1
  \ldots
  Viscosity = Variable Temperature
  Procedure "fluidproperties" "getViscosity"
  \ldots
  Reference Viscosity = Real 1.2E-03
  Parameter C = Real 5.72
  \ldots
End
\ttend
The values $\mu_{293 \textrm{K}} = 1.2\cdot 10^{-3}$ and $C=5.72$ are the numerical values of the parameter occurring in \eqref{eq:viscosityTemp} for pure ethanol. The executable containing the function named \texttt{getViscosity} will be called \texttt{fluidproperties}. The header -- including the variable declaration -- of the function then reads as follows:
\ttbegin
!-----------------------------------------------------
! material property function for ELMER:
! dynamic fluid viscosity as a function of temperature 
!-----------------------------------------------------
FUNCTION getViscosity( model, n, temp ) RESULT(visc)
  ! modules needed
  USE DefUtils

  IMPLICIT None

  ! variables in function header
  TYPE(Model_t) :: model
  INTEGER :: n
  REAL(KIND=dp) :: temp, visc

  ! variables needed inside function
  REAL(KIND=dp) :: refVisc, C
  Logical :: GotIt
  TYPE(ValueList_t), POINTER :: material
\ttend
In order to get the pointer to the correct material-list, we use the function \texttt{GetMaterial}
\ttbegin
  ! get pointer on list for material
  material => GetMaterial()
  IF (.NOT. ASSOCIATED(material)) THEN
     CALL Fatal('getViscosity', 'No material found')
  END IF
\ttend
We immediately check, whether the pointer assignment was successful. In the case of the NULL-pointer being returned, the pre-defined procedure \texttt{Fatal} will stop the simulation and stdio will display the the message: \texttt{(getViscosity): No material-id found}

\noindent The next step is to read in the numerical values for the parameter:
\ttbegin
  ! read in reference viscosity
  refvisc = GetConstReal( material, 'Reference Viscosity', GotIt)
  IF(.NOT. GotIt) THEN
     CALL Fatal('getViscosity', 'Reference Viscosity not found')
  END IF

  ! read in parameter C
  C = GetConstReal( material, 'Parameter C', GotIt)
  IF(.NOT. GotIt) THEN
     CALL Fatal('getViscosity', 'Parameter C not found')
  END IF

\ttend
The variable \texttt{GotIt} contains the state of success of the input. In the case of unsuccessful read-in (i.e., the variable \texttt{GotIt} shows the value \texttt{.FALSE.}), the simulation will be stopped by the routine \texttt{Fatal}.

\noindent Finally, after a check upon the absolute temperature being larger than zero, the viscosity is computed according to equation \eqref{eq:viscosityTemp}
\ttbegin
  ! compute viscosity
  IF (temp <= 0.0D00) THEN ! check for physical reasonable temperature
     CALL Warn('getViscosity', 'Negative absolute temperature.')
     CALL Warn('getViscosity', 'Using viscosity reference value')
     visc = refVisc(1)
  ELSE  
     visc = refVisc * EXP(C *(2.93D02/temp - 1.0D00))
  END IF

END FUNCTION getViscosity
\ttend
In the case of negative absolute temperature, the reference value will be returned. The pre-defined routine \texttt{Warn} will display a specific warning on stdio.
\subsubsection{Example: Body Force as a Function of Space}
For the use as body force for the solver presented in \ref{programming:howtosolver} (i.e. heat source distribution for heat conduction equation), we want to write a function that provides a scalar in the domain as a function of space. This example demonstrates the following topics:
\begin{itemize}
   \item definition of a scalar in the domain as function of space in two dimensions
   \item how to inquire the dimension of the problem
\end{itemize}
\noindent We want to implement the following two-dimensional spatial distribution for the scalar $h$:
\begin{equation}  
\label{eq:loadDist}
h(x,y) = -\cos(2\,\pi\,x)\cdot\sin(2\,\pi\,y),\quad x,y \in [0,1]
\end{equation}
where $x$ corresponds to \texttt{Coordinate 1} and $y$ to \texttt{Coordinate 2} of the solver input file.


Since the function given in \eqref{eq:loadDist} is dependent on two input variables, the single argument that is able to be passed to the function is not sufficient. Hence it will just be used as dummy argument. Consequently, the user can provide any (existing!) variable as argument in the solver input file. The header reads as follows
\ttbegin
!-----------------------------------------------------
! body force function for ELMER:
!   scalar load as function of coordinates x and y
!                -cos(2*pi*x)*sin(2*pi*y)  
!-----------------------------------------------------
FUNCTION getLoad( model, n, dummyArgument ) RESULT(load)
  ! modules needed
  USE DefUtils

  IMPLICIT None

  ! variables in function header
  TYPE(Model_t) :: model
  INTEGER :: n
  REAL(KIND=dp) :: dummyArgument, load

  ! variables needed inside function
  INTEGER :: DIM
  REAL(KIND=dp) :: x, y
  Logical :: FirstVisited = .TRUE.

  ! remember these variables    
  SAVE DIM, FirstVisited
\ttend
Further we want to check whether the problem is two-dimensional and hence suitable for our function. This is done only the first time the function is called, since - hopefully - the dimension of the problem does not change during all the following calls. The function returning the problem dimension is \texttt{CoordinateSystemDimension()}
\ttbegin
  ! things done only the first time the function is visited
  IF (FirstVisited) THEN
     ! check whether we are dealing with a 2d model
     DIM = CoordinateSystemDimension()
     IF (DIM /= 2) THEN
        CALL FATAL('getLoad', 'Dimension of model has to be 2d')
     END IF
     FirstVisited = .FALSE.
  END IF
\ttend
The next step to inquire the coordinates of the current point the function is evaluated for. The structure \texttt{model} contains that information
\ttbegin
  ! get the local coordinates of the point
  x = model \% Nodes \% x(n)
  y = model \% Nodes \% y(n)
\ttend
Finally, the result is computed
\ttbegin
  ! compute load 
  load = -COS(2.0D00*PI*x) * SIN(2.0D00*PI*y)

END FUNCTION getLoad
\ttend
Figure \ref{fig:load} shows the result of a simulation using the solver defined in section \ref{programming:howtosolver} together with the function \texttt{getLoad} as body force.
\begin{figure}[tbhp]
\begin{center}
\epsfig{figure=load.ps, width=0.66\textwidth,angle=0}
\caption{\label{fig:load} Result obtained with the routine \texttt{getLoad} as body force input for the heat conduction solver presented in \ref{programming:howtosolver}. The $z$-coordinate is set proportional to the result obtained in the $x$-$y$ plane.}
\end{center}
\end{figure}
The entry in the body force section of the solver input file reads as follows:
\ttbegin
Body Force 1
  Heat Source 
   Variable Temp      !just a dummy argument
   Real Procedure "load" "getLoad"
End
\ttend
where the shared object file has been given the name \texttt{load}. All boundaries are set to adiabatic boundary condition, i.e., $\nabla T\cdot\vec{n} = 0$. This is possible if -- and only if -- the integral over the load vector over the whole domain balances to zero, like in our case. Since no Dirichtlet condition is set, the result is not unique and contains an undetermined offset $T_{0}$. 
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{User Functions for Boundary Conditions\label{programming:boundaryUDF}}
As for the user functions for bulk properties presented in section \ref{programming:UDF_bulk},  the function for a boundary property is evaluated pointwise. Hence, the identical function interface is used. The major difference between bulk elements and elements on boundaries are, that the latter can be associated to more than one body. That is the case on boundaries between bodies. This is important in such cases where the boundary condition is dependent on properties inside a specific body to which the boundary is attached. Possible configurations of boundaries are depicted in Fig. \ref{programming:fig:boundary}. 
\begin{figure}[tbhp]
\begin{center}
\epsfig{figure=boundary.eps, width=\textwidth,angle=0}
\caption{\label{programming:fig:boundary} Possible constellations for boundaries and the normal vectors, $\vec{n}$ at element nodes. Mind, that for a body-body interface (case b) the default orientation of the surface normal may vary from element to element. At boundary points that have a discontinuous first derivative of the surface (i.e. at corners and edges), the evaluation of the normal at the same point for two adjacent boundary elements leads to different surface normals. Parent elements of boundary elements for the specific body are marked as filled.}
\end{center}
\end{figure}

If the keyword for checking the directions in the function \texttt{NormalVector} (see section \ref{programming:solvercommunication}) is set to \texttt{.TRUE.}, the following rules apply:
\begin{itemize}
\item In the case of an outside boundary the surface normal, $\vec{n}$, is always pointing outwards of the body.
\item By default on a body-body boundary, the orientation is such that the normal always is pointing towards the body with lower density, $\varrho$, which is evaluated by comparison of the values given for the keyword \texttt{Density} in the corresponding material sections of the adjacent bodies.
\end{itemize}
In certain cases, if densities on both sides are either equal or varying functions of other variables, this may lead to a varying orientation of the surface. This effect and the effect of different directions of surface normal for the same point at surface corners and edges is depicted in Fig.~\ref{programming:fig:boundary}. Whereas the latter effect can only be dealt with by either producing smooth surfaces or averaging surface normals, the first problem can be overcome by providing the keyword \texttt{Normal Target Body} in the solver input file. This keyword defines the direction of the surface normals for the pre-defined subroutine \texttt{NormalVector}. For instance, the following sequence fixes the surface normal at boundary condition number 1 to point into body number 2

\ttbegin
Boundary Condition 1
  Target Boundaries = 1
  Normal Target Body = Integer 2
\ldots
End
\ttend
%------------------------------------------------------------------------
\subsubsection{Example: Idealized Radiation Law for External Heat Transfer\label{programming:example_boundary}}
As an illustrative example we want to show how to implement a very idealized radiation boundary condition for heat transfer. This example explains:
\begin{itemize}
\item how to identify the type of boundary according to Fig.~\ref{programming:fig:boundary}
\item how to get material parameters from domain parent elements of the boundary element
\item how to identify the local node number in an elment
\item how to inquire boundary normals
\end{itemize}
The net flux into the body at such a boundary shall be approximated by
\begin{subequations}
\begin{equation}\label{programming:radiation}
q_{n} = \epsilon\,q_{\mathrm{ext}} -  \epsilon\sigma\cdot\left(T^{4} - T_{\mathrm{ext}}^{4}\right),
\end{equation}
where $T_{\mathrm{ext}}$ is the external temperature, $\sigma$ stands for the Stefan-Boltzmann constant and $\epsilon$ is the emissivity. The external heat flux shall be defined as
\begin{equation}\label{programming:extflux}
q_{\mathrm{ext}} = \begin{cases} -I \vec{s}\cdot\vec{n},&  \vec{s}\cdot\vec{n} < 0, \\ 0,& \text{else}, \end{cases} 
\end{equation}
\end{subequations}
where $I$ is the intensity and $\vec{s}$ the direction of the incoming radiation vector. The surface normal, $\vec{n}$, is assumed to point outwards the body surface.

Since we are planning to use this boundary condition in connection with the solver presented in section \ref{programming:example_heat}, we have to provide the load vector $l=q_{n}/(c_{p}\,\varrho)$ occurring in the force vector of \eqref{programming:matrices}. This means that we have to inquire the material parameters $c_{p}$ and $\varrho$ for the parent element from the material section of the adjacent body.

The header of the function reads as
\ttbegin
!-----------------------------------------------------
! boundary condition function for ELMER:
!  simplified radiation BC
!-----------------------------------------------------
FUNCTION simpleRadiation( model, n, temp ) RESULT(load)
  ! modules needed
  USE DefUtils

  IMPLICIT None

  ! variables in function header
  TYPE(Model\_t) :: model
  INTEGER :: n
  REAL(KIND=dp) :: temp, load

  ! variables needed inside function
  REAL(KIND=dp), ALLOCATABLE :: Density(:), HeatCapacity(:), ExtTemp(:)
  REAL(KIND=dp), POINTER :: Work(:,:)
  REAL(KIND=dp) :: radvec(3), Normal(3), NormDir, U, V,&
       Emissivity, normalabsorbtion, emission, StefanBoltzmann
  INTEGER :: DIM, other_body_id, nboundary, nparent,&
       BoundaryElementNode, ParentElementNode, istat
  Logical :: GotIt, FirstTime=.TRUE., Absorption = .TRUE.
  TYPE(ValueList\_t), POINTER :: ParentMaterial, BC
  TYPE(Element\_t), POINTER :: BoundaryElement, ParentElement
  TYPE(Nodes\_t) :: ElementNodes

  SAVE FirstTime, Density, HeatCapacity, ExtTemp
!-----------------------------------------------------------------------
\ttend
The boundary element and the pointer to the list of the corresponding Boundary Condition-entry in the solver input file are assigned
\ttbegin
! -----------------------
! get element information
! -----------------------
  BoundaryElement => CurrentModel \% CurrentElement
  IF ( .NOT. ASSOCIATED(BoundaryElement) ) THEN
     CALL FATAL('simpleRadiation','No boundary element found')
  END IF

  BC => GetBC()
  IF ( .NOT. ASSOCIATED(BC) ) THEN
     CALL FATAL('simpleRadiation','No boundary condition found')
  END IF
\ttend
Thereafter, a case distinction between the two possible constellations in Fig. \ref{programming:fig:boundary} (i.e.,outside or body-body boundary). A outside boundary is indicated by the value -1 of \texttt{BoundaryElement \% BoundaryInfo \% outbody}. In the case of a boundary-boundary interface the surface normal is supposed to point outwards. I.e., the body hosting the parent element is taken the one for which \texttt{ParentElement \% BodyId} does not coincide with \texttt{BoundaryElement \% BoundaryInfo \% outbody}
\ttbegin
  other_body_id = BoundaryElement \% BoundaryInfo \% outbody
  ! only one body in simulation
  ! ---------------------------
  IF (other_body_id < 1) THEN 
     ParentElement => BoundaryElement \% BoundaryInfo \% Right
     IF ( .NOT. ASSOCIATED(ParentElement) )&
          ParentElement => BoundaryElement \% BoundaryInfo \% Left
  ! we are dealing with a body-body boundary 
  ! and assume that the normal is pointing outwards
  ! -----------------------------------------------
  ELSE 
     ParentElement => BoundaryElement \% BoundaryInfo \% Right
     IF (ParentElement \% BodyId == other_body_id)&
          ParentElement => BoundaryElement \% BoundaryInfo \% Left
  END IF

  ! just to be on the save side, check again 
  ! ----------------------------------------
  IF ( .NOT. ASSOCIATED(ParentElement) ) THEN
     WRITE(Message, *)&
          'No parent element found for boundary element no. ', n
     CALL FATAL('simpleRadiation',Message)
  END IF
\ttend
After that procedure the pointer \texttt{ParentElement} is set on the adjacent element of the boundary element inside the body for which the radiation boundary condition is evaluated.

We further need the total number of nodes in the boundary element and the parent element given by \texttt{nboundary} and \texttt{nparent}, respectively. Also the corresponding number of the boundary node number, \texttt{n}, in the parent element, \texttt{ParentElementNode}, as well as in the boundary element itself, \texttt{BoundaryElementNode}, is evaluated. At the end of this code sequence, the routine \texttt{GetElementNodes} sets the information on the nodes of the boundary element
\ttbegin
  ! get the corresponding node in the elements
  ! ------------------------------------------
  nboundary = GetElementNOFNodes(BoundaryElement)
  DO BoundaryElementNode=1,nboundary
     IF (  n == BoundaryElement \% NodeIndexes(BoundaryElementNode) ) EXIT
  END DO
  nparent = GetElementNOFNodes(ParentElement)
  DO ParentElementNode=1,nboundary
     IF (  n == ParentElement \% NodeIndexes(ParentElementNode) ) EXIT
  END DO

  ! get element nodes
  ! -----------------
  CALL GetElementNodes(ElementNodes, BoundaryElement)
\ttend
The needed space for reading material parameter fro the parent element as well as boundary condition parameters for the boundary element is allocated. In the case of the function being re-visited, we first do a deallocation, since  the values of \texttt{nboundary} or \texttt{nparent} may change from element to element (hybrid mesh)
\ttbegin
! -----------
! Allocations
! ----------- 
  IF (.NOT.FirstTime) THEN 
     DEALLOCATE(Density, HeatCapacity, ExtTemp)
  ELSE
     FirstTime = .FALSE.
  END IF
  ALLOCATE(Density( nparent ), HeatCapacity( nparent ),& 
       ExtTemp(nboundary), stat=istat)
  IF (istat /= 0) CALL FATAL('simpleRadiation', 'Allocations failed')
\ttend
The following code lines read the values for the parameters associated with the boundary element and the Stefan-Boltzmann constant from the solver input file
\ttbegin
! --------------------------------------
! get parameters from constants section 
!     and boundary condition section
! --------------------------------------  
  DIM = CoordinateSystemDimension()
  StefanBoltzmann = ListGetConstReal( Model \% Constants, &
       'Stefan Boltzmann',GotIt)
  IF (.NOT. GotIt) THEN ! default value in SI units
     StefanBoltzmann = 5.6704D-08 
  END IF
  Emissivity = GetConstReal( BC,'Emissivity',GotIt)
  IF ((.NOT. GotIt) .OR. &
   ((Emissivity < 0.0d0) .OR. (Emissivity > 1.0d0))) THEN
     load = 0.0d00
     CALL WARN('simpleRadiation','No Emissivity found.')
     RETURN ! no flux without or with unphysical emissivity
  END IF

  ExtTemp(1:nboundary) = GetReal( BC,'External Temperature',GotIt)
  IF (.NOT.GotIt) THEN
     WRITE (Message,*) 'No external temperature defined at point no. ', n 
     CALL Warn('simpleRadiation', Message)
     ExtTemp(1::nboundary)= temp
  END IF
  
  Work => ListGetConstRealArray( BC,'Radiation Vector',GotIt)
  IF ( GotIt ) THEN
     radvec = 0.0D00
     NormDir =  SQRT(SUM(Work(1:DIM,1) * Work(1:DIM,1)))
     IF (NormDir /= 0.0d00) THEN
        radvec(1:DIM) = Work(1:DIM,1)*Work(4,1)/NormDir
     ELSE ! no radiation for weird radiation vector
        Absorption = .FALSE.
     END IF
  ELSE ! no absorption without radiation vector
     Absorption = .FALSE.
  END IF
\ttend
If absorption of an incoming radiation vector has to be computed, the surface normal has to be inquired
\ttbegin
! ---------------------------------
! get surface normals ( if needed )
! ---------------------------------
  IF (Absorption) THEN
     U = BoundaryElement \% Type \% NodeU(BoundaryElementNode)
     V = BoundaryElement \% Type \% NodeV(BoundaryElementNode)
     Normal = NormalVector(BoundaryElement, ElementNodes, U, V, .TRUE.)
  END IF
\ttend
Thereafter, the needed material parameters are read from the material section of the solver input file that associated with the body for which the radiation boundary condition is computed
\ttbegin
! -------------------------------------------
! get material parameters from parent element
! -------------------------------------------
  ParentMaterial => GetMaterial(ParentElement)
  ! next line is needed, if the consequently read 
  ! parameters are themselves user functions
  ! ---------------------------------------------
  CurrentModel \% CurrentElement => ParentElement
  Density(1:nparent) = GetReal(ParentMaterial, 'Density', GotIt)
  IF (.NOT.GotIt) Density(1:nparent) = 1.0d00
  HeatCapacity(1:nparent) = GetReal(ParentMaterial, 'Heat Capacity', GotIt)
  IF (.NOT.GotIt) HeatCapacity(1:nparent) = 1.0d00

  ! put default pointer back to where it belongs
  ! --------------------------------------------
  CurrentModel \% CurrentElement => BoundaryElement
\ttend
Since these material parameters themselves may be given in form of user functions, the default pointer \texttt{CurrentModel \% CurrentElement} has to be set to the parent element upon call of the function \texttt{GetReal}. 

Finally the two parts of the total normal heat flux are evaluated. The external load is obtained by dividing this Laue by the inquired values for \texttt{Density} and \texttt{HeatCapacity}.
\ttbegin
!------------------------------------
! compute flux and subsequently load
!-----------------------------------
  IF (Absorption) THEN
     normalabsorbtion = -1.0D00 & ! since normal pointing outwards
          * Emissivity * DOT_PRODUCT(Normal,radvec) 
     IF (normalabsorbtion < 0.0d0) &
          normalabsorbtion = 0.0d00
  ELSE
     normalabsorbtion = 0.0d00
  END IF

  emission = StefanBoltzmann * Emissivity * &
       ( temp**4 - ExtTemp(BoundaryElementNode)**4) &
       / (HeatCapacity(ParentElementNode) * Density(ParentElementNode))

  load = normalabsorbtion + emission
  
END FUNCTION simpleRadiation
\ttend

Figure \ref{programming:fig:radiation} shows the result of the heat conduction solver presented in section \ref{programming:howtosolver} in combination with the function \texttt{simpleRadiation} as boundary condition on two oppositely directed boundaries (boundary condition no. 1). Since the radiation vector is aligned with the $x$-direction and hence  perpendicular with respect to these two boundaries, the absorption part vanishes for one of these boundaries.
\begin{figure}[tbhp]
\begin{center}
\epsfig{figure=simpleradiation.ps, width=0.66\textwidth,angle=0}
\caption{\label{programming:fig:radiation} Result of the heat conduction solver applying the simplified radiation boundary condition described in this section. The coordinate directions as well as the number of the corresponding boundary condition section are shown. The latter can be compared to the solver input file entries shown in this section.}
\end{center}
\end{figure}
For the sake of simplicity, the material parameters $\varrho$, $c_{p}$ and $k$ have been set to unity. The corresponding entries of the solver input file for the boundary conditions of the case shown in Fig. \ref{programming:fig:radiation} are:
\ttbegin
Boundary Condition 1
  Target Boundaries(2) = 1 2
  Boundary Type = String "Heat Flux"
  External Load  
        Variable Temp
        Real Procedure "radiation_flux.exe" "simpleRadiation"
  External Temperature = Real -20.0E00
  Radiation Vector(4) = Real -1.0E00 0.0E00  0.0E00  1.0E01
  Emissivity = Real 0.5
End

Boundary Condition 2
  Target Boundaries = 3
  Boundary Type = String "Given Temperature"
  Temp = Real 0
End

Boundary Condition 3
  Target Boundaries = 4
  Boundary Type = String "Adiabatic"
End
\ttend

%++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Writing a Solver\label{programming:howtosolver}}
In Elmer an additional solver may be provided by dynamically linked subroutines. The pre-defined interface of a solver subroutine is
\ttbegin
SUBROUTINE mysolver( Model,Solver,dt,TransientSimulation )
  TYPE(Model_t) :: Model
  TYPE(Solver_t) :: Solver
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
\ttend
The first argument, \texttt{Model}, is the same structure also passed to a user function (see section \ref{programming:UDF}). The second argument, \texttt{Solver}, is of type \texttt{Solver\_t} and contains all information upon options set for this particular solver. The timestep size, \texttt{dt}, and a boolean variable, \texttt{TransientSimulation}, indicating whether the solver is to be run as a part of a transient (value \texttt{.TRUE.}) or steady state (value .FALSE.) simulation are further arguments of the solver subroutine.
%---------------------------------------------------------------------
\subsection{Structure of a Solver\label{programming:solver_structure}}
The well known structure of a linearized partial differential equation (PDE) for the scalar $T$ in the variational formulation is
\begin{equation}\label{programming:variational}
\mathbf{M}_{i\,j}\frac{\partial T_{j}}{\partial t} + \mathbf{A}_{i\,j}T_{j} = F_{i},
\end{equation}
with the mass matrix, $\mathbf{M}_{i\,j}$, the stiffness matrix, $\mathbf{A}_{i\,j}$ and the force vector, $ F_{i}$. 

Time-stepping and the coupled solver iteration -- i.e., the steady state or time level iteration of several solvers of the simulation -- is taken care of by the main part of the Elmer Solver. The task of the user supplying a user defined solver subroutine is to linearize an eventually nonlinear PDE and to supply the Elmer Solver with the element-wise components for the matrices as well as the force vector. 

This leads to a principle structure of a user defined solver subroutine as it is depicted in Fig. \ref{fig:solverstructure}.
\begin{figure}[tbhp]
\begin{center}
\epsfig{figure=solver_flow.eps, height=0.5\textheight,angle=0}
\caption{\label{fig:solverstructure} Flowchart of a user defined solver subroutine within Elmer Solver. The grey underlayed area indicates the tasks of a simulation that are provided by Elmer, whereas the white area contains the flowchart for the source code of the user subroutine. Arrows pointing into this field indicate needed subroutine/function calls to Elmer Solver.}
\end{center}
\end{figure}
We further will explain the construction of a user solver subroutine by discussing an example case.
%-----------------------------------------------------------------------------
\subsection{Example: Heat Conduction Equation}\label{programming:example_heat}
In order to provide a simple example, we want to explain how the solution of the purely convective heat transport equation is implemented in Elmer. This example explains:
\begin{itemize}
\item reading solver parameters from the solver input file
\item assembly of the local element matrix components for the domain and a von Neumann condition including explanation of the most important Elmer Solver routines needed for linear system matrix assembly and solution
\item how to deal with non-linear and transient PDE's
\item how to implement Dirichlet boundary conditions
\end{itemize}
For constant density, $\varrho$, and heat capacity, $c_{p}$  this equation may be written as
\begin{equation}\label{programming:heat}
\frac{\partial T}{\partial t} - \nabla\cdot(\frac{k}{c_{p}\,\varrho}\,\nabla T) = \frac{h}{c_{p}\,\varrho},
\end{equation}
where $T$ stands for the temperature, $k$ for the heat conductivity and $h$ is the heat source.


The variational formulation of \eqref{programming:heat} reads after partial integration of the conduction term and application of Green's theorem
\begin{multline}
\int\limits_{V}\frac{\partial T}{\partial t} \gamma_{i}\,dV + \int\limits_{V}\frac{k}{c_{p}\,\varrho}\, \nabla T \cdot\nabla \gamma_{i}\,dV  =\\ \int\limits_{V} \frac{h}{c_{p}\,\varrho} \gamma_{i}\,dV + \oint\limits_{\partial V}\frac{1}{c_{p}\,\varrho} \underbrace{(k\,\nabla T)\cdot\vec{n}}_{=q_{n}}\,\gamma_{i}\,dA,
\end{multline}
where $\gamma_{i}$ is the basis-function, $V$ and $\partial V$ is the element volume and its enclosing surface, respectively.
The surface normal of $\partial V$ is denoted by $\vec{n}$. According to the Galerkin method, the variable is given as $T = T_{j} \gamma_{j}$, with the sum taken over the index $j$. Comparing with \eqref{programming:variational} leads to the matrices and vectors
\begin{equation}\label{programming:matrices}
\begin{split}
 \mathbf{M}_{i\,j} &= \int\limits_{V} \gamma_{j}\gamma_{i}\,dV,\\
 \mathbf{A}_{i\,j} &= \int\limits_{V} \frac{k}{c_{p}\,\varrho} \nabla \gamma_{j}\cdot\nabla \gamma_{i}\,dV,\\
         F_{i}         &= \int\limits_{V}\frac{h}{c_{p}\,\varrho}\nabla \gamma_{i}\,dV + \oint\limits_{\partial V}\underbrace{\frac{q_{n}}{c_{p}\,\varrho}}_{= l} \,\gamma_{i}\,dA.
\end{split}
\end{equation}
Although the external heat flux perpendicular to the surface normal, $q_{n}(T)$, in general is a function of the temperature we want to keep it formal as being prescribed. Hence, only a contribution in the force vector occurs in our formulation. Mind, that a linear or linearized expression of $q_{n}(T)$ directly could give a contribution to the stiffness matrix at the entries corresponding to boundary nodes. In our approach, even in the case of a linear dependency $q_{n}(T) \propto T$ we have to iterate the solution because of our treatment of the boundary condition.

The header contains the declaration needed variables -- we tried to give them self explaining identifiers. Furthermore, allocations of the needed field arrays are done for the first time the subroutine is visited (checked by the boolean variable \texttt{AllocationsDone}). The variable names of these arrays then have to be included in the \texttt{SAVE}-statement at the end of the variable declaration block.

\ttbegin
SUBROUTINE MyHeatSolver( Model,Solver,dt,TransientSimulation )

  USE DefUtils

  IMPLICIT NONE
!----------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model

  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!----------------------------------------------------------------
! Local variables
!----------------------------------------------------------------
  TYPE(Element_t),POINTER :: Element

  LOGICAL :: AllocationsDone = .FALSE., Found, Converged

  INTEGER :: n, t, istat, other_body_id, iter, NonlinearIter
  REAL(KIND=dp) :: Norm, PrevNorm=0.0d00, NonlinearTol, RelativeChange

  TYPE(ValueList_t), POINTER :: BodyForce, Material, BC, SolverParams
  REAL(KIND=dp), ALLOCATABLE :: MASS(:,:), STIFF(:,:), LOAD(:), FORCE(:)
  REAL(KIND=dp), ALLOCATABLE :: HeatCapacity(:), HeatConductivity(:),&
       Density(:), ExternalTemp(:), TransferCoeff(:), HeatFlux(:)

  CHARACTER(LEN=MAX_NAME_LEN) :: BoundaryType

  SAVE MASS, STIFF, LOAD, FORCE,&
       HeatCapacity, HeatConductivity,&
       Density, ExternalTemp, TransferCoeff, HeatFlux, &
       AllocationsDone, PrevNorm
!----------------------------------------------------------------

  !Allocate some permanent storage, this is done first time only:
  !--------------------------------------------------------------
  IF ( .NOT. AllocationsDone ) THEN
     N = Solver \% Mesh \% MaxElementNodes !big enough for elemental arrays
     ALLOCATE( FORCE(N), LOAD(N), MASS(N,N), STIFF(N,N), STAT=istat )
     IF ( istat /= 0 ) THEN
        CALL Fatal( 'MyHeatSolve',&
             'Memory allocation error for matrix/vectors.' )
     END IF
     ALLOCATE( HeatCapacity(N), HeatConductivity(N), Density(N),&
          ExternalTemp(N), TransferCoeff(N), HeatFlux(N), STAT=istat )
     IF ( istat /= 0 ) THEN
        CALL Fatal( 'MyHeatSolve',&
             'Memory allocation error for parameter arrays.' )
     END IF
     AllocationsDone = .TRUE.
  END IF
\ttend
In the next step, information on the nonlinear iteration is being read from the solver section of the solver input file
\ttbegin
  !Read in solver parameters
  !-------------------------
  SolverParams => GetSolverParams()
  IF (.NOT. ASSOCIATED(SolverParams))&
       CALL FATAL('MyHeatSolve','No Solver section found')
  NonlinearIter = GetInteger(SolverParams, &
                     'Nonlinear System Max Iterations', Found)
  IF ( .NOT.Found ) NonlinearIter = 1
  NonlinearTol  = GetConstReal( SolverParams, &
       'Nonlinear System Convergence Tolerance',    Found )
  IF ( .NOT.Found ) NonlinearTol = 1.0D-03
\ttend
Therafter, the nonlinear iteration loop (outermost loop of the white underlayed area in Fig. \ref{fig:solverstructure}) is started and the linear system solver is initialized (routine \texttt{DefaultInitialize})
\ttbegin
!----------------------------------------------------------------
! Nonlinear iteration loop
!----------------------------------------------------------------
  DO iter=1,NonlinearIter
     Converged = .FALSE.
     WRITE(Message,'(A,I5,A,I5)') 'Nonlinear iteration no.',iter,&
          ' of max. ', NonlinearIter
     CALL INFO('MyHeatSolve',Message,level=1)

     !Initialize the system and do the assembly:
     !------------------------------------------
     CALL DefaultInitialize()
\ttend
The next loop is over all elements in the simulation domain our solver has been assigned to (\texttt{Solver \% NumberOfActiveElements}). The function \texttt{GetActiveElement} inquires the element associated with the element number \texttt{t}. This call at the same time also sets the default pointer \texttt{CurrentModel \% CurrentElement} to that particular element, which is important if subsequently called functions rely on this pointer to be set correctly (see section \ref{programming:UDF}). After inquiring the number of nodes the nodal material parameter values $c_{p} \to$~\texttt{HeatCapacity(1:n)}, $k \to$~\texttt{HeatConductivity(1:n)} and $\varrho \to$~\texttt{Density(1:n)} are read in. If one of these parameters is not found (i.e., \texttt{Found == .FALSE.}), a default value of 1 will be set in order to avoid division by zero.
\ttbegin
!----------------------------------------------------------------
!    Assembly for the domain
!----------------------------------------------------------------
     DO t=1,Solver \% NumberOfActiveElements

        ! get element info
        !-----------------
        Element => GetActiveElement(t)
        n = GetElementNOFNodes()

        ! get material parameters
        ! ----------------------
        Material => GetMaterial()
        IF (.NOT. ASSOCIATED(Material)) THEN
           WRITE(Message,'(A,I5,A)') &
                'No material for bulk element no. ',t,' found.'
           CALL FATAL('MyHeatSolve',Message)
        END IF     
        HeatCapacity(1:n) = GetReal(Material, 'Heat Capacity', Found )
        IF (.NOT. Found) HeatCapacity(1:n) = 1.0D00
        HeatConductivity(1:n) = & 
                 GetReal(Material, 'Heat Conductivity', Found )
        IF (.NOT. Found) HeatCapacity(1:n) = 1.0D00
        Density(1:n) = GetReal(Material, 'Density', Found )
        IF (.NOT. Found) Density(1:n) = 1.0D00
\ttend
In order to call the subroutine taking care of the composition of the element matrices and force vector (subroutine \texttt{LocalMatrix}), the load vector -- in our case the heat source, $h \to$~\texttt{LOAD(1:n)} -- has to be read from the body section of the solver input file. In the case of a transient simulation (indicated by \texttt{TransientSimulation == .TRUE.}) the first order time discretization is accounted for using the subroutine \texttt{Default1stOrderTime}.  Mind, that also higher order time discretization routines would be at hand. The local matrix is added to the global coefficient matrix of Elmer Solver calling the subroutine \texttt{DefaultUpdateEquations}
\ttbegin
        !Get load for force vector
        !-------------------------
        LOAD = 0.0d0
        BodyForce => GetBodyForce()
        IF ( ASSOCIATED(BodyForce) ) &
             LOAD(1:n) = GetReal( BodyForce, 'Heat Source', Found )      
     
        !Get element local matrix and rhs vector:
        !----------------------------------------
        CALL LocalMatrix( MASS, STIFF, FORCE, LOAD, Element, n,&
             HeatCapacity, HeatConductivity, Density, TransientSimulation)
     
        !Update global matrix and rhs vector from local matrix & vector:
        !---------------------------------------------------------------
        IF ( TransientSimulation ) THEN
           CALL Default1stOrderTime( MASS,STIFF,FORCE )
        END IF
        CALL DefaultUpdateEquations( STIFF, FORCE )
      
!----------------------------------------------------------------
     END DO ! end Assembly for the domain
!----------------------------------------------------------------
\ttend
After the bulk elements, the contribution to the coefficient matrix and the force vector from a von Neumann type of boundary condition has to be taken into account. To this end, we are looping over all boundary elements. Their total number is given by \texttt{ Solver \% Mesh \% NumberOfBoundaryElements}. The routine \texttt{ActiveBoundaryElement} checks whether the previously inquired element is part of a boundary condition that has been  assigned to our solver. If the value 1 is returned from the function \texttt{GetElementFamily} -- i.e. we are dealing with boundary element given at a point element -- the element also will be skipped, since von Neumann conditions cannot be set on such elements.  Finally, the list-pointer to the associated boundary condition section (\texttt{GetBC}) is set and the local matrices and vectors are initiated to zero.
\ttbegin
!----------------------------------------------------------------
!     assembly of von Neumann boundary conditions
!----------------------------------------------------------------
     DO t=1, Solver \% Mesh \% NumberOfBoundaryElements

        ! get element and BC info
        ! -----------------------     
        Element => GetBoundaryElement(t)
        IF ( .NOT.ActiveBoundaryElement() ) CYCLE
        n = GetElementNOFNodes()
        ! no evaluation of von Neumann BC's on points
        IF ( GetElementFamily() == 1 ) CYCLE 
        BC => GetBC()
        
        FORCE = 0.0d00
        MASS = 0.0d00
        STIFF = 0.0d00
\ttend
Since we have to define between different types of boundary conditions, we inquire the contents of a keyword \texttt{Boundary Type} from the solver input file. If this string is equal to \texttt{'heat flux'}, the variable with the name \texttt{'External Load'} will be read in from the boundary condition list \texttt{BC}. Thereafter, the contribution to the force vector will be computed by the internal subroutine \texttt{BoundaryCondition} (see later in this code). Mind, that the external load is not the given heat flux, $q_{n}$, but its value divided by the heat capacity and the density, $l = q_{n}/(c_{p}\,\varrho)$. This has to be taken care of if a numerical value or even a user function is provided in the solver input file (see section \ref{programming:example_boundary}). In the case of no boundary type being found or an unknown string being detected, the natural boundary condition, zero flux perpendicular to the surface, will be assumed. This is equivalent to the \texttt{'adiabatic'} boundary condition. In the case of \texttt{'given temperature'} the natural boundary condition will be altered by the matrix manipulation arising from the Dirichlet boundary condition (see later in this code).
\ttbegin
        ! check type of boundary and set BC accordingly
        !----------------------------------------------
        BoundaryType = GetString(BC,'Boundary Type',Found)
        IF (.NOT. Found) CYCLE
        ! natural boundary condition
        IF ((BoundaryType == 'adiabatic')&
             .OR. (BoundaryType == 'given temperature')) THEN 
           CYCLE
           ! external heat flux
        ELSE IF(BoundaryType == 'heat flux') THEN
           ! get external load; mind that this is the heat flux
           ! divided by the density and heat capacity
           LOAD(1:n) = LOAD(1:n) + GetReal(BC,'External Load', Found)            
           ! do the assembly of the force vector
           CALL BoundaryCondition(LOAD, FORCE, Element, n)
        ELSE
           WRITE(Message,'(A,I3,A)')&
                'No boundary condition given for BC no. ',GetBCId(),&
                '. Setting it to adiabatic.'
           CALL WARN('MyHeatSolve',Message)
           CYCLE 
        END IF
\ttend
 The boundary element loop is closed after the component system matrix and vector are updated for the current boundary element.
\ttbegin
        IF ( TransientSimulation ) THEN
           MASS = 0.d0
           CALL Default1stOrderTime( MASS, STIFF, FORCE )
        END IF
     
        CALL DefaultUpdateEquations( STIFF, FORCE )
!----------------------------------------------------------------
     END DO ! end of assembly of von Neumann boundary conditions
!----------------------------------------------------------------
\ttend
Before setting the Dirichlet conditions (i.e., given boundary temperature $T$) using the subroutine \texttt{DefaultDirichletBCs()} it is important to finish the element-wise assembly of the Elmer Solver system matrix calling \texttt{DefaultFinishAssembly}
\ttbegin
     CALL DefaultFinishAssembly()

     ! call Elmer Solver routine for Dirichlet BCs
     ! ------------------------------------------
     CALL DefaultDirichletBCs()
\ttend
The system is solved by the function call \texttt{DefaultSolve}, which returns the norm, $N^{n}$ of the solution vector $T_{j}$ for the $n$-th nonlinear iteration step. This is needed in order to inquire the change of the solution between two steps. If the relative norm
\begin{displaymath}
R = 2\frac{\vert N^{n-1} - N^{n}\vert}{N^{n-1} + N^{n}},
\end{displaymath}
is smaller than the given tolerance \texttt{Nonlinear System Tolerance} of the solver section, then the nonlinear iteration is taken to be converged.
\ttbegin
     ! Solve the system
     ! ----------------
     Norm = DefaultSolve()

     ! compute relative change of norm
     ! -------------------------------
     IF ( PrevNorm + Norm /= 0.0d0 ) THEN
        RelativeChange = 2.0d0 * ABS( PrevNorm-Norm ) / (PrevNorm + Norm)
     ELSE
        RelativeChange = 0.0d0
     END IF

     WRITE( Message, * ) 'Result Norm   : ',Norm
     CALL Info( 'MyHeatSolve', Message, Level=4 )
     WRITE( Message, * ) 'Relative Change : ',RelativeChange
     CALL Info( 'MyHeatSolve', Message, Level=4 )


     ! do we have to do another round?
     ! -------------------------------
     IF ( RelativeChange < NonlinearTol ) THEN  ! NO
        Converged = .TRUE.
        EXIT
     ELSE ! YES
        PrevNorm = Norm        
     END IF
!----------------------------------------------------------------
  END DO ! of the nonlinear iteration
!----------------------------------------------------------------
\ttend
After leaving the nonlinear iteration loop the status of convergence shall be displayed on stdio
\ttbegin
  ! has non-linear solution converged?
  ! ----------------------------------
  IF ((.NOT.Converged) .AND. (NonlinearIter > 1)) THEN 
     WRITE( Message, * ) 'Nonlinear solution has not converged',&
          'Relative Change=',RelativeChange,'>',NonlinearTol
     CALL Warn('MyHeatSolve', Message)
  ELSE
     WRITE( Message, * ) 'Nonlinear solution has converged after ',&
          iter,' steps.'
     CALL Info('MyHeatSolve',Message,Level=1)
  END IF
\ttend
In the code lines given above, the user could exchange the routine \texttt{Warn} by \texttt{Fatal} if the simulation should stop upon failed nonlinear iteration convergence.

\noindent Further we have to include the needed local subroutines using the Fortran~90 command 
\ttbegin
!----------------------------------------------------------------
! internal subroutines of MyHeatSolver
!----------------------------------------------------------------
CONTAINS
\ttend
The subroutine \texttt{LocalMatrix} composes the local matrices and vectors for a bulk element. The header with the variable declaration reads as follows
\ttbegin
!----------------------------------------------------------------
  SUBROUTINE LocalMatrix(MASS, STIFF, FORCE, LOAD, Element, n, &
       HeatCapacity, HeatConductivity, Density, TransientSimulation)
    IMPLICIT NONE
!----------------------------------------------------------------
    REAL(KIND=dp), DIMENSION(:,:) :: MASS, STIFF
    REAL(KIND=dp), DIMENSION(:) :: FORCE, LOAD, & 
         HeatCapacity, HeatConductivity, Density
    INTEGER :: n
    TYPE(Element_t), POINTER :: Element
    LOGICAL :: TransientSimulation
!----------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),ddBasisddx(n,3,3)
    REAL(KIND=dp) :: detJ, LoadAtIP,&
         LocalHeatCapacity, LocalHeatConductivity, LocalDensity
    LOGICAL :: Stat
    INTEGER :: t,i,j,DIM
    TYPE(GaussIntegrationPoints_t) :: IP

    TYPE(Nodes_t) :: Nodes
    SAVE Nodes
\ttend
For the sake of simplicity we use the same identifiers as in the solver subroutine for the variables in the argument list.

The next step is to inquire the dimension of the coordinate system. Thereafter, we get the nodes of the element using the already introduced function \texttt{GetElementNodes}. Since the values in \texttt{CurrentModel \% CurrentElement} and \texttt{CurrentModel \% Solver} have been set, no additional arguments to the variable \texttt{Nodes} have to be set. After we have initialized the local matrix and vector components to zero, the information upon the  Gauss-points needed for integration is inquired by the function \texttt{GaussPoints}. They returned variable \texttt{IP} is of type \texttt{GaussIntegrationPoints\_t}.
\ttbegin
    DIM = CoordinateSystemDimension()

    CALL GetElementNodes( Nodes )

    STIFF = 0.0d0
    FORCE = 0.0d0
    MASS = 0.0d0


    !Numerical integration:
    !----------------------
    IP = GaussPoints( Element )
\ttend
The integration over the element is done by summing over all Gauss-points (from 1 to $N_{\mathrm{IP}}\,\to$~\texttt{IP \% n}. The square root of the determinant of the element coordinate system metric tensor $\sqrt{\det(\mathbf{J}^{T}\cdot\mathbf{J})}\,\to$\texttt{DetJ} as well as the  local basis functions, $\gamma_{i} \to$~\texttt{Basis}, their derivatives, $\nabla\gamma_{i} \to$~\texttt{dBasisdx}, are evaluated for every Gauss-point using the function \texttt{ElementInfo}. The variable \texttt{ddBasisddx} is just passed as a dummy argument, since the last argument, \texttt{getSecondDerivatives} is set to  \texttt{.FALSE.}. The pointer to the element, \texttt{Element}, and its nodes, \texttt{Nodes} and the local variables of the Gauss-points \texttt{IP \% U(t)}, \texttt{IP \% V(t)} and \texttt{IP \% W(t)}, are needed as input.
\ttbegin
!----------------------------------------------------------------
!   Loop over Gauss-points (element Integration)
!----------------------------------------------------------------
    DO t=1,IP \% n
       !Basis function values & derivatives at the integration point:
       !-------------------------------------------------------------
       getSecondDerivatives = .FALSE.
       stat = ElementInfo( Element, Nodes, IP \% U(t), IP \% V(t), &
            IP \% W(t),  detJ, Basis, dBasisdx, ddBasisddx, &
            getSecondDerivatives)
\ttend
Thereafter, the material parameters at the Gauss-points are evaluated, using the basis function. For instance, the local density, $\varrho\vert_{\mathrm{IP}}\,\to$~\texttt{LocalDensity} at the Gauss-point is evaluated as follows:
\begin{displaymath}
\varrho\vert_{\mathrm{IP}} = \varrho_{i}\,\gamma_{i}\vert_{\mathrm{IP}},
\end{displaymath}
with the sum taken over the nodal index $i$. The load vector $h/(\varrho\,c_{p})\vert_{\mathrm{IP}}\,\to$ \texttt{LoadAtIP} is evaluated in a similar way.
\ttbegin
       !Material parameters at integration point:
       !----------------------------------------
       LocalHeatCapacity = SUM( HeatCapacity(1:n) * Basis(1:n) )
       LocalHeatConductivity = SUM( HeatConductivity(1:n) * Basis(1:n) )
       LocalDensity = SUM( Density(1:n) * Basis(1:n) )
       !The source term at the integration point:
       !-----------------------------------------
       LoadAtIP = SUM( Basis(1:n) * LOAD(1:n) ) &
            /(LocalHeatCapacity * LocalDensity)      
\ttend
The force vector is obtained by the integral over the element, which is approximated by the sum over all Gauss-point contributions
\begin{displaymath}
F_{j} = \int\limits_{V}\frac{h}{\varrho\,c_{p}}\gamma_{j}\,DV \approx \sum\limits_{t=1}^{N_{\mathrm{IP}}}\left( \sqrt{ds^{2}} \sqrt{\det(\mathbf{J}^{T}\cdot\mathbf{J})} \frac{h}{\varrho\,c_{p}}\,\gamma_{j}\right)\vert_{\mathrm{IP}}.
\end{displaymath}
The model coordinate system metric  $\sqrt{ds^{2}}\,\to$~\texttt{IP \% s(t)} as well as the previously inquired element coordinate system metric $\sqrt{\det(\mathbf{J}^{T}\cdot\mathbf{J})}\,\to$~\texttt{DetJ} have to be taken into account.

\noindent The matrix components are evaluated in complete analogy to the force vector
\begin{displaymath}
\begin{split}
 \mathbf{M}_{i\,j} = \int\limits_{V} \gamma_{j}\gamma_{i}\,dV & \approx \sum\limits_{t=1}^{N_{\mathrm{IP}}}\left(\sqrt{ds^{2}} \sqrt{\det(\mathbf{J}^{T}\cdot\mathbf{J})}\gamma_{j}\gamma_{i}\right)\vert_{\mathrm{IP}},\\
 \mathbf{A}_{i\,j} = \int\limits_{V} \frac{k}{c_{p}\,\varrho} \nabla \gamma_{j}\cdot\nabla \gamma_{i}\,dV & \approx \sum\limits_{t=1}^{N_{\mathrm{IP}}}\left[\sqrt{ds^{2}} \sqrt{\det(\mathbf{J}^{T}\cdot\mathbf{J})}\frac{k}{c_{p}\,\varrho}\,\left(\nabla \gamma_{j}\cdot\nabla \gamma_{i}\right)\right]\vert_{\mathrm{IP}},\\
\end{split}
\end{displaymath}
where the dot product of the first derivatives of the basis function is implemented using the expression $\nabla \gamma_{j}\cdot\nabla \gamma_{i}\,\to$~\texttt{SUM(dBasisdx(i,1:DIM) * dBasisdx(j,1:DIM))}
\ttbegin
!----------------------------------------------------------------
!      Loop over j-components of matrices and over force vector
!----------------------------------------------------------------
       DO j=1,n
          FORCE(j) = FORCE(j) + IP \% s(t) * DetJ * LoadAtIP * Basis(j)
!----------------------------------------------------------------
!         Loop over i-components of matrices
!----------------------------------------------------------------
          DO i=1,n
             !The mass matrix, if needed
             !--------------------------
             IF (TransientSimulation) THEN
                MASS(i,j) = MASS(i,j)+ IP \% s(t) * DetJ * &
                     Basis(i)*Basis(j)
             END IF

             !Finally, the stiffness matrix:
             !------------------------------
             STIFF(i,j) = STIFF(i,j)  &
                  + IP \% s(t) * DetJ * LocalHeatConductivity &
                  * SUM(dBasisdx(i,1:DIM) * dBasisdx(j,1:DIM))& 
                  /(LocalDensity * LocalHeatCapacity)
!---------------------------------------------------------------- 
          END DO ! end Loop over i-components of matrices
!---------------------------------------------------------------- 
       END DO ! end Loop over j-components of matrices and vector
!----------------------------------------------------------------
    END DO ! end Loop over Gauss-points (element Integration)
!----------------------------------------------------------------
  END SUBROUTINE LocalMatrix
!----------------------------------------------------------------
\ttend
The last two statements in the code sequence given above close the loop over the Gauss-points and provide the end statement of the local subroutine \texttt{ LocalMatrix}. 

\noindent The subroutine \texttt{BoundaryCondition} evaluates the contribution to the force vector at the boundary elements with given external load $l = q_{n}/(c_{p}\,\varrho)\,\to$ \texttt{LOAD}
\begin{displaymath}
F_{j} = \oint\limits_{\partial V}l\,dV \approx \sum\limits_{t=1}^{N_{\mathrm{IP}}}\left( \sqrt{ds^{2}} \sqrt{\det(\mathbf{J}^{T}\cdot\mathbf{J})} l\right)\vert_{\mathrm{IP}}.
\end{displaymath}
Since this is implemented in complete analogy to the assembly of the force vector in the previously discussed subroutine \texttt{LocalMatrix}, a detailed explanation can be omitted
\ttbegin
!----------------------------------------------------------------
  SUBROUTINE BoundaryCondition(LOAD, FORCE, Element, n)
    IMPLICIT NONE
!----------------------------------------------------------------
    REAL(KIND=dp), DIMENSION(:) :: FORCE, LOAD
    INTEGER :: n
    TYPE(Element_t), POINTER :: Element
!----------------------------------------------------------------
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3),ddBasisddx(n,3,3)
    REAL(KIND=dp) :: detJ, LoadAtIP,&
         LocalHeatCapacity, LocalDensity
    LOGICAL :: stat, getSecondDerivatives
    INTEGER :: t,j
    TYPE(GaussIntegrationPoints_t) :: IP

    TYPE(Nodes_t) :: Nodes
    SAVE Nodes
!----------------------------------------------------------------

    CALL GetElementNodes( Nodes )

    FORCE = 0.0d0

    !Numerical integration:
    !----------------------
    IP = GaussPoints( Element )
!-----------------------------------------------------------------
!   Loop over Gauss-points (boundary element Integration)
!-----------------------------------------------------------------
    DO t=1,IP \% n
       !Basis function values & derivatives at the integration point:
       !-------------------------------------------------------------
       getSecondDerivatives = .FALSE.
       stat = ElementInfo( Element, Nodes, IP \% U(t), IP \% V(t), &
            IP \% W(t),  detJ, Basis, dBasisdx, ddBasisddx, &
            getSecondDerivatives)
       !The source term at the integration point:
       !-----------------------------------------
       LoadAtIP = SUM( Basis(1:n) * LOAD(1:n) )
!-----------------------------------------------------------------    
!      Loop over j-components of matrices and over force vector
!-----------------------------------------------------------------    
       DO j=1,n
          FORCE(j) = FORCE(j) + IP \% s(t) * DetJ * LoadAtIP * Basis(j)
       END DO
    END DO
!----------------------------------------------------------------
  END SUBROUTINE BoundaryCondition
!----------------------------------------------------------------
\ttend
The Fortran~90 file is completed providing the end statement for the user solver subroutine \texttt{MyHeatSolver}.
\ttbegin
!----------------------------------------------------------------
END SUBROUTINE MyHeatSolver
!----------------------------------------------------------------
\ttend
%++++++++++++++++++++++++++++++++
\section{Compilation and Linking}
As already mentioned, the Elmer Solver is written in Fortran 90. The modularity of Elmer implies the use of modules, which are included by the command \texttt{USE} in the header of the user functions. 

Since these modules are binaries, they in general are incompatible between different compilers on the same platform. This is not an issue on commercial UNIX platforms, such as IRIX (Silicon Graphics) and TRU64 (Alpha Compaq/HP), where the compilers normally are vendor specific. But on Linux as well as Windows, there is more than one Fortran~90 compiler available - for instance the Absoft and Intel compilers on Linux. Hence, if the user wants to include dynamically linked code, it is essential that the same compiler the Elmer Solver source has been compiled with is also used for compilation of the user function.

Let the directory of the installation tree of Elmer be referred to by the system variable \texttt{ELMER\_HOME} (e.g. \texttt{/usr/local/ELMER3.0} on Unix/Linux-systems or \texttt{C:\textbackslash Programs\textbackslash ELMER3.0} on Windows). The modules that are needed for the compilation are to be found in the subdirectory \texttt{include} of the \texttt{ELMER\_HOME}-tree -- \texttt{\$ELMER\_HOME/include} on Unix/Linux systems. The libraries needed for linking are stored in the subdirectory \texttt{lib} of the \texttt{ELMER\_HOME}-tree. Mind, that on Unix/Linux platforms the filename as well as the path are case-sensitive.
%--------------------------------------------------
%\subsection{AIX\label{programming:compile_AIX}}
%\ttbegin
%mpxlf90 -qsuffix=f=f90 -I\$(ELMER_HOME)/include -O -qstrict -qmaxmem=-1
%-L\$ELMER_HOME/lib -L\$ELMER_HOME/bin -lSolver
%-G -brtl -bexpall -lxlf90 -lxlopt -lxlf -lxlomp_ser -lm -lc -lC
%\ttend
%--------------------------------------------------
\subsection{IRIX\label{programming:compile_IRIX}}
On an Silicon Graphics IRIX system  the subroutine or function in the file \texttt{mysolver.f90} is compiled by the command
\ttbegin
f90 -I\$ELMER_HOME/include mysolver.f90 -o mysolver -shared
\ttend
No additional libraries have to be linked to the shared object. The binary in our example is called \texttt{mysolver}.
%--------------------------------------------------
\subsection{TRU64\label{programming:compile_TRU}}
The same syntax as for the IRIX compiler applies also to the Compaq Fortran 90 compiler
\ttbegin
f90 -I\$ELMER_HOME/include mysolver.f90 -o mysolver -shared
\ttend
%--------------------------------------------------
\subsection{Linux (Intel Fortran)\label{programming:compile_Linux}}
The  32-bit Linux version of Elmer Solver has been compiled using the Intel Fortran compiler (see details under \URL{http://www.intel.com/software/products/compilers/flin/}). The compiler call is \texttt{ifc}.  From the compiler side in order to obtain a working executable the library \texttt{libimf.so} has to be linked. If the variable \texttt{IFC\_HOME} contains the path to the installation directory of the compiler (e.g., \texttt{IFC\_HOME = /opt/intel/compiler70} for version 7.0), this library is then to be found under \texttt{\$IFC\_HOME/libimf.so}.

On an Intel Pentium IV using RedHat Linux version 9 the following line (given in one line at the command prompt) compiles the user file \texttt{mysolver.f90} containing the Fortran~90 code for a user subroutine or user function and links it to the Elmer Solver library, \texttt{\$ELMER\_HOME/lib/libSolver.so}, and the earlier mentioned compiler specific library. The final executable is stored in the file \texttt{mysolver}:
\ttbegin
ifc -xW -tpp7 -vec_report0 -w -O -I\$ELMER\_HOME/include -o mysolver 
    mysolver.f90 -shared -L/\$ELMER\_HOME/lib -L\$IFC\_HOME/ia32/lib
    -lSolver -limf
\ttend
The options \texttt{-xW} and \texttt{-tpp7} are for special optimization of the code for the Pentium IV architecture and have to be replaced or omitted if compiling on another hardware platform. \texttt{-w} switches off warnings and \texttt{-O} sets the lowest level of compiler optimization -- higher orders usually tend to cause problems and should be used with care. The \texttt{-I} indicates the include directory for modules, whereas the directories after the \texttt{-L} contain the libraries that are linked to the compiled object. Mind, that these library-paths always have to be added at the very end of the command line. The \texttt{-shared} option takes care that dynamically linked libraries are used.
%--------------------------------------------------
\subsection{Windows\label{programming:compile_Win}}
The Windows version of Elmer Solver has been compiled using the DECWindows Fortran compiler. The subroutine \texttt{mysolver.f90} is compiled from the command line entering 
\ttbegin
f90 -I\%ELMER_HOME\%\textbackslash{include} -dll mysolver.f90 \%ELMER_HOME\%\textbackslash{Solver.lib}
\ttend
It is important that the keyword \texttt{DLLEXPORT} followed by the name of the subroutine is inserted immediately after the interface of the subroutine. In the case of the example given in \ref{programming:example_heat}, this would look as follows
\ttbegin
SUBROUTINE MyHeatSolver( Model,Solver,dt,TransientSimulation )
DLLEXPORT MyHeatSolver
\ldots
\ttend
After successful compilation, the file \texttt{mysolver.dll} is to be found in the local directory. In the filename declaration of the \texttt{Procedure}-keyword in solver input file, the suffix \texttt{.dll} can be omitted
\ttbegin
Solver 1
  Procedure = "mysolver" "subroutineName"
  \ldots
End
\ttend

\bibliography{elmerbib}
\bibliographystyle{plain}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "~/TeX/SolverManual/opas"
%%% End: 
