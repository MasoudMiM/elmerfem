!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  This solver may be used for optimization 
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback
! *  Email:   Peter.Raback@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 26 Mar 2003
! *
! ****************************************************************************/
 

!------------------------------------------------------------------------------
SUBROUTINE FindOptimum( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************

  USE Types
  USE Lists
  USE MeshUtils
  USE Integration
  USE ElementDescription
  USE SolverUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation

!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
  LOGICAL :: gotIt, OptimalFinish, InternalHistory, SaveHistory
  LOGICAL, ALLOCATABLE :: FixedParam(:)
  INTEGER :: i,j,k,l,NoParam, NoValues, NoFreeParam, OptimizationsDone=0, Direction=1
  REAL(KIND=dp), POINTER :: Param(:)
  REAL(KIND=dp), ALLOCATABLE :: MinParam(:), MaxParam(:), PrevParam(:,:), &
      PrevCost(:), BestParam(:)
  REAL(KIND=dp) :: Cost, CostTarget, Extent, Step, Eps, MinCost, x(10), c(10)
  CHARACTER(LEN=MAX_NAME_LEN) :: Name, ParamStr, Method
  CHARACTER(LEN=MAX_NAME_LEN) :: BestFile, HistoryFile
  
  SAVE Param, MinParam, MaxParam, PrevParam, NoParam, &
      OptimizationsDone, Method, Direction, x, c, PrevCost, Eps, &
      FixedParam, NoFreeParam, MinCost, BestParam, NoValues, &
      OptimalFinish, InternalHistory

  !------------------------------------------------------------------------------
  ! In the 1st round perform initializations 
  !------------------------------------------------------------------------------
  IF( OptimizationsDone == 0) THEN

    NoParam = Solver % Variable % DOFs
    IF(NoParam == 0) THEN
      CALL Fatal('FindOptimum','There are no parameters to optimize!')
    END IF

    Param => Solver % Variable % Values
    IF( SIZE( Param) /= NoParam ) THEN
      CALL Fatal('FindOptimum','The variable vector is of wrong size')
    END IF

    OptimalFinish = ListGetLogical( Solver % Values,'Optimal Finish',GotIt)
    NoValues = ListGetInteger(Model % Simulation,'Timestep Intervals')

    ALLOCATE( MinParam(NoParam), BestParam(NoParam), MaxParam(NoParam), &
        FixedParam(NoParam))

    MinParam = 0.0_dp
    BestParam = 0.0_dp
    MaxParam = 0.0_dp
    FixedParam = .FALSE.
    MinCost = HUGE(MinCost)
   
    NoFreeParam = 0
    DO i=1,NoParam
      IF(i < 10) THEN
        WRITE( ParamStr,'(A,I2)') 'Parameter',i
      ELSE IF( i < 100 ) THEN
        WRITE( ParamStr,'(A,I3)') 'Parameter',i 
      ELSE IF( i < 1000 ) THEN
        WRITE( ParamStr,'(A,I4)') 'Parameter',i
      END IF

      Param(i) = ListGetConstReal(Solver % Values,'Fixed '//TRIM(ParamStr),GotIt)
      IF( GotIt ) THEN
        FixedParam(i) = .TRUE.
      ELSE
        MinParam(i) = ListGetConstReal(Solver % Values,'Min '//TRIM(ParamStr))
        MaxParam(i) = ListGetConstReal(Solver % Values,'Max '//TRIM(ParamStr))
        NoFreeParam = NoFreeParam + 1
        Param(i) = ListGetConstReal(Solver % Values,'Initial '//TRIM(ParamStr),GotIt)
        IF(.NOT. GotIt ) THEN
          Param(i) = 0.5_dp * ( MinParam(i) + MaxParam(i) ) 
        END IF
      END IF

      IF( ListGetLogical(Solver % Values,'Optimal Restart',GotIt) ) THEN
        CALL GuessOptimum()
      END IF

    END DO

    Method = ListGetString(Solver % Values,'Optimization Method')

    ! Internal history could be used in more complicated optimization routines
    !--------------------------------------------------------------------------
    InternalHistory = ListGetLogical( Solver % Values,'Internal History',GotIt)    
    IF( Method == 'bisect') InternalHistory = .TRUE.
    IF( InternalHistory ) THEN
      ALLOCATE( PrevParam(NoValues,NoParam), PrevCost(NoValues))
    END IF

    PRINT *,'min',minparam
    PRINT *,'max',maxparam
    PRINT *,'param',param
    PRINT *,'fixedparam',fixedparam
    PRINT *,'method: ',method
  END IF

  !------------------------------------------------------------------------------
  ! If visiting for the second time inspect how good the previous solution was
  !------------------------------------------------------------------------------
  IF( OptimizationsDone > 0 ) THEN
    Cost = ListGetConstReal(Model % Simulation,'Cost Function',GotIt)
    IF(.NOT. GotIt) THEN
      Name = ListGetString(Solver % Values,'Cost Function Name',GotIt)
      IF(.NOT. GotIt) CALL Fatal('FindOptimum','Give Cost Function or its name')
      Cost = ListGetConstReal(Model % Simulation,Name,GotIt)     
      IF(.NOT. GotIt) CALL Fatal('FindOptimum','Cost with the given name was not found')
    END IF
    CostTarget = ListGetConstReal( Solver % Values,'Cost Function Target',GotIt)    
    IF( GotIt ) Cost = ABS( Cost - CostTarget ) 
  
    PRINT *,'cost',cost,mincost
        
    ! Found a new best point
    !-----------------------
    IF(Cost < MinCost) THEN
      MinCost = Cost
      BestParam(1:NoParam) = Param(1:NoParam)
      
      WRITE(Message,'(A,ES15.6E3)') 'Found New Minimum Set',MinCost
      CALL Info('FindOptimum',Message,Level=4)

      BestFile = ListGetString(Solver % Values,'Best File',GotIt )
      IF( GotIt ) THEN
        OPEN (10, FILE=BestFile, STATUS='UNKNOWN')
        WRITE (10,'(I4)') NoParam
        DO i=1,NoParam
          WRITE (10,'(ES17.8E3)') Param(i)
        END DO
        WRITE (10,'(ES17.8E3)') Cost
        CLOSE(10)
      END IF
    END IF

    IF( InternalHistory ) THEN
      PrevParam(OptimizationsDone,1:NoParam) = Param(1:NoParam)
      PrevCost(OptimizationsDone) = Cost
    END IF

    ! Save the results to a file
    !---------------------------
    HistoryFile = ListGetString(Solver % Values,'History File',GotIt )
    IF( GotIt ) THEN
      IF(OptimizationsDone == 1) THEN
        OPEN (10, FILE=HistoryFile)
      ELSE
        OPEN (10, FILE=HistoryFile,POSITION='APPEND')
      END IF
      
      WRITE (10,'(ES17.8E3)',advance='no') Cost
      DO i=1,NoParam
        WRITE (10,'(ES17.8E3)',advance='no') Param(i)
      END DO
      WRITE(10,'(A)') ' '
      CLOSE(10)
    END IF
  END IF

  CALL Info( 'FindOptimum', '-----------------------------------------', Level=4 )
  WRITE( Message, '(A,I2,A,A)' ) 'Manipulating',NoFreeParam,' parameters using ',TRIM(Method) 
  CALL Info( 'FindOptimum', Message, Level=4 )
  WRITE( Message, '(A,ES15.6E3)' ) 'Lowest cost so far is ',MinCost
  CALL Info( 'FindOptimum', Message, Level=4 )
  CALL Info( 'FindOptimum', '-----------------------------------------', Level=4 )
  

  SELECT CASE(Method)
    
  CASE ('random')
    DO i=1,NoParam
      CALL RANDOM_NUMBER(Extent)
      Param(i) = MinParam(i) + (MaxParam(i)-MinParam(i)) * Extent
    END DO
    
  CASE ('scanning')
    IF(NoFreeParam /= 1) CALL Fatal('FindOptimum',&
        'Option scan implemented only for one parameter')
    DO i=1,NoParam
      IF(.NOT. FixedParam(i)) EXIT
    END DO
    PRINT *,'Active Parameter',i,NoValues,OptimizationsDone
    IF( OptimalFinish ) THEN
      Extent = OptimizationsDone*1.0_dp/(NoValues-2)
    ELSE
      Extent = OptimizationsDone*1.0_dp/(NoValues-1)
    END IF
    PRINT *,'extent',extent,MinParam(i),MaxParam(i)
    Param(i) = MinParam(i) + (MaxParam(i)-MinParam(i)) * Extent
    
  CASE ('genetic')
    CALL GeneticOptimize(NoParam, OptimizationsDone+1, Param, Cost)
    DO i=1,NoParam 
      Param(i) = MAX(MinParam(i),Param(i))
      Param(i) = MIN(MaxParam(i),Param(i))
    END DO

  CASE ('bisect')    
    IF(NoFreeParam /= 1) CALL Fatal('FindOptimum',&
        'Option bisect implemented only for one parameter')
    Eps = ListGetConstReal(Solver % Values,'Optimization Accuracy')
    DO j=1,NoParam
      IF(.NOT. FixedParam(j)) EXIT
    END DO
    PRINT *,'Active Parameter For Bisection Search',j
    PRINT *,'Interval',MinParam(1),MaxParam(1)
    CALL BisectOptimize(OptimizationsDone+1)
    
  END SELECT

  IF( OptimalFinish .AND. OptimizationsDone == NoValues - 1 ) THEN
    CALL Info('FindOptimum','Peforming the last step with the best so far')
    Param = BestParam
  END IF

  IF(.TRUE.) THEN
    WRITE (*,'(A,ES12.4)') 'Minimum Cost',MinCost
    WRITE (*,'(A,4ES12.4)') 'Best set',BestParam
    WRITE (*,'(A,4ES12.4)') 'Test set',Param
  END IF

  OptimizationsDone = OptimizationsDone + 1

CONTAINS

!-------------------------------------------------------------------------------

  FUNCTION rnd(n)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(KIND=dp), DIMENSION(n) :: rnd
    CALL RANDOM_NUMBER(rnd)
  END FUNCTION rnd

!-------------------------------------------------------------------------------

  INTEGER FUNCTION idx(n)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(KIND=dp) :: x
    CALL RANDOM_NUMBER(x)
    idx = n*x + 1
  END FUNCTION idx

!-------------------------------------------------------------------------------

  SUBROUTINE GeneticOptimize(parsize, no, parameters, func)

    INTEGER :: parsize, no
    REAL (KIND=dp) :: parameters(parsize), func

    INTEGER :: popsize, i0, i1, i2, i3 
    REAL(KIND=dp) :: popcoeff, popcross
    REAL(KIND=dp), ALLOCATABLE :: pars(:,:), vals(:) 
    LOGICAL, ALLOCATABLE :: mask(:)

    SAVE i0, pars, vals, mask, popsize, popcoeff, popcross
        
    IF(no == 1) THEN
      popsize = ListGetInteger(Solver % Values,'Populazation Size',GotIt)
      IF(.NOT. GotIt) popsize = 5 * parsize
      popcoeff = ListGetConstReal(Solver % Values,'Population Coefficient',GotIt)
      IF(.NOT. GotIt) popcoeff = 0.7
      popcross = ListGetConstReal(Solver % Values,'Population Crossover',GotIt)
      IF(.NOT. GotIt) popcross = 0.1
      ALLOCATE(pars(parsize,popsize),vals(popsize),mask(parsize))
      IF(.FALSE.) THEN
        PRINT *,'popsize',popsize,'parsize',parsize
        PRINT *,'popcoeff',popcoeff,'popcross',popcross
      END IF
    END IF
    
    ! Read the cases into the population
    IF(no <= popsize) THEN
      pars(1:parsize,no) = parameters(1:parsize)
      vals(no) = func
    ELSE   
      IF(func < vals(i0)) THEN
        pars(1:parsize,i0) = parameters(1:parsize) 
        vals(i0) = func
      END IF
    END IF

    ! The first cases are just random
    IF(no < popsize) THEN
      pars(1:parsize,no) = parameters(1:parsize)
      vals(no) = func
      Param = MinParam + (MaxParam-MinParam) * rnd(parsize)
    END IF

    ! Here use genetic algorithms 
    IF(no >= popsize) THEN
      ! Find the three vectors to recombine 
      i0 = MOD(no,popsize) + 1 
      DO
        i1 = idx(popsize)
        IF (i1 /= i0) EXIT
      END DO
      DO
        i2 = idx(popsize)
        IF (i2 /= i0.AND. i2 /= i1) EXIT
      END DO
      DO
        i3 = idx(popsize)
        IF (ALL(i3 /= (/i0,i1,i2/))) EXIT
      END DO
      
      mask = (rnd(parsize) < popcross)
      
      WHERE (mask)
        parameters = pars(:,i3) + popcoeff*(pars(:,i1)-pars(:,i2))
      ELSEWHERE
        parameters = pars(:,i0)
      END WHERE
    END IF

  END SUBROUTINE GeneticOptimize

!-------------------------------------------------------------------------------



  SUBROUTINE BisectOptimize(no)

    INTEGER :: no
    REAL(KIND=dp) :: step 

    SAVE step

    IF(no == 1) THEN
      step = ListGetConstReal(Solver % Values,'Step Size',GotIt)
      IF(.NOT. GotIt) step = (MaxParam(j)-Param(j))/2.0
      step = MIN((MaxParam(j)-Param(j))/2.0,step)
    END IF
    
    IF(no <= 3) THEN
      Param(j) = Param(j) + step
      RETURN
    END IF

    IF(no == 4) THEN
      x(1) = PrevParam(1,j)
      x(2) = PrevParam(2,j)
      x(3) = PrevParam(3,j)
      c(1) = PrevCost(1)
      c(2) = PrevCost(2)
      c(3) = PrevCost(3)
    ELSE
      x(3) = Param(j)
      c(3) = Cost
    END IF

    ! Order the previous points so that x1 < x2 < x3
    DO k=1,2 
      DO i=k+1,3
        IF(x(i) < x(k)) THEN
          x(4) = x(k)
          x(k) = x(i)
          x(i) = x(4)
          c(4) = c(k)
          c(k) = c(i)
          c(i) = c(4)
        END IF
      END DO
    END DO
    
    ! Monotonic line segment
    IF( (c(2)-c(1))*(c(3)-c(2)) > 0.0) THEN
      IF(c(3) < c(1)) THEN
        Param(j) = x(3) + SIGN(step,x(3)-x(1))
        c(1) = c(3)
        x(1) = x(3)
      ELSE
        Param(j) = x(1) + SIGN(step,x(1)-x(3))
      END IF
    ELSE IF(c(2) < c(1) .OR. c(2) < c(3)) THEN 
      IF(c(3) < c(1)) THEN
        c(1) = c(3)
        x(1) = x(3)
      END IF
      step = (x(2)-x(1))/2.0d0
      Param(j) = x(1) + SIGN(step,x(2)-x(1))
    ELSE
      CALL Fatal('FindOptimum','Bisection method cannot handle local maxima')
    END IF

  END SUBROUTINE BisectOptimize



!--------------------------------------------------------------------------------------
! This subroutine may be used to continue the optimization from the previous best value
!--------------------------------------------------------------------------------------
  SUBROUTINE GuessOptimum( )
!------------------------------------------------------------------------------

    INTEGER :: i,n
    REAL(KIND=dp) :: parami
    REAL(KIND=dp), ALLOCATABLE :: param(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: Name
    LOGICAL :: fileis, GotIt
    CHARACTER(LEN=MAX_NAME_LEN) :: GuessFile

    GuessFile = ListGetString(Solver % Values,'Filename',GotIt )
    IF(.NOT. GotIt) GuessFile = 'optimize-best.dat'

    INQUIRE (FILE=GuessFile, EXIST=fileis)
    
    IF(.NOT. fileis ) THEN
      CALL Warn('FindOptimum','Previous optimum was not found in: '//TRIM(GuessFile))
      RETURN
    END IF

    OPEN(10,FILE=GuessFile)
    READ (10,*) n
    ALLOCATE (param(n))
    DO i=1,n
      READ (10,*) param(i)
    END DO
    CLOSE(10)

  END SUBROUTINE GuessOptimum



END SUBROUTINE FindOptimum
