!/******************************************************************************
! *
! * Subroutine for tracking a particle under the influence of collisions,
! * contacts and external fields.
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback & Juha Ruokolainen
! *  Email:   Peter.Raback@csc.fi & Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 26.5.2010
! *
! *****************************************************************************/


SUBROUTINE ParticleDynamics_Init( Model,Solver,dt,TransientSimulation )

  USE DefUtils
  USE Interpolation
  USE MeshUtils
  USE ElementUtils
  USE ParticleUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------
  
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: Found

  Params => Solver % Values

  IF( GetLogical( Params,'Particle To Field',Found ) ) THEN
    CALL ListAddString( Params,&
        NextFreeKeyword('Exported Variable',Params),'Particle Trace')
    CALL ListAddString( Params,&
        NextFreeKeyword('Exported Variable',Params),'Particle Weight')
    IF( .NOT. ListCheckPresent( Params,'Variable') ) THEN
      CALL ListAddString( Params,'Variable','Particle Field')
    END IF
  END IF

END SUBROUTINE ParticleDynamics_Init


!------------------------------------------------------------------------------
SUBROUTINE ParticleDynamics( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  This subroutine saves scalar values to a matrix.
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************
  USE DefUtils
  USE Interpolation
  USE MeshUtils
  USE ElementUtils
  USE ParticleUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------

  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Solver_t), POINTER :: PSolver
  TYPE(Element_t), POINTER :: CurrentElement, FaceElement
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Variable_t), POINTER :: Var
  LOGICAL :: GotIt, Debug, Hit, InitLocation, CollisionInteraction, &
      ContactInteraction, ParticleToField, &
      ParticleInBox, ParticleWall, Absolute, InitTimestep, &
      TrueCollision, StatInfo, Found
  INTEGER :: i,j,k,n,dim,No,No2,nodims,NoParticles = 0,&
       ElementIndex, VisitedTimes = 0, nstep, OutputInterval, ExtOutputInterval, &
       Status,TimeOrder, PartitionChanges, TimeStepsTaken=0,estindexes(6),&
       ParticleStepsTaken=0, TotParticleStepsTaken, TotNoParticles, &
       FirstGhost
  REAL(KIND=dp) :: dtime, tottime = 0.0, Tchar, Cchar, &
      Coord(3), Velo(3), &
      Coord2(3), Velo2(3), Force(3), Force2(3), &
      Lambda, LocalCoords(3), Rinit(3),Rfin(3)
  REAL(KIND=dp) :: cput1,cput2,RealTime,CPUTime, Norm
  REAL(KIND=dp), POINTER :: RhsVector(:), WeightVector(:), ForceVector(:)

  TYPE(Particle_t) :: Particles


  SAVE CollisionInteraction, ContactInteraction, &
      ParticleToField, OutputInterval, ExtOutputInterval, &
      Nstep, VisitedTimes, &
      RhsVector, WeightVector, ForceVector, TimeOrder, ParticleInBox, Particles, &
      tottime, TimeStepsTaken, ParticleStepsTaken,ParticleWall,StatInfo


!------------------------------------------------------------------------------

  CALL Info('ParticleDynamics','-----------------------------------------', Level=4 )
  CALL Info('ParticleDynamics','Tracking the path of the particle',Level=4) 

  VisitedTimes = VisitedTimes + 1

  PSolver => Solver
  Params => Solver % Values
  Mesh => Solver % Mesh
  DIM = CoordinateSystemDimension()

  ! Initialize as some of these are also used with dim==2
  Rfin = 0.0_dp
  Rinit = 0.0_dp
  Coord = 0.0_dp
  Coord2 = 0.0_dp
  Velo = 0.0_dp
  Velo2 = 0.0_dp
  Force = 0.0_dp
  Force2 = 0.0_dp


  ! Do some initalialization: allocate space, check fields  
  !------------------------------------------------------------------------
  IF( VisitedTimes == 1 ) THEN
    TimeOrder = GetInteger( Params,'Time Order',GotIt)
    IF(.NOT. GotIt) TimeOrder = 2

    CALL SetParticlePreliminaries( Particles, dim, TimeOrder )

    CollisionInteraction = GetLogical( Params,'Particle Particle Collision')
    ContactInteraction = GetLogical( Params,'Particle Particle Contact')
    ParticleToField = GetLogical( Params,'Particle To Field')

    OutputInterval = GetInteger( Params,'Output Intervals')

    ! This should be done for arrays!
    IF( GetLogical( Params,'Simulation Output Intervals',GotIt)) THEN
      ExtOutputInterval = GetInteger( CurrentModel % Simulation,'Output Intervals')
    ELSE
      ExtOutputInterval = 0
    END IF

    Nstep = GetInteger( Params,'Max Timestep Intervals',Found)
    IF(.NOT. Found) Nstep = 1
    ParticleInBox = GetLogical( Params,'Box Particle Collision',Found) .OR. &
        GetLogical( Params,'Box Particle Contact',Found)

    ParticleWall = GetLogical( Params,'Wall Particle Contact',Found) 
    IF(.NOT. Found) ParticleWall = .TRUE.

    TrueCollision = .FALSE.
    CALL ListAddLogical( Params,'True Collision Mode',TrueCollision)

    StatInfo = GetLogical( Params,'Particle Info',GotIt)

    IF( ParticleToField ) THEN
      Var => VariableGet( Mesh % Variables,'Particle Trace')      
      IF(.NOT. ASSOCIATED(Var)) THEN
        CALL Fatal('ParticleDynamics','Trace Variable should exist!')
      END IF
      ForceVector => Var % Values

      Var => VariableGet( Mesh % Variables,'Particle Weight')      
      IF(.NOT. ASSOCIATED(Var)) THEN
        CALL Fatal('ParticleDynamics','Weight Variable should exist!')
      END IF
      WeightVector => Var % Values
    END IF
  END IF

  ! Initialize particles at first time visiting, or each time if requested
  !-------------------------------------------------------------------------
  IF( VisitedTimes == 1 .OR. &
      GetLogical( Params,'Reinitialize Particles',GotIt) ) THEN
    CALL InitializeParticles( Particles ) 
  END IF

  IF( ParticleToField .AND. GetLogical( Params,'Reinitialize Field',GotIt) ) THEN
    WeightVector = 0.0_dp
    ForceVector = 0.0_dp
  END IF
  

  IF(StatInfo) THEN
    CALL ParticleStatistics( Particles, 0 )
    CALL ParticleStatistics( Particles, 1 )
  END IF

  ! a logaritmic scale of indexes is used to estimate time
  !--------------------------------------------------------
  cput1 = CPUTime()
  estindexes(1) = nstep / 2
  DO i=1,5
    estindexes(i+1) = estindexes(i) / 10
  END DO

  InitTimestep = .TRUE.

  DO i=1,nstep

    ! Get the timestep size, initialize at 1st round
    !--------------------------------------------------------------
    dtime = GetParticleTimeStep( Particles, InitTimestep )
    InitTimeStep = .FALSE.

    ! If size of timestep goes to zero then no more steps are needed
    !---------------------------------------------------------------
    IF( dtime < TINY( dtime ) ) EXIT	

    tottime = tottime + dtime

    TimeStepsTaken = TimeStepsTaken + 1
    ParticleStepsTaken = ParticleStepsTaken + Particles % NumberOfParticles

    ! Initialize the timestep, in practive just set force to zero
    !--------------------------------------------------------------
    CALL ParticleInitializeTime( Particles )

    ! If there is a decay time for the trace use it
    !--------------------------------------------------------------
    IF( ParticleToField ) THEN
      Tchar = GetCReal( Params,'Particle To Field Decay Time',GotIt)
      IF( GotIt ) THEN
        Cchar = EXP( -dtime / Tchar ) 
        WeightVector = Cchar * WeightVector 
        ForceVector = Cchar * ForceVector 
      END IF
    END IF

    ! If there are periodic BCs apply them just before locating the particles
    !------------------------------------------------------------------------
    CALL ParticleBoxPeriodic( Particles )

    ! Find the elements (and only the elements) in which the particles are in 
    ! This might also not be done for some particle-only problems but those 
    ! are probably not relevant in conjunction with Elmer.
    !------------------------------------------------------------------------

    PartitionChanges = 0

    CALL LocateParticles(Particles) 

    PartitionChanges = ChangeParticlePartition(Particles)

    DO WHILE(PartitionChanges > 0)
      CALL LocateParticles(Particles,PartitionChangesOnly=.TRUE.) 
      PartitionChanges=ChangeParticlePartition(Particles)
    END DO
    NoParticles = Particles % NumberOfParticles

    ! Calculate the force resulting from external fields in mesh
    ! and / or cumpulate the r.h.s. of matrix equation with data 
    !------------------------------------------------------------------
    DO No = 1, NoParticles

      Status = GetParticleStatus( Particles, No )
      IF( Status >= PARTICLE_LOST ) CYCLE
      IF( Status <= PARTICLE_INITIATED ) CYCLE
      
      ElementIndex = GetParticleElement( Particles, No )
      CurrentElement => Mesh % Elements( ElementIndex )
      
      Rfin = GetParticleCoord( Particles, No, 0 )
      Velo = GetParticleCoord( Particles, No, 1 )
   
      CALL ParticleFieldInteraction(CurrentElement, dtime, No, Status, &
          Rfin, Velo, Force ) 
      CALL AddParticleCoord( Particles, No, 2, Force )

      CALL SetParticleStatus( Particles, No, Status )      
    END DO

    ! Interaction with the walls
    !---------------------------------------------------------------
    IF( ParticleInBox ) THEN
      ! Faster for rectangular and hexahedral domains
      !---------------------------------------------------------------
      CALL  ParticleBoxContact( Particles ) 
    ELSE IF( ParticleWall ) THEN
      ! Generic version
      !---------------------------------------------------------------
      DO No = 1, NoParticles
        CALL ParticleWallContact( Particles, dtime, No  )
      END DO
    END IF

    ! If there is either collisions or contacts between particles
    ! create the structures for closest neighbours
    !------------------------------------------------------------
    FirstGhost = 0
    IF( CollisionInteraction .OR. ContactInteraction ) THEN
      CALL CreateNeighbourList( Particles )
      NoParticles = Particles % NumberOfParticles
    END IF

    ! Add the forces in case of collision contacts where the
    ! effect is mutated into acceleration values.
    !------------------------------------------------------------
    IF( CollisionInteraction ) THEN
      DO No=1,NoParticles
        IF ( Particles % Status(no) == PARTICLE_GHOST ) EXIT
        IF ( Particles % Status(no) == PARTICLE_LOST  ) CYCLE

        Coord = GetParticleCoord( Particles, No, 0 )
        Velo  = GetParticleCoord( Particles, No, 1 )

        DO WHILE(.TRUE.)
          No2 = GetNextNeighbour( Particles, No )           
          IF( No2 == 0 ) EXIT
          Coord2 = GetParticleCoord( Particles, No2, 0 )
          Velo2  = GetParticleCoord( Particles, No2, 1 )

          IF( ParticleParticleCollision(dtime,Coord,Coord2,Velo,Velo2,&
              Force,Force2) ) THEN
            CALL SetParticleCoord( Particles, No, 0, Coord )
            CALL SetParticleCoord( Particles, No2, 0, Coord2 )
            CALL AddParticleCoord( Particles, No, 2, Force )
            CALL AddParticleCoord( Particles, No2, 2, Force2 )
          END IF
        END DO
      END DO
      IF( No < NoParticles ) FirstGhost = No
    END IF

    ! Add contact interaction, for example due to granular forces
    !------------------------------------------------------------
    IF( ContactInteraction ) THEN
      DO No=1,NoParticles
        IF ( Particles % Status(no) == PARTICLE_GHOST ) EXIT
        IF ( Particles % Status(no) == PARTICLE_LOST  ) CYCLE
        
        Coord = GetParticleCoord( Particles, No, 0 )
        Velo  = GetParticleCoord( Particles, No, 1 )

        DO WHILE(.TRUE.)
          No2 = GetNextNeighbour( Particles, No )           
          IF( No2 == 0 ) EXIT
          Coord2 = GetParticleCoord( Particles, No2, 0 )
          Velo2  = GetParticleCoord( Particles, No2, 1 )

          IF ( ParticleParticleContact(dtime,Coord,Coord2,Velo,Velo2,&
              Force,Force2) ) THEN
            CALL AddParticleCoord( Particles, No, 2, Force )
            CALL AddParticleCoord( Particles, No2, 2, Force2 )
          END IF
        END DO
      END DO
      IF( No < NoParticles ) FirstGhost = No
    END IF

    ! This assumes that the real particles are followed by ghost particles. 
    ! which are destroyed before leaving this configuration.
    !---------------------------------------------------------------
    IF ( FirstGhost /= 0 ) THEN
      Particles % NumberOfParticles = FirstGhost - 1
      DO No=FirstGhost, NoParticles
        Particles % Status(No) = PARTICLE_LOST
      END DO
      NoParticles = Particles % NumberOfParticles
    END IF

    ! Do the update for particle velocities and positions
    ! v = v0 + at, r = r0 + vt
    !---------------------------------------------------------------
    CALL ParticleAdvanceTime( Particles, dtime )
    !---------------------------------------------------------------

    IF( OutputInterval > 0 ) THEN
      IF( MOD(i,OutputInterval) == 0) CALL ParticleOutput( Particles ) 
    END IF

    ! Write estimates of remaining time in log scale
    !---------------------------------------------------------------
    IF( ANY( estindexes == i ) ) THEN
      cput2 = CPUTime()
      WRITE( Message,'(A,F8.3)') 'Fraction computed (s)  :',(100.0_dp)*i/nstep
      CALL Info('ParticleDynamics',Message)
      WRITE( Message,'(A,F8.3)') 'Consumed time (s)  :',cput2-cput1
      CALL Info('ParticleDynamics',Message)
      WRITE( Message,'(A,F8.3)') 'Remaining time (s) :',(cput2-cput1)*(nstep-i)/i
      CALL Info('ParticleDynamics',Message)
    END IF
  END DO

  ! In the end, compute the fields
  ! Interaction with the fields is typically with external solvers
  ! so no idea to do it after each timestep.
  !---------------------------------------------------------------   

  IF( ParticleToField ) THEN
    CALL ParticleToFieldSolver( PSolver, WeightVector, ForceVector )
  END IF

  IF(StatInfo) THEN
    CALL ParticleStatistics( Particles, 0 )
    CALL ParticleStatistics( Particles, 1 )
  END IF
  
  IF( VisitedTimes == 1 ) THEN
    CALL ParticleOutput( Particles ) 
  ELSE IF( ExtOutputInterval > 0) THEN
    IF( MOD(VisitedTimes,ExtOutputInterval) == 0) THEN
      CALL ParticleOutput( Particles ) 
    END IF
  ELSE IF( OutputInterval == 0) THEN
    CALL ParticleOutput( Particles ) 
  END IF


  IF(.TRUE.) THEN
    IF( ParEnv % PEs > 1 ) THEN
      TotNoParticles =  NINT( ParallelReduction( 1.0_dp * Particles % NumberOfParticles ) )
      TotParticleStepsTaken = NINT( ParallelReduction( 1.0_dp * ParticleStepsTaken) )
    ELSE
      TotNoParticles = Particles % NumberOfParticles 
      TotParticleStepsTaken =  ParticleStepsTaken
    END IF
    
    IF ( ParEnv % mype==0 ) THEN
      WRITE (Message,'(A,T22,I12)') 'Active particles:',TotNoParticles
      CALL Info('ParticleDynamics',Message)
      WRITE (Message,'(A,T22,F12.2)') 'Elapsed time:',tottime
      CALL Info('ParticleDynamics',Message)
      WRITE (Message,'(A,T22,I12)') 'Time steps taken:',TimeStepsTaken
      CALL Info('ParticleDynamics',Message)
      WRITE (Message,'(A,T22,I12)') 'Particle steps taken:',TotParticleStepsTaken
      CALL Info('ParticleDynamics',Message)
    END IF
  END IF


  CALL Info('ParticleDynamics','All done',Level=4)
  CALL Info('ParticleDynamics', '-----------------------------------------', Level=4 )
  

 CONTAINS



   
  
   !------------------------------------------------------------------------
   ! Compute field values at the given points in the FE mesh. 
   !-------------------------------------------------------------------------
   SUBROUTINE ParticleFieldInteraction(CurrentElement,dtime,No,&
       Status,Coord,Velo, Force )
     
     TYPE(Element_t), POINTER :: CurrentElement
     INTEGER :: No, Status
     REAL(KIND=dp) :: dtime, Coord(3),Velo(3), Force(3)
     
     TYPE(Mesh_t), POINTER :: Mesh
     TYPE(Valuelist_t), POINTER :: Params
     REAL(KIND=dp) :: PotAtPoint, GradPotAtPoint(3),VeloAtPoint(3), &
         GradVeloAtPoint(3,3)
     LOGICAL :: Stat, UseGradVelo, CoordCond, VeloCond, Visited = .FALSE., &
         GotPot, GotVelo
     INTEGER :: i,j,k,n,dim,FieldMode,TimeOrder
     INTEGER, POINTER :: NodeIndexes(:), FieldPerm(:),FieldIndexes(:)
     REAL(KIND=dp) :: SqrtElementMetric, Weight, Decay, Dist, ParticleVolume, &
         FluidDensity, FluidViscosity, Rad
     REAL(KIND=dp), POINTER :: Basis(:), dBasisdx(:,:)
     LOGICAL :: GotIt
     REAL(KIND=dp) :: mass, charge, dragcoeff, val
     REAL(KIND=dp) :: damping, Gravity(3)
     REAL(KIND=dp), POINTER :: gWork(:,:)
     LOGICAL :: GotGravity, GotDamping, GotBuoyancy, GotField


     SAVE :: Visited, dim, Basis, dBasisdx, mass, charge, dragcoeff, FieldPerm, &
         FieldMode, Decay, UseGradVelo, TimeOrder, GotGravity, GotDamping, &
         GotPot, GotVelo, Gravity, Damping, VeloCond, CoordCond, GotBuoyancy, &
         ParticleVolume, GotField, Rad
  
     IF( .NOT. Visited ) THEN
       Mesh => GetMesh()

       dim = Mesh % MeshDim
       n = Mesh % MaxElementNodes
       ALLOCATE( Basis(n), dBasisdx(n, 3) )
       
       ! These physical parameters could basically vary from call to call
       !-------------------------------------------------------------------------
       Params => GetSolverParams()

       mass = GetCReal( Params,'Particle Mass')
       damping = GetCReal( Params,'Particle Damping',GotDamping)

       Params => GetSolverParams()
       GotBuoyancy = GetLogical( Params,'Particle Lift',Found)
       IF( GotBuoyancy ) THEN
         Rad = GetCReal(Params,'Particle Radius')
         IF( dim == 2 ) THEN
           ParticleVolume = PI * Rad ** 2
         ELSE
           ParticleVolume = (4.0_dp/3) * PI * Rad ** 3
         END IF
       END IF

       GotGravity = GotBuoyancy .OR. ListGetLogical( Params,'Particle Gravity',Found)
       IF( GotGravity ) THEN
         gWork => ListGetConstRealArray( CurrentModel % Constants,'Gravity',GotGravity)
         IF ( ASSOCIATED(gwork) ) THEN
           Gravity = gWork(4,1) * gWork(1:3,1)
         ELSE
           CALL Fatal('ParticleFieldInteraction','Gravity and Lift requires gravity!')
         END IF
       END IF

       GotPot = ListCheckPresent(Params,'Potential Variable Name')
       IF( GotPot ) THEN
         charge = GetCReal( Params,'Particle Charge',Found)
         IF(.NOT. Found) CALL Fatal('ParticleFieldInteraction',&
             '> Particle Charge < not given!')
       END IF

       dragcoeff = GetCReal( Params,'Particle Drag Coefficient',Found)
       GotVelo = ListCheckPresent(Params,'Velocity Variable Name')
       IF( GotVelo ) THEN
         IF(.NOT. Found) CALL Fatal('ParticleFieldInteraction',&
             '> Particle Drag Coefficient < not given!')        
         UseGradVelo = GetLogical( Params,'Velocity Gradient Correction',Found)
       END IF
    
       VeloCond = ListCheckPresent(Params,'Velocity Condition Variable Name')
       CoordCond = ListCheckPresent(Params,'Coordinate Condition Variable Name')

       FieldMode = GetInteger( Params,'Particle To Field Mode',Found)
       IF( FieldMode == 4 ) THEN
         Decay = GetCReal( Params,'Particle Decay Distance')
       END IF

       TimeOrder = Particles % TimeOrder

       IF( ParticleToField ) THEN
         FieldPerm => Solver % Variable % Perm
       END IF

       GotField = ParticleToField .OR. GotVelo .OR. GotPot .OR. &
           VeloCond .OR. CoordCond .OR. GotBuoyancy

       Visited = .TRUE.
     END IF
     
     Force = 0.0_dp
     
     !-------------------------------------------------------------------------
     ! Add constant fields i.e. gravity and constant damping force
     !-------------------------------------------------------------------------
     IF( GotGravity ) THEN
       Force = Force + Gravity * Mass
     END IF

     ! For 1st order models the velocity is solved implicitely, when drag is known
     IF( GotDamping .AND. TimeOrder == 2 ) THEN
       Force = Force - damping * Velo * Mass 
     END IF
     
     

     IF(.NOT. GotField ) RETURN
     
     stat = GlobalElementInfo( CurrentElement, Coord, &
         SqrtElementMetric, Basis, dBasisdx )


     !-------------------------------------------------------------------------
     ! Set Dirichlet conditions for velocity / coordinate
     ! The condition is computed from an external field and hence this is the 
     ! appropriate place to set this flag.
     !-------------------------------------------------------------------------
     IF( VeloCond ) THEN
       IF( GetVelocityConditionInMesh(CurrentElement, Basis ) ) &
           Status = PARTICLE_FIXEDVELO
     END IF
     IF( CoordCond ) THEN
       IF( GetCoordinateConditionInMesh(CurrentElement, Basis ) ) &
           Status = PARTICLE_FIXEDCOORD
     END IF


     !-------------------------------------------------------------------------
     ! Add interaction with fields i.e. fluidic, electrostatic forces etc.
     ! If acceleration is not needed solve implicitely for the velocity
     ! when drag coefficient is known. Hence do not set that as force here.
     !-------------------------------------------------------------------------
     IF( GotVelo ) THEN
       IF( UseGradVelo ) THEN       
         CALL GetVelocityInMesh(CurrentElement, Basis, VeloAtPoint, &
             dBasisdx, GradVeloAtPoint )
         DO i=1,dim
           VeloAtPoint(i) = VeloAtPoint(i) + &
               0.5_dp * SUM( GradVeloAtPoint(i,1:dim) * Velo(1:dim) ) * dtime        
         END DO
       ELSE
         CALL GetVelocityInMesh(CurrentElement, Basis, VeloAtPoint )
       END IF
       IF( TimeOrder == 2 ) THEN
         Force = Force + dragcoeff * ( VeloAtPoint - Velo )  
       ELSE     
         Force = Force + dragcoeff * VeloAtPoint 
       END IF
     END IF

     IF( GotPot ) THEN
       CALL GetPotentialInMesh(CurrentElement, Basis, PotAtPoint, dBasisdx, GradPotAtPoint )
       Force = Force + charge * GradPotAtPoint 
     END IF

     IF( GotBuoyancy ) THEN
       CALL GetFluidPropertiesInMesh(Particles, CurrentElement, Basis, Coord, Rad, &
           FluidDensity, FluidViscosity ) 
       Force = Force - Gravity * ParticleVolume * FluidDensity
     END IF


     IF( ANY( ISNAN( Force ) ) ) THEN
       PRINT *,'Gravity',Gravity,ParticleVolume,FluidDensity
       PRINT *,'charge',GradPotAtPoint
       PRINT *,'dragcoeff',dragcoeff
       PRINT *,'Basis',Basis
       PRINT *,'VeloAtPoint',VeloAtPoint
       IF( UseGradVelo) PRINT *,'GradVelo',GradVeloAtPoint
     END IF

     !-------------------------------------------------------------------------
     ! the value at point is obtained from a property of the particles
     ! which may be accumulated with time. Note that the weight could
     ! be also ~1/r^2 from the nodes etc. 
     !-------------------------------------------------------------------------
     IF( ParticleToField ) THEN
       IF( FieldMode == 1) THEN
         ! the kinetic energy
         val = 0.5 * mass * SUM( Velo ** 2 ) 
       ELSE IF( FieldMode == 2 ) THEN
         ! potential energy
         val = Mass * SUM( Gravity(1:dim) * Coord(1:dim) )
       ELSE IF( FieldMode == 3 ) THEN
         ! kinetic + potential energy
         val = Mass * ( 0.5 * SUM( Velo(1:dim)**2 ) + &
             SUM( Gravity(1:dim) * Coord(1:dim) ) )
       ELSE IF( FieldMode == 4 ) THEN       
         ! electrostatic potential energy at point (for testing)
         val = Charge * PotAtPoint
       ELSE IF( FieldMode == 5 ) THEN       
         ! exteranl speed at point (for testing)
         val = SQRT( SUM( VeloAtPoint ** 2 ) )
       ELSE IF( FieldMode == 6 ) THEN 
         ! exponential decay, e.g. volumetric heat source
         dist = Particles % Distance( No ) 
         val = EXP(-dist/decay)
       ELSE
         val = SQRT( SUM( Force(1:dim) ** 2 ) )
       END IF

       n = CurrentElement % TYPE % NumberOfNodes
       NodeIndexes => CurrentElement % NodeIndexes
       
       DO i = 1,n
         j = FieldPerm( NodeIndexes(i) )
         IF( j == 0 ) CYCLE
         
         weight = SqrtElementMetric * Basis(i)

         WeightVector( j ) = WeightVector( j ) + weight 
         ForceVector( j ) = ForceVector( j ) + weight * val
       END DO
     END IF

   END SUBROUTINE ParticleFieldInteraction
   

   
   !--------------------------------------------------------------------------------------    
   ! Subroutine for getting the force resulting from particle-particle interaction 
   ! This could be used to give forces on granular flow, for example. 
   !--------------------------------------------------------------------------------------    
   FUNCTION ParticleParticleContact(dt,Coord,Coord2,Velo,Velo2,&
       Force,Force2) RESULT ( Contact ) 
     
     REAL(KIND=dp):: dt,Coord(3),Coord2(3),Velo(3),Velo2(3),Force(3),Force2(3)
     LOGICAL :: Contact 
     
     REAL(KIND=dp) :: Rad, Mass, Spring, Damping, Friction
     REAL(KIND=dp) :: dist,dr(3),dv(3),eta,rn(3),vn(3),speed,tn1(3),tn2(3)
     REAL(KIND=dp) :: damp_force, spring_force
     TYPE(ValueList_t), POINTER :: Params
     LOGICAL :: Visited=.FALSE.
     
     SAVE Visited, Rad, Mass, Spring, Damping, Friction
     
     ! At the first time of calling the particle parameters are just tested
     IF(.NOT. Visited ) THEN
       Params => GetSolverParams()
       Rad = GetCReal(Params,'Particle Radius')
       Mass = GetCReal(Params,'Particle Mass')         
       Spring = GetCReal(Params,'Particle Spring')        
       Damping = GetCReal(Params,'Particle Damping')
       Friction = GetCReal(Params,'Particle Friction')
       Visited = .TRUE.
     END IF
     
     Contact = .FALSE.
     
     ! relative displacement 
     dr = Coord - Coord2
     dist = SQRT( SUM( dr * dr ) ) 

     ! if they overlap, what to do?
     IF ( dist==0._dp ) RETURN
     
     ! no contact if the distance is too large
     eta = 2 * Rad - dist
     IF( eta < 0 ) RETURN
     
     ! normal vector for contact
     IF( dist > TINY( dist ) ) THEN
       rn = dr / dist
     ELSE
       CALL Fatal('ParticleParticleContact','Particles are at same point!')
     END IF

     ! avoi division by zero at all cost
     dv = Velo - Velo2
     speed = SQRT( SUM( dv * dv ) )
     IF( speed > TINY( speed ) ) THEN
       vn = dv / speed
     ELSE
       speed = SQRT( SUM( Velo(1:dim)**2) )
       IF( speed > TINY( speed ) ) THEN
         vn = Velo / speed
       ELSE
         vn = 0.0_dp
         vn(1) = 1.0_dp
       END IF
     END IF


     ! if one needs tangent directions, then activate this
     IF(.FALSE.) THEN
       CALL TangentDirections( rn, tn1, tn2 )
     END IF
     
     ! Currently a linear spring respect to the displacement is given
     ! Here is the place to put the force which could be a complicated function
     ! f=f(r,v,...)
        
     spring_force = eta * Spring 
     damp_force = MIN( speed * Damping, spring_force * Friction )
     damp_force = 0.0_dp


     Force = spring_force * rn - damp_force * vn     
     ! law of force and counterforce:
     Force2 = -Force


     IF( ANY( ISNAN( Force ) ) ) THEN
       PRINT *,'Force',Force
       PRINT *,'spring force',spring_force
       PRINT *,'eta',eta
       PRINT *,'spring'
       PRINT *,'vn',vn
       PRINT *,'damp_force',damp_force
     END IF


     Contact = .TRUE.
     
   END FUNCTION ParticleParticleContact
   


!------------------------------------------------------------------------------
END SUBROUTINE ParticleDynamics
!------------------------------------------------------------------------------


