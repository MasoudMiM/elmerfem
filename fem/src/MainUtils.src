!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - Scientific Computing Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *

! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Utility routines for the elmer main program.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Ville Savolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - Scientific Computing Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/
! *
! * $Log: MainUtils.src,v $
! * Revision 1.36  2007/08/21 07:19:26  raback
! * Unified norm and change output.
! *
! * Revision 1.35  2007/08/16 19:41:19  raback
! * Improved the convergence control options and applied it to FlowSolve.
! *
! * Revision 1.33  2007/08/15 11:38:41  jpr
! * Bug fix: in a few places check whether variable size>0 before accessing
! * variables values.
! *
! * Revision 1.32  2007/08/15 09:44:02  jpr
! * Changes to update convergence criteria computations (Peter,Juha).
! *
! * Revision 1.30  2007/05/11 10:29:12  jpr
! * Small cleanups.
! *
! * Revision 1.29  2007/04/23 12:29:09  jpr
! * Removed some old code.
! *
! * Revision 1.23  2007/02/07 11:42:22  jpr
! * Enabled "Exported Variable n" defintions of "Internal Solvers". Added
! * keyword "Radiation Solver" to use if "Equation=Heat Equation" solver
! * not present.
! *
! * Revision 1.22  2006/12/20 09:23:32  jpr
! * Corrected messed up indentation.
! *
! * Revision 1.21  2006/12/18 13:09:42  jpr
! * Removed debug prints.
! *
! * Revision 1.20  2006/12/18 13:06:24  jpr
! * Harmonic analysis additions.
! *
! * Revision 1.19  2006/12/18 12:23:07  jpr
! * Added 'Harmonic analysis' option.
! *
! * Revision 1.18  2006/12/01 09:02:17  jpr
! * Initial changes to enable 'constant bulk system' for time dependent
! * simulations.
! *
! * Revision 1.17  2006/11/27 10:23:57  jpr
! * Removed some execess (unrelated) use of TRIM & POINTER.
! *
! * Revision 1.13  2006/10/09 09:33:52  jpr
! * Added 'exec interval'-keyword to solver stuff.
! *
! * Revision 1.9  2006/01/10 08:51:49  apursula
! * Updated header information (GPL).
! *
! * Revision 1.8  2005/12/22 10:27:00  jpr
! * Added solver section keyword 'Timestep scale'.
! *
! * Revision 1.7  2005/12/07 12:54:15  jpr
! * Changes to have gfortran happy / bug fix in "exported variable" defs.
! *
! * Revision 1.6  2005/07/07 09:12:27  jpr
! * Changed ElementInfo to have dBasisdx,ddBasisddx as OPTIONAL arguments.
! * Changed all calls to ElementInfo accordingly.
! *
! * Revision 1.5  2005/07/06 08:38:00  jpr
! * Some comments added.
! *
! * Revision 1.4  2005/06/22 04:40:52  jpr
! * Bubbles to global system by default.
! *
! * Revision 1.3  2005/05/26 12:33:14  jpr
! * Removed explicit DLLEXPORT definitions
! *
! * Revision 1.2  2005/05/26 11:32:55  vierinen
! * umfpack changes
! *
! * Revision 1.1  2005/05/26 08:24:30  vierinen
! * moved .f90 to .src because .f90 is needed for preprosessed files
! *
! * Revision 1.2  2005/05/04 09:16:04  vierinen
! * minor modifications
! *
! * Revision 1.157  2005/04/14 11:36:15  jpr
! * Removed the Sparse library interface.
! *
! * Revision 1.148  2004/03/03 10:22:37  jpr
! * Corrected bug in radiation factors&matrix structured introduced
! * by previous changes.
! *
! * Revision 1.147  2004/03/03 09:40:36  jpr
! * Changed strategy of allocation of solver primary variables somewhat.
! *
! * 
! * $Id: MainUtils.src,v 1.36 2007/08/21 07:19:26 raback Exp $
! *****************************************************************************/

MODULE MainUtils

!------------------------------------------------------------------------------

  USE SolverUtils
  USE ModelDescription

!------------------------------------------------------------------------------
  IMPLICIT NONE
!------------------------------------------------------------------------------

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION GetMatrixFormat( Model, Equation ) RESULT(FORMAT)
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    CHARACTER(LEN=*) :: Equation
!------------------------------------------------------------------------------
    INTEGER :: FORMAT

    INTEGER :: i
    LOGICAL :: Found
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
!
!
    FORMAT = MATRIX_CRS

!
! TODO: The following code always selects the MATRIX_CRS as format
! and should be removed...
! -----------------------------------------------------------------
    DO i=1,Model % NumberOfSolvers
       IF (  &
            ListGetString(Model % Solvers(i) % Values, 'Equation') == Equation &
            ) THEN

          str = ListGetString( Model % Solvers(i) % Values, & 
                  'Linear System Solver', Found )
          IF ( .NOT. Found ) str = 'direct'

          IF ( str == 'direct' ) THEN
             str = ListGetString(Model % Solvers(i) % Values, &
                  'Linear System Direct Method', Found )

             IF ( .NOT. Found ) THEN
                FORMAT = MATRIX_CRS
             ELSE
                SELECT CASE( str )
                CASE( 'banded', 'symmetric banded' )
                   FORMAT = MATRIX_CRS

                CASE( 'umfpack' )
#include "../config.h"
#ifdef HAVE_UMFPACK
                   FORMAT = MATRIX_CRS
#else
                   CALL Fatal( 'GetMatrixFormat', 'UMPACK solver has not been installed.' )
#endif
                CASE DEFAULT
                   CALL Warn( 'GetMatrixFormat', 'Unknown direct solver method: ' // TRIM(str) )
                   CALL Warn( 'GetMatrixFormat', 'band solver (LAPACK) will be used.' )
                   FORMAT = MATRIX_CRS
                END SELECT
             END IF
          ELSE IF ( str == 'iterative' ) THEN
             FORMAT = MATRIX_CRS
          ELSE IF ( str == 'multigrid' ) THEN
             FORMAT = MATRIX_CRS
          ELSE
             CALL Fatal( 'GetMatrixFormat', 'Unknown linear system solver: ' // TRIM(str) )
             STOP
          END IF

          EXIT
       END IF
    END DO
!------------------------------------------------------------------------------
  END FUNCTION GetMatrixFormat
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddSolverProcedure( Solver,PROCEDURE  )
!------------------------------------------------------------------------------
    TYPE(Solver_t) :: Solver
    EXTERNAL :: PROCEDURE
    INTEGER  :: PROCEDURE
!------------------------------------------------------------------------------
    INTEGER(KIND=AddrInt) :: AddrFunc
!------------------------------------------------------------------------------
    Solver % PROCEDURE = AddrFunc( PROCEDURE )
!------------------------------------------------------------------------------
  END SUBROUTINE AddSolverProcedure
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddEquation( Solver, Name,Transient )
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
    CHARACTER(LEN=*) :: Name
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: Solution(:), Component(:)

    INTEGER, POINTER :: Perm(:)

    INTEGER(KIND=AddrInt) :: InitProc

    INTEGER :: MaxDGDOFs, MaxNDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs
    INTEGER :: i,j,k,l,NDeg,Nrows,nSize,n,DOFs,MatrixFormat,istat,Maxdim

    LOGICAL :: Found, BandwidthOptimize, EigAnal, ComplexFlag, &
    MultigridActive, VariableOutput, GlobalBubbles, HarmonicAnal, MGAlgebraic

    CHARACTER(LEN=MAX_NAME_LEN) :: str,eq,var_name, tmpname

    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix

    TYPE(Variable_t), POINTER :: Var
    TYPE(Variable_t), POINTER :: NewVariable

    REAL(KIND=dp) :: tt, CPUTime
    REAL(KIND=dp), POINTER :: freqv(:,:)

    EXTERNAL FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver
    INTEGER :: FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver

    !------------------------------------------------------------------------------

    eq = ListGetString( Solver % Values, 'Equation', Found )
    IF ( Found ) THEN
      MAXdim = 0
      DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
         CurrentElement => Solver % Mesh % Elements(i)
         IF ( CheckElementEquation( CurrentModel, CurrentElement, eq ) ) THEN
           Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
         END IF
      END DO
      CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
    END IF

    str = ListGetString( Solver  % Values, 'Procedure', Found )
    IF ( Found ) THEN
      InitProc = GetProcAddr( TRIM(str)//'_Init', abort=.FALSE. )
      IF ( InitProc /= 0 ) THEN
        CALL ExecSolver( InitProc, CurrentModel, Solver, &
                 Solver % dt, Transient )
      END IF
    END IF
 

    MaxNDOFs  = 0
    MaxDGDOFs = 0
    DO i=1,Solver % Mesh % NumberOFBulkElements
      CurrentElement => Solver % Mesh % Elements(i)
      MaxDGDOFs = MAX( MaxDGDOFs, CurrentElement % DGDOFs )
      MaxNDOFs  = MAX( MaxNDOFs,  CurrentElement % NDOFs )
    END DO

    MaxEDOFs = 0
    DO i=1,Solver % Mesh % NumberOFEdges 
      CurrentElement => Solver % Mesh % Edges(i)
      MaxEDOFs  = MAX( MaxEDOFs,  CurrentElement % BDOFs )
    END DO

    MaxFDOFs = 0
    DO i=1,Solver % Mesh % NumberOFFaces 
      CurrentElement => Solver % Mesh % Faces(i)
      MaxFDOFs  = MAX( MaxFDOFs,  CurrentElement % BDOFs )
    END DO

    MaxBDOFs = 0
      DO i=1,Solver % Mesh % NumberOFBulkElements
      CurrentElement => Solver % Mesh % Elements(i)
      MaxBDOFs  = MAX( MaxBDOFs,  CurrentElement % BDOFs )
    END DO

    GlobalBubbles = ListGetLogical( Solver % Values, 'Bubbles in Global System', Found )
    IF (.NOT.Found) GlobalBubbles=.TRUE.

    Ndeg = 0
    Ndeg = Ndeg + Solver % Mesh % NumberOfNodes 
    IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Solver % Mesh % NumberOFEdges
    IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Solver % Mesh % NumberOFFaces
    IF ( GlobalBubbles ) &
    Ndeg = Ndeg + MaxBDOFs * Solver % Mesh % NumberOfBulkElements
    IF ( ListGetLogical( Solver % Values, 'Discontinuous Galerkin', Found ) ) &
      Ndeg = MAX( NDeg, MaxDGDOFs * (Solver % Mesh % NumberOfBulkElements+ &
              Solver % Mesh % NumberOfBoundaryElements) )

    Solver % Order = 1

    IF ( Transient ) THEN
      str = ListGetString( Solver % Values, 'Timestepping Method',Found )
      IF ( .NOT. Found ) THEN
        str = ListGetString( CurrentModel % Simulation, 'Timestepping Method',Found )
        IF ( Found ) THEN
          CALL ListAddString( Solver % Values, 'Timestepping Method', str )
        END IF
      END IF

      IF ( Found ) THEN
        IF (str=='bdf') THEN
          Solver % Order = ListGetInteger( Solver % Values, &
                'BDF Order', Found, minv=1, maxv=5 )
          IF ( .NOT. Found ) THEN
            Solver % Order = ListGetInteger( CurrentModel % &
                    Simulation, 'BDF Order', Found, minv=1, maxv=5 )
          END IF
          IF ( .NOT.Found ) THEN
              Solver % Order = 2
            CALL Warn( 'AddEquation', 'BDF order defaulted to 2.' )
          END IF
        ELSE IF ( str=='runge-kutta') THEN
          Solver % Order = ListGetInteger( CurrentModel % &
                    Simulation, 'Runge-Kutta Order', Found, minv=2, maxv=4 )
          IF ( .NOT.Found ) Solver % Order = 2
        END IF
      ELSE
        CALL Warn( 'AddEquation', 'Time stepping method defaulted to IMPLICIT EULER' )
        CALL ListAddString( Solver % Values, 'Timestepping Method', 'Implicit Euler' )
      END IF
    END IF

    Solver % TimeOrder = 1
    !------------------------------------------------------------------------------

    DOFs = CoordinateSystemDimension()
    IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = DOFs + 1

    MatrixFormat = GetMatrixFormat( CurrentModel, Name )

    BandwidthOptimize = ListGetLogical( Solver % Values, &
            'Optimize Bandwidth', Found )
    IF ( .NOT. Found ) BandwidthOptimize = .TRUE.

    VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
    IF ( .NOT. Found ) VariableOutput = .TRUE.

    var_name = ListGetString( Solver % Values, 'Variable', Found )
    IF ( Found ) THEN
      IF ( var_name(1:9) == '-nooutput' ) THEN
        VariableOutput = .FALSE.
        var_name(1:LEN(var_name)-10) = var_name(11:)
      END IF
    END IF

    !------------------------------------------------------------------------------
    SELECT CASE( Name )       
    !------------------------------------------------------------------------------

      !------------------------------------------------------------------------------
      CASE('navier-stokes')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Flow Solution')

      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg), STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF

      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, Perm, &
                  DOFs+1, MatrixFormat, BandwidthOptimize, 'Navier-Stokes', GlobalBubbles=GlobalBubbles )

      Nrows =(DOFs+1)* Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )

        ! First add components to the variable list separately (must be done
        ! this way for the output routines to work properly...):
        !---------------------------------------------------------------------
        Component => Solution( 1 : Nrows: DOFs+1 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 1', &
                    1, Component, Perm, Output=VariableOutput )

        Component => Solution( 2 : Nrows: DOFs+1 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 2', &
                  1, Component, Perm, Output=VariableOutput )

        IF ( DOFs+1 == 3 ) THEN
          Component => Solution( 3 : Nrows: DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
                  1, Component, Perm, Output=VariableOutput )
        ELSE
          Component => Solution( 3 : Nrows: DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 3', &
                  1, Component, Perm, Output=VariableOutput )

          Component => Solution( 4 : Nrows : DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
                  1, Component, Perm, Output=VariableOutput )
        END IF

        ! Then add the thing itself:
        !---------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
          'Flow Solution',DOFs+1,Solution,Perm, Output=VariableOutput )

        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Flow Solution' )
        Solution = 1.0d-6
      END IF
      CALL AddSolverProcedure( Solver, FlowSolver )
      !------------------------------------------------------------------------------


      !------------------------------------------------------------------------------
      CASE('magnetic induction')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Magnetic Field')

      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(NDeg),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Elmer Solver: Memory allocation error.' )
        END IF
      END IF

      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
                  Perm,3, MatrixFormat, BandwidthOptimize, 'Magnetic Induction', GlobalBubbles=GlobalBubbles )

      Nrows = 3*Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )

        Component => Solution( 1 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
                    'Magnetic Field 1', 1, Component, Perm,Output=VariableOutput )

        Component => Solution( 2 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
                    'Magnetic Field 2', 1, Component, Perm,Output=VariableOutput )

        Component => Solution( 3 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
                    'Magnetic Field 3', 1, Component, Perm,Output=VariableOutput )
        !------------------------------------------------------------------------------
        !         Then add the thing itself
        !------------------------------------------------------------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
                    'Magnetic Field',3,Solution,Perm,Output=VariableOutput )

        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Magnetic Field' )

        Solution = 0.0d0
        !------------------------------------------------------------------------------
        !         Add first components to the variable list separately...
        !------------------------------------------------------------------------------
        ALLOCATE( Solution(Nrows), STAT=istat )

        Component => Solution( 1 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
                  'Electric Current 1', 1, Component, Perm,Output=VariableOutput )

        Component => Solution( 2 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
                  'Electric Current 2', 1, Component, Perm,Output=VariableOutput )

        Component => Solution( 3 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
                  'Electric Current 3', 1, Component, Perm,Output=VariableOutput )
        !------------------------------------------------------------------------------
        !         Then add the thing itself
        !------------------------------------------------------------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
                    'Electric Current', 3, Solution, Perm, Output=VariableOutput )
        Solution = 0.0d0
      END IF
      CALL AddSolverProcedure( Solver, MagneticSolver )
      !------------------------------------------------------------------------------


      !------------------------------------------------------------------------------
      CASE('stress analysis')
      !------------------------------------------------------------------------------
      IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2

      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(NDeg),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF

      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
        Perm, DOFs, MatrixFormat, BandwidthOptimize, &
             'Stress Analysis', GlobalBubbles=GlobalBubbles )

      Nrows = DOFs*Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT.ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )

        ! First add the components to the variable list separately:
        !----------------------------------------------------------
        Component => Solution( 1 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
                  'Displacement 1',1, Component, Perm,Output=VariableOutput )

        Component => Solution( 2 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
                 'Displacement 2', 1, Component, Perm,Output=VariableOutput )

        IF ( CoordinateSystemDimension() >= 3 ) THEN
          Component => Solution( 3 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver,  &
                'Displacement 3', 1, Component, Perm, Output=VariableOutput )
        END IF

        ! Then add the thing itself:
        !---------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
                    'Displacement',DOFs,Solution,Perm,Output=VariableOutput )

        Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')

        Solution = 0.0D0
      END IF
      CALL AddSolverProcedure( Solver, StressSolver )
      !------------------------------------------------------------------------------


      !------------------------------------------------------------------------------
      CASE('mesh update')
      !------------------------------------------------------------------------------
      IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2

      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Mesh Update')
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg), STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF

      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
                  Perm, DOFs, MatrixFormat, BandwidthOptimize, 'Mesh Update', GlobalBubbles=GlobalBubbles )
      IF ( .NOT. ASSOCIATED( Solver % Matrix ) )  RETURN

      Nrows = DOFs*Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF (.NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )

        ! First add the components to the variable list separately:
        !----------------------------------------------------------
        Component => Solution( 1 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
                  'Mesh Update 1',1, Component, Perm,Output=VariableOutput )

        Component => Solution( 2 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
                  'Mesh Update 2', 1, Component, Perm,Output=VariableOutput )

        IF ( CoordinateSystemDimension() >= 3 ) THEN
          Component => Solution( 3 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver,  &
                   'Mesh Update 3', 1, Component, Perm,Output=VariableOutput )
        END IF

        !      Then add the thing itself...
        !------------------------------------------------------------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
                    'Mesh Update',DOFs,Solution,Perm,Output=VariableOutput )
        Solution = 0.0d0
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Mesh Update' )
      END IF

      Var =>  VariableGet( Solver % Mesh % Variables, 'Mesh Velocity')
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        IF ( Transient ) THEN
          ALLOCATE( Solution(Nrows), STAT=istat )
          IF ( istat /= 0 ) THEN
            CALL Fatal( 'AddEquation', 'Memory allocation error.' )
          END IF

          Component => Solution( 1 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, &
               Solver, 'Mesh Velocity 1',1, Component, Perm,Output=VariableOutput)

          Component => Solution( 2 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, &
               Solver, 'Mesh Velocity 2', 1, Component, Perm,Output=VariableOutput)

          IF ( CoordinateSystemDimension() >= 3 ) THEN
            Component => Solution( 3 : Nrows : DOFs )
            CALL VariableAdd(Solver % Mesh % Variables,Solver % Mesh, &
               Solver, 'Mesh Velocity 3', 1, Component, Perm,Output=VariableOutput)
          END IF

          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
                    'Mesh Velocity',DOFs,Solution,Perm,Output=VariableOutput )
  
          Solution = 0.0D0
        END IF
      END IF
      CALL AddSolverProcedure( Solver, MeshSolver )
      !------------------------------------------------------------------------------
      !------------------------------------------------------------------------------


      !------------------------------------------------------------------------------
      CASE('heat equation')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )

      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg),STAT=istat )
      END IF

      eq = ListGetString( CurrentModel % Simulation, 'Gebhardt Factors',Found )
      IF ( Found ) THEN
        CALL LoadGebhardtFactors( Solver % Mesh,eq )
      ELSE
        CALL RadiationFactors( Solver, .TRUE.)
      END IF

      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
                  Perm,1, MatrixFormat, BandwidthOptimize, &
                          'Heat Equation', GlobalBubbles=GlobalBubbles)

      Nrows = Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF

        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, Solver,&
                    'Temperature',1, Solution, Perm, Output=VariableOutput )

        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )
        Solution = 0.0d0
      END IF
      CALL AddSolverProcedure( Solver, HeatSolver )
      !------------------------------------------------------------------------------

      !------------------------------------------------------------------------------
      CASE DEFAULT
      !------------------------------------------------------------------------------
      str = ListGetString( Solver % Values, 'Procedure', Found )
      IF(Found) Solver % PROCEDURE = GetProcAddr(str)

      NULLIFY( Solver % Matrix )
      NULLIFY( Solver % Variable )
      Solver % TimeOrder = 0

      eq = ListGetString( Solver  % Values, 'Equation', Found )

      IF ( Found ) THEN
        var_name = ListGetString( Solver % Values, 'Variable', Found )
        IF ( Ndeg >= 1 .AND. Found ) THEN
          DOFs = ListGetInteger( Solver % Values, 'Variable DOFs', Found, minv=1 )
          IF ( .NOT. Found ) THEN
            j = 0
            DOFs = 0
            DO WHILE( .TRUE. )
              i = INDEX( var_name(j+1:), ':' ) + j
              IF ( i<=j ) EXIT
              READ( var_name(i+1:),'(i1)' ) k
              DOFs = DOFs + k
              j = i + 1
            END DO
          END IF

          VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
          IF ( .NOT. Found ) VariableOutput = .TRUE.

          DO WHILE( var_name(1:1) == '-' )
            IF ( var_name(1:10) == '-nooutput ' ) THEN
              VariableOutput = .FALSE.
              var_name(1:LEN(var_name)-10) = var_name(11:)
            END IF

            IF ( var_name(1:6) == '-dofs ' ) THEN
              READ( var_name(7:), * ) DOFs
              i = 7
              j = LEN_TRIM( var_name )
              DO WHILE( var_name(i:i) /= ' '  )
                i = i + 1
                IF ( i > j ) EXIT
              END DO
              var_name(1:LEN(var_name)-i) = var_name(i+1:)
            END IF
          END DO
          IF ( DOFs == 0 ) DOFs = 1

          n = LEN_TRIM(var_name)
          Solver % Variable => VariableGet( Solver % Mesh % Variables,var_name(1:n) )
          IF ( ASSOCIATED( Solver % Variable ) ) THEN
            Perm => Solver % Variable % Perm
          ELSE
            ALLOCATE( Perm(Ndeg) )
          END IF

          Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
               Perm, DOFs, MatrixFormat, BandwidthOptimize, eq(1:LEN_TRIM(eq)), &
               ListGetLogical( Solver % Values, &
               'Discontinuous Galerkin', Found ), GlobalBubbles=GlobalBubbles )

          Nrows = DOFs * Ndeg
          IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows

          IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
            ALLOCATE( Solution( Nrows ) )
            Solution = 0.0d0

            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                        var_name(1:n), DOFs, Solution, Perm, Output=VariableOutput )

            Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )

            IF ( DOFs > 1 ) THEN
              DO i=1,DOFs
                tmpname = ComponentName( var_name(1:n), i )
                Component => Solution( i:Nrows-DOFs+i:DOFs )
                CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                      tmpname, 1, Component, Perm, Output=VariableOutput )
              END DO
            END IF
          END IF
        ELSE
          ALLOCATE( Solver % Variable )
          Solver % Variable % Name = ''
          Solver % Variable % NameLen = 0
          Solver % Variable % Norm = 0.0d0
          NULLIFY( Solver % Variable % Values )
        END IF
      ELSE
        ALLOCATE( Solver % Variable )
        Solver % Variable % Norm = 0.0d0
        Solver % Variable % Name = ''
        Solver % Variable % NameLen = 0
        NULLIFY( Solver % Variable % Values )
      END IF
      !------------------------------------------------------------------------------
    END SELECT


    l = 1
    DO WHILE( .TRUE. )
      str = ComponentName( 'exported variable', l )
      var_name = ListGetString( Solver % Values, str, Found )

      IF ( Found ) THEN
        str = TRIM( ComponentName( 'exported variable', l ) ) // ' Output'
        VariableOutput = ListGetLogical( Solver % Values, str, Found )
        IF ( .NOT. Found ) VariableOutput = .TRUE.

        str = TRIM( ComponentName( 'exported variable', l ) ) // ' DOFs'
        DOFs = ListGetInteger( Solver % Values, str, Found )
        IF ( .NOT. Found ) THEN
          j = 0
          DOFs = 0
          DO WHILE( .TRUE. )
            i = INDEX( var_name(j+1:), ':' ) + j
            IF ( i<=j ) EXIT
            READ( var_name(i+1:),'(i1)' ) k
            DOFs = DOFs + k
            j = i + 1
          END DO
        END IF

        VariableOutput = .TRUE.
        DO WHILE( var_name(1:1) == '-' )
          IF ( var_name(1:10) == '-nooutput ' ) THEN
            VariableOutput = .FALSE.
            var_name(1:LEN(var_name)-10) = var_name(11:)
          END IF

          IF ( var_name(1:6) == '-dofs ' ) THEN
            READ( var_name(7:), * ) DOFs 
            j = LEN_TRIM( var_name )
            k = 7
            DO WHILE( var_name(k:k) /= ' '  )
              k = k + 1
              IF ( k > j ) EXIT
            END DO
            var_name(1:LEN(var_name)-(k+2)) = var_name(k+1:)
          END IF
        END DO
        IF ( DOFs == 0 ) DOFs = 1

        NewVariable => VariableGet( Solver % Mesh % Variables, Var_name )

        IF ( .NOT. ASSOCIATED(NewVariable) ) THEN
          nSize = Nrows * DOFs / Solver % Variable % DOFs
          ALLOCATE( Solution(nSize) )
          Solution = 0.0d0
          Perm => Solver % Variable % Perm

          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
           var_name, DOFs, Solution, Solver % Variable % Perm,Output=VariableOutput )

          IF ( DOFs > 1 ) THEN
            n = LEN_TRIM( var_name )
            DO j=1,DOFs
              tmpname = ComponentName( var_name(1:n), j )
              Component => Solution( j:nSize-DOFs+j:DOFs )
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component, Perm, Output=VariableOutput )
            END DO
          END IF
        END IF
      ELSE
        EXIT
      END IF
      l = l + 1
    END DO

    IF ( ListGetLogical( Solver % Values,'Calculate Loads', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Loads'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        ALLOCATE( Solution(nRows) )
        DOFs = Solver % Variable % DOFs
        Solution = 0.0d0
        Perm => Solver % Variable % Perm

        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
           var_name, Solver % Variable % DOFs, Solution, &
              Solver % Variable % Perm, Output=VariableOutput )

        IF ( DOFs > 1 ) THEN
          n = LEN_TRIM( Var_name )
          DO j=1,DOFs
            tmpname = ComponentName( var_name(1:n), j )
            Component => Solution( j:nRows-DOFs+j:DOFs )
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                tmpname, 1, Component, Perm, Output=VariableOutput )
          END DO
        END IF
      END IF
    END IF

    !------------------------------------------------------------------------------
    ! Add computation of the weights resulting from Galerkin integration

    IF ( ListGetLogical( Solver % Values,'Calculate Weights', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Weights'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        Perm => Solver % Variable % Perm
        ALLOCATE( Solution(SIZE(Solver % Variable % Perm)) )
        Solution = 0.0d0

        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
           var_name, 1, Solution, &
           Solver % Variable % Perm, Output=VariableOutput )
      END IF
    END IF
    !------------------------------------------------------------------------------


    Solver % NOFEigenValues = 0
    !   NULLIFY( Solver % Variable % PrevValues )
    !   NULLIFY( Solver % Variable % EigenValues )
    !   NULLIFY( Solver % Variable % EigenVectors )

    Solver % DoneTime  = 0
    Solver % MultiGridLevel = 1
    Solver % MultiGridTotal = 0
    Solver % MultiGridSolver = .FALSE.
    Solver % MultiGridEqualSplit = .FALSE.
    !------------------------------------------------------------------------------
    !
    ! Check for special solvers, to be executed only
    ! at a certain points in simulation:
    ! ----------------------------------------------

    Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS

    SELECT CASE( ListGetString( Solver % Values, 'Exec Solver', Found )  )
      CASE( 'never' )
      Solver % SolverExecWhen = SOLVER_EXEC_NEVER
      CASE( 'always' )
      Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
      CASE( 'after simulation', 'after all' )
      Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
      CASE( 'before simulation', 'before all' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
      CASE( 'before timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
      CASE( 'after timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
      CASE( 'before saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
      CASE( 'after saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
      CASE DEFAULT
         Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
    END SELECT


    IF ( ListGetLogical( Solver % Values, 'Before All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'After Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
    ELSE IF ( ListGetLogical( Solver % Values, 'After Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
    END IF

    Solver % LinAfterProc  = 0
    Solver % LinBeforeProc = 0
    str = ListGetString( Solver  % Values, 'Before Linsolve', Found )
    IF ( Found ) Solver % LinBeforeProc = GetProcAddr( str )

    str = ListGetString( Solver  % Values, 'After Linsolve', Found )
    IF ( Found ) Solver % LinAfterProc = GetProcAddr( str )

!------------------------------------------------------------------------------
    IF ( .NOT. ASSOCIATED( Solver % Variable % Values ) ) RETURN
!------------------------------------------------------------------------------

    HarmonicAnal = ListGetLogical( Solver % Values, 'Harmonic Analysis', Found )

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
       ALLOCATE( Solver % Matrix % RHS(Solver % Matrix % NumberOFRows) )
       Solver % Matrix % RHS = 0.0d0

       Solver % Matrix % RHS_im => NULL()
       IF ( HarmonicAnal ) THEN
         ALLOCATE( Solver % Matrix % RHS_im(Solver % Matrix % NumberOFRows) )
         Solver % Matrix % RHS_im = 0.0d0
       END IF
    END IF
!------------------------------------------------------------------------------

    EigAnal = ListGetLogical( Solver % Values, 'Eigen Analysis', Found )

    IF ( Transient .AND. .NOT. EigAnal .AND. .NOT. HarmonicAnal ) THEN
       k = ListGetInteger( Solver % Values, 'Time Derivative Order', Found, &
                  minv=0, maxv=2 )
       Solver % TimeOrder = 1
       IF ( Found ) Solver % TimeOrder = MIN(MAX(1,k),2)

       IF ( ASSOCIATED( Solver % Matrix ) ) THEN
          ALLOCATE( Solver % Matrix % Force(Solver % Matrix % NumberOFRows, &
                          Solver % TimeOrder+1) )
          Solver % Matrix % Force = 0.0d0
       END IF

       IF ( .NOT. ASSOCIATED( Solver % Variable % PrevValues ) ) THEN
          IF ( Solver % TimeOrder == 2 ) THEN
             ALLOCATE( Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values),5) )
          ELSE IF ( Solver % Order > Solver % TimeOrder ) THEN
             ALLOCATE(Solver % Variable % PrevValues( &
                   SIZE(Solver % Variable % Values), Solver % Order))
          ELSE
             ALLOCATE(Solver % Variable % PrevValues( &
                   SIZE(Solver % Variable % Values), Solver % TimeOrder))
          END IF
          Solver % Variable % PrevValues = 0.0d0

          IF ( Solver % Variable % DOFs > 1 ) THEN
             IF ( Solver % Variable % Name == 'flow solution' ) THEN
               DO k=1,Solver % Variable % DOFs-1
                  str = 'Velocity ' // CHAR(k+ICHAR('0'))
                  Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                  Var % PrevValues =>  &
                      Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
               END DO
               Var => VariableGet( Solver % Mesh % Variables, 'Pressure', .TRUE. )
               Var % PrevValues =>  &
                     Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
             ELSE
               DO k=1,Solver % Variable % DOFs
                  str = ComponentName( Solver % Variable % Name, k )
                  Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                  Var % PrevValues =>  &
                      Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
               END DO
             END IF
          END IF
       END IF
    ELSE
       Solver % TimeOrder = 0
       IF ( EigAnal ) THEN
          ComplexFlag = ListGetLogical( Solver % Values,  'Eigen System Complex', Found )
          IF ( .NOT. Found ) ComplexFlag = .FALSE.

          n = ListGetInteger( Solver % Values,  'Eigen System Values', Found )
          IF ( Found .AND. n > 0 ) THEN
             Solver % NOFEigenValues = n
             IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
               ALLOCATE( Solver % Variable % EigenValues(n) )
               ALLOCATE( Solver % Variable % EigenVectors(n, &
                    SIZE( Solver % Variable % Values ) ) )

               Solver % Variable % EigenValues  = 0.0d0
               Solver % Variable % EigenVectors = 0.0d0

               DO k=1,Solver % Variable % DOFs
                 str = ComponentName( Solver % Variable % Name, k )
                 Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                 IF ( ASSOCIATED( Var ) ) THEN
                    Var % EigenValues => Solver % Variable % EigenValues
                    IF ( ComplexFlag ) THEN
                       Var % EigenVectors => Solver % Variable % EigenVectors
                    ELSE
                       Var % EigenVectors =>  & 
                          Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs )
                    END IF
                 END IF
               END DO
             END IF
             ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
             Solver % Matrix % MassValues = 0.0d0
          END IF
       ELSE IF ( HarmonicAnal ) THEN
          freqv => ListGetConstRealArray( Solver % Values, 'Frequency', Found )
          IF ( Found ) THEN
             n = SIZE(Freqv,1)
             Solver % NOFEigenValues = n
             IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
               ALLOCATE( Solver % Variable % EigenValues(n) )
               ALLOCATE( Solver % Variable % EigenVectors(n, &
                    SIZE( Solver % Variable % Values ) ) )

               Solver % Variable % EigenValues  = 0.0d0
               Solver % Variable % EigenVectors = 0.0d0

               DO k=1,Solver % Variable % DOFs
                 str = ComponentName( Solver % Variable % Name, k )
                 Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                 IF ( ASSOCIATED( Var ) ) THEN
                    Var % EigenValues => Solver % Variable % EigenValues
                    Var % EigenVectors => Solver % Variable % EigenVectors
                 END IF
               END DO
             END IF
             ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
             Solver % Matrix % MassValues = 0.0d0
          ELSE
             CALL Fatal( 'AddEquation', 'Frequency must be given for harmonic analysis.' )
          END IF
       END IF
    END IF

!------------------------------------------------------------------------------

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
       Solver % Matrix % Symmetric = ListGetLogical( Solver % Values, &
                  'Linear System Symmetric', Found )

       Solver % Matrix % Lumped = ListGetLogical( Solver % Values, &
                  'Lumped Mass Matrix', Found )

       MultigridActive = &
         ListGetString( Solver % Values, 'Linear System Solver', Found ) == 'multigrid' .OR. &
         ListGetString( Solver % Values, 'Linear System Preconditioning', Found ) == 'multigrid'


!      Check for multigrid solver:
!      ---------------------------
       IF ( MultigridActive ) THEN

          str = ListGetString( Solver % Values,'MG Method',Found) 
          IF( Found ) THEN
            MGAlgebraic = ( str == 'algebraic' ) .OR. ( str == 'cluster')
          ELSE	    
            MGAlgebraic = ListGetLogical( Solver % Values, 'MG Algebraic', Found ) &
	       .OR. ListGetLogical( Solver % Values, 'MG Cluster', Found )
          END IF

          Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
                        'MG Levels', Found, minv=1 )

          IF ( .NOT. Found ) THEN
             Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
                     'Multigrid Levels', Found, minv=1 )
          END IF
          IF ( .NOT. Found ) THEN
	    IF( MGAlgebraic ) THEN 
	      Solver % MultiGridTotal = 10
            ELSE
	      Solver % MultiGridTotal = 3	    
	    END IF
          END IF

!         Check if h/2 splitting of mesh requested:
!         ------------------------------------------
          Solver % MultiGridEqualSplit = ListGetLogical( &
             Solver % Values, 'MG Equal Split', Found )

          IF ( Solver % MultiGridEqualSplit ) THEN
             CALL ParallelInitMatrix( Solver, Solver % Matrix )
             Solver % MultiGridLevel = 1
             DO WHILE( Solver % MultiGridLevel < Solver % MultiGridTotal )
                IF ( ASSOCIATED( Solver % Mesh % Child ) ) THEN
                   NewMesh => Solver % Mesh % Child

                   OldMesh   => Solver % Mesh
                   OldMatrix => Solver % Matrix

                   CALL UpdateSolverMesh( Solver, NewMesh )
                   Solver % Mesh % Changed = .FALSE.
                ELSE
                   NewMesh => SplitMeshEqual( Solver % Mesh )
                   NewMesh % Next => CurrentModel % Meshes
                   CurrentModel % Meshes => NewMesh

                   OldMesh   => Solver % Mesh
                   OldMatrix => Solver % Matrix

                   CALL UpdateSolverMesh( Solver, NewMesh )
                   Solver % Mesh % Changed = .FALSE.

                   NewMesh % Parent => OldMesh
                   OldMesh % Child  => NewMesh
                   NewMesh % Name = OldMesh % Name
                END IF

                NewMatrix => Solver % Matrix
                NewMatrix % Parent => OldMatrix
                OldMatrix % Child  => NewMatrix
                CALL ParallelInitMatrix( Solver, Solver % Matrix )
                Solver % MultiGridLevel = Solver % MultiGridLevel + 1
             END DO
          END IF
          CALL MeshStabParams( Solver % Mesh )
          Solver % MultiGridSolver = ListGetString(Solver % Values, &
             'Linear System Solver', Found ) == 'multigrid'
          Solver % MultiGridLevel  = Solver % MultiGridTotal
       END IF
    END IF
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE AddEquation
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolveEquations( Model, dt, TransientSimulation, &
      CoupledMinIter, CoupledMaxIter, SteadyStateReached )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    INTEGER :: CoupledMinIter, CoupledMaxIter
    LOGICAL :: TransientSimulation, SteadyStateReached
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: RelativeChange, Tolerance, PrevDT = 0.0d0, Relaxation
    INTEGER :: i,j,k,n,ierr,istat
    LOGICAL :: Found, Stat, AbsNorm, Convergence, RungeKutta, MeActive, Relax, NeedSol
    LOGICAL, ALLOCATABLE :: DoneThis(:)
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Mesh_t),   POINTER :: Mesh
    CHARACTER(LEN=max_name_len) :: When
    TYPE(Variable_t), POINTER :: IterV
    REAL(KIND=dp), POINTER :: steadyIt,nonlnIt
    REAL(KIND=dp), ALLOCATABLE :: k1(:), k2(:), k3(:), k4(:), Values0(:)
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!   Intialize equation solvers for new timestep
!------------------------------------------------------------------------------
    IF ( TransientSimulation ) THEN
       DO k=1,Model % NumberOfSolvers
          Solver => Model % Solvers(k)
          IF ( Solver % PROCEDURE /= 0 ) CALL InitializeTimestep( Solver )
       END DO

       IterV => VariableGet(Model % Solvers(1) % Mesh % Variables, 'coupled iter')
       steadyIt => IterV % Values(1)
    END IF
!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      when  = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF ( Found ) THEN
         IF ( When == 'before timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AHEAD_TIME ) THEN
            CALL SolverActivate( Model,Solver,dt,TransientSimulation )
            CALL ParallelBarrier
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------

    ALLOCATE( DoneThis( Model % NumberOfSolvers ) )

    IF ( PrevDT == 0.0d0 ) PrevDT = dt
!------------------------------------------------------------------------------
    DO i=1,CoupledMaxIter
       IF ( TransientSimulation ) THEN
          CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Info( 'SolveEquations', Message, Level=3 )
          CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )

          steadyIt = i
       END IF

       DoneThis = .FALSE.

!      Initialize the mesh output flag to FALSE here, reactivated
!      later for meshes connected to active solvers.
!      ----------------------------------------------------------
       Mesh => Model % Meshes
       DO WHILE( ASSOCIATED( Mesh ) )
          Mesh % OutputActive = .FALSE.
          Mesh => Mesh % Next
       END DO
!------------------------------------------------------------------------------
!      Go trough number of solvers (heat,laminar or turbulent flow, etc...)
!------------------------------------------------------------------------------
       DO k=1,Model % NumberOfSolvers
!------------------------------------------------------------------------------

          Solver => Model % Solvers(k)
          IF ( Solver % PROCEDURE == 0 ) THEN

!!!!!!!!!!!! This is still experimental
             IF( ListGetLogical(Solver % Values,'Generic Solver',Found) ) THEN 
                CALL GenericSolver( Model, Solver, dt, TransientSimulation )
             END IF

             DoneThis(k) = .TRUE.
             CYCLE
          END IF

          When = ListGetString( Solver % Values, 'Exec Solver', Found )
          IF ( Found ) THEN
             IF ( When /= 'always' ) THEN
                DoneThis(k) = .TRUE.
                CYCLE
             END IF
          ELSE
            IF ( Solver % SolverExecWhen /= SOLVER_EXEC_ALWAYS ) THEN
               DoneThis(k) = .TRUE.
               CYCLE
            END IF
          END IF
!------------------------------------------------------------------------------

          RungeKutta = .FALSE.
          IF ( TransientSimulation .AND. Solver % TimeOrder == 1 ) THEN
             RungeKutta = ListGetString( Solver % Values, &
                    'Timestepping Method', Found ) == 'runge-kutta'
          END IF

          n = 0
          IF ( ASSOCIATED(Solver % Variable) ) THEN
            IF ( ASSOCIATED(Solver % Variable % Values) ) &
              n = SIZE(Solver % Variable % Values)
            Solver % Variable % PrevNorm = Solver % Variable % Norm
          END IF

!------------------------------------------------------------------------------
          Relaxation = ListGetConstReal( Solver % Values, &
              'Steady State Relaxation Factor', Relax )
          Relax = Relax .AND. (Relaxation /= 1.0d0)

          NeedSol = ( ListGetString( Solver % Values, &
              'Steady State Convergence Measure', Stat ) /= 'norm')  
          NeedSol = NeedSol .AND. Stat

          IF ( ( Relax .OR. NeedSol ) .AND. n>0 ) THEN
            Stat = ASSOCIATED(Solver % Variable % SteadyValues)
            IF(Stat .AND. SIZE(Solver % Variable % SteadyValues) /= n) THEN
              DEALLOCATE(Solver % Variable % SteadyValues)
              Stat = .FALSE.
            END IF
            IF(.NOT. Stat) THEN
              ALLOCATE( Solver % Variable % SteadyValues(n), STAT=istat ) 
              IF ( istat /= 0 ) CALL Fatal( 'SolveEquations', 'Memory allocation error.' )
            END IF
            Solver % Variable % SteadyValues(1:n) = Solver % Variable % Values(1:n)
          END IF


          IF ( RungeKutta .AND. n>0 ) THEN

            SELECT CASE( Solver % Order )
            CASE(2)
              ALLOCATE( k1(n), k2(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k2 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                  ( k1 + k2 ) / 2
              DEALLOCATE( k1, k2 )


            CASE DEFAULT
              ALLOCATE( k1(n), k2(n), k3(n), k4(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1/2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k2 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k3 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k3
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k4 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                ( k1 + 2*k2 + 2*k3 + k4 ) / 6
              DEALLOCATE( k1, k2, k3, k4 )
            END SELECT
             Solver % Variable % Norm = ComputeNorm(Solver, n, Solver % Variable % Values)
           ELSE
             CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           END IF
!------------------------------------------------------------------------------
!         check for coupled system convergence
!------------------------------------------------------------------------------

          IF ( i >= CoupledMinIter .OR. .NOT. TransientSimulation ) THEN
             IF ( i /= CoupledMaxIter .OR. .NOT. TransientSimulation ) THEN

               CALL ComputeChange(Solver,.TRUE., n)
               RelativeChange = Solver % Variable % SteadyChange	
               Tolerance = ListGetConstReal( Solver % Values,   &
                   'Steady State Convergence Tolerance', Found ) 
               
               IF ( Found ) THEN
                 DoneThis(k) = (RelativeChange < Tolerance)
               ELSE
                 DoneThis(k) = .TRUE.
               END IF
             END IF
	  END IF 

          CALL ParallelAllReduceAnd( DoneThis(k) )
          IF( ALL(DoneThis) ) EXIT
!------------------------------------------------------------------------------
       END DO
!------------------------------------------------------------------------------
       Model % Mesh % Changed = .FALSE.
       IF ( ALL(DoneThis) ) EXIT
    END DO
    PrevDT = dt

    IF ( TransientSimulation .AND. .NOT. ALL(DoneThis) ) THEN
       IF ( ListGetLogical( Model % Simulation,  &
               'Coupled System Abort Not Converged', Found ) ) THEN
          CALL Error( 'SolveEquations', ' ' )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Error( 'SolveEquations', Message )
          CALL Fatal( 'SolveEquations', ' ' )
       ELSE
!         CALL Error( 'SolveEquations', ' ' )
!         WRITE( Message, * ) 'Coupled system iteration: ', i
!         CALL Error( 'SolveEquations', Message )
!         CALL Error( 'SolveEquations', ' ' )
       END IF
    END IF

!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      When = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF (  Found ) THEN
         IF ( When == 'after timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AFTER_TIME ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------
    IF ( .NOT.TransientSimulation ) SteadyStateReached = ALL(DoneThis)
!------------------------------------------------------------------------------
    DEALLOCATE( DoneThis )
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE SolveEquations
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE GenericSolver( Model, Solver, dt, Transient )
!------------------------------------------------------------------------------
!  
! Provide assembly loop and solution of linear and nonlinear systems
    
    USE DefUtils
    USE Types
    USE Lists
    USE Integration
    USE ElementDescription
    USE SolverUtils
    USE ElementUtils
    
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Solver_t), TARGET :: Solver
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    LOGICAL :: Transient
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t),POINTER :: Element
    INTEGER :: i,j,k,l,t,n,nd,NoIterations,iter,istat
    REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), DAMP(:,:), MASS(:,:), FORCE(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: ProcName
    LOGICAL :: GotIt, GotIt2, GotProc, BulkMode, Visited = .FALSE.
    INTEGER(KIND=AddrInt) :: ProcPntr    
    INTEGER :: Row, Col, ColDofs, RowDofs, ColInd0, RowInd0, MaxDofs, &
         ColVar, RowVar, Nrow, Ncol, NoVar, NoCons, TotSize, ConDofs, OffSet(20)
    INTEGER :: ElementsFirst, ElementsLast, body_id
    INTEGER, POINTER :: ColPerm(:), RowPerm(:), ColInds(:), RowInds(:), DirPerm(:)
    REAL(KIND=dp), POINTER :: Constraints(:)
    REAL(KIND=dp) :: NonlinearTol, Norm, ConsValue, ConsVolume
    CHARACTER(LEN=max_name_len) :: str, VarName, ColName, RowName, ConsTarget, ConsType
    LOGICAL :: Coupling, Equality
    INTEGER, POINTER :: Rows(:),Cols(:),Diag(:),Indexes(:),AllPerm(:)
    TYPE(ListMatrix_t), POINTER :: Alist(:) => NULL()
    REAL(KIND=dp), POINTER :: ForceVector(:),AllValues(:)
    LOGICAL, POINTER :: AllDir(:)
    TYPE (Matrix_t), POINTER :: Amat

    INTERFACE 
      SUBROUTINE ExecLocalAssembly( Proc, Model, Solver, dt, Transient, &
          M, D, S, F, Element, Nrow, Ncol )
        USE Types
        INTEGER(KIND=AddrInt) :: Proc
        TYPE(Model_t)   :: Model
        TYPE(Solver_t)  :: Solver
        REAL(KIND=dp)   :: dt
        LOGICAL :: Transient
        REAL(KIND=dp) :: S(:,:), D(:,:), M(:,:), F(:)
        TYPE(Element_t) :: Element
        INTEGER :: Nrow, Ncol
      END SUBROUTINE ExecLocalAssembly
    END INTERFACE
    
    SAVE Visited 
    
    CALL Info('GenericSolver','---------------------------------------',Level=5)
    CALL Info('GenericSolver','Solving a Generic equation',Level=5)
    CALL Info('GenericSolver','---------------------------------------',Level=5)


!!!!!!!!!! This should be done externally when routine is taken into proper use

    Model % Solver => Solver

!------------------------------------------------------------------------------
! Check out which variables the coupled model includes
! and compure size information related to the new coupled dof.
!------------------------------------------------------------------------------

!!!!!!!!!!!!! Currently the list of active variables and their permutation vectors must be
!!!!!!!!!!!!! provided using other solvers for initiazalition. This could be allocated 
!!!!!!!!!!!!! internally using the Variable = AllDofs[VectorDof:3 ScalarDof:1] system
    Offset = 0
    MaxDofs = 0
    TotSize = 0
    
    NoVar = 0
    DO i = 1,9
      WRITE (str,'(A,I2)') 'Variable',i
      VarName = ListGetString( Solver % Values, TRIM(str), GotIt )
      IF(.NOT. GotIt) EXIT
      Var => VariableGet( Model % Variables, TRIM(VarName) )
      IF(.NOT. ASSOCIATED( Var )) EXIT 
      
      NoVar = NoVar + 1
      TotSize = TotSize + Var % Dofs * SIZE(Var % Values)
      MaxDofs = MAX( MaxDofs, Var % Dofs)
      Offset(NoVar+1) = Offset(NoVar) + Var % Dofs * SIZE(Var % Values)

      WRITE(Message,'(A,I2,A,I8)') 'Variable offset',NoVar,': ',OffSet(NoVar)
      CALL Info('GenericSolver',Message)
    END DO

!!!!!!!!!!!!! Here is a hack for taking constraints into account where dofs are created on-the-fly
!!!!!!!!!!!!! might be better to create special solvers somewhere else
!!!!!!!!!!!!! also the size of constraint might be directly deduced from its type.

    NoCons = 0
    DO i = 1,9
      WRITE (str,'(A,I2)') 'Constraint',i
      VarName = ListGetString( Solver % Values, TRIM(str), GotIt )
      IF(.NOT. GotIt) EXIT
      
      NoCons = NoCons + 1      
      Var => VariableGet( Model % Variables, VarName )
      IF( ASSOCIATED(Var) ) THEN
        ConDofs = Var % Dofs
        Constraints => Var % Values
      ELSE
        WRITE (str,'(A,I2,A)') 'Constraint',i,' DOFs'
        ConDofs = ListGetInteger( Solver % Values, str)
        IF( ConDofs > 0 ) THEN
          ALLOCATE(Constraints(ConDofs))
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              VarName, ConDofs, Constraints, Output = .FALSE. )          
          Var => VariableGet( Model % Variables, VarName )         
        END IF
      END IF
      
      TotSize = TotSize + ConDofs
      j = NoVar + NoCons 
      Offset(j+1) = Offset(j) + ConDofs

      WRITE(Message,'(A,I2,A,I8)') 'Permutation offset',j,': ',OffSet(j)
      CALL Info('GenericSolver',Message)
    END DO

    WRITE(Message,'(A,I8)') 'Number of coupled variables: ',NoVar
    CALL Info('GenericSolver',Message)
  
    WRITE(Message,'(A,I8)') 'Number of constraints: ',NoCons
    CALL Info('GenericSolver',Message)
  
    WRITE(Message,'(A,I8)') 'Size of coupled system: ',TotSize
    CALL Info('GenericSolver',Message)

!------------------------------------------------------------------------------
! Do some initial stuff
!------------------------------------------------------------------------------
  
    N = Solver % Mesh % MaxElementNodes    
    ALLOCATE( FORCE( MaxDofs*N ),       &
        STIFF( MaxDofs*N, MaxDofs*N ), &
        DAMP( MaxDofs*N, MaxDofs*N ),  &
        MASS(  MaxDofs*N, MaxDofs*N ), &
        ColInds( N ), RowInds( N ), &
        STAT=istat )
    IF ( istat /= 0 ) CALL FATAL('GenericSolver','Memory allocation error')
    
    NoIterations = GetInteger( Solver % Values,'Nonlinear System Max Iterations',GotIt)
    IF(.NOT. GotIt) NoIterations = 1
    NonlinearTol = GetCReal( Solver % Values,'Nonlinear System Convergence Tolerance',gotIt)
    
    IF(.NOT. Visited ) THEN
      Amat => AllocateMatrix()
      Amat % ListMatrix => Alist
      Amat % FORMAT = MATRIX_LIST      
      Solver % Matrix => Amat

      ALLOCATE(AllPerm(TotSize),AllValues(TotSize),ForceVector(TotSize))
      DO i=1,TotSize
        AllPerm(i) = i
        AllValues(i) = 0.0_dp
      END DO
      CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
          'AllDofs',1,AllValues,AllPerm,Output=.FALSE.)
      CALL Info('GenericSolver','New coupled variable added', Level=5)

      Solver % Matrix % Rhs => ForceVector
      Solver % Variable => VariableGet(Model % Variables, 'Alldofs')

      ALLOCATE( AllDir(TotSize) ) 
      AllDir = .FALSE.
      Visited = .TRUE.
    END IF


!------------------------------------------------------------------------------
! Iterate over any nonlinearity of material or source
!------------------------------------------------------------------------------
  
    CALL Info('GenericSolver','-------------------------------------------------',Level=5)
    
    
    DO iter = 1,NoIterations
      
      WRITE(Message,'(A,T35,I5)') 'Generic iteration:',iter
      CALL Info('GenericSolver',Message,Level=5)
      
      IF( Solver % Matrix % FORMAT == MATRIX_CRS ) THEN
        CALL DefaultInitialize()
      END IF
      AllDir = .FALSE.
      
      ! Start of assemly process
      !------------------------------------------
      BulkMode = .TRUE.
100   IF(BulkMode) THEN
        CALL Info('GenericSolver','Starting bulk assembly',Level=5)
        ElementsFirst = 1
        ElementsLast = Solver % Mesh % NumberOfBulkElements 
      ELSE
        CALL Info('GenericSolver','Starting boundary assembly',Level=5)
        ElementsFirst = Solver % Mesh % NumberOfBulkElements + 1
        ElementsLast = Solver % Mesh % NumberOfBulkElements + &
            Solver % Mesh % NumberOfBoundaryElements
      END IF
      
      ! Variables over rows
      !-------------------------------------------
      DO RowVar = 1,NoVar + NoCons        
        IF( RowVar <= NoVar ) THEN
          WRITE (str,'(A,I2)') 'Variable',RowVar
        ELSE
          WRITE (str,'(A,I2)') 'Constraint',RowVar-NoVar
          ConsVolume = 0.0_dp
        END IF
        RowName = ListGetString( Solver % Values, TRIM(str), GotIt )
        Var => VariableGet( Model % Variables, TRIM(RowName) )
        
        IF( RowVar <= NoVar ) THEN
          RowPerm => Var % Perm
        ELSE         
          Nrow = 1
          RowInds(1:Nrow) = 1
          WRITE (str,'(A,I2,A)') 'Constraint',RowVar-NoVar,' Target'
          ConsTarget = ListGetString( Solver % Values, TRIM(str) )
          
          WRITE (str,'(A,I2,A)') 'Constraint',RowVar-NoVar,' Value'
          ConsValue = GetCReal(Solver % Values,TRIM(str))
          
          WRITE (str,'(A,I2,A)') 'Constraint',RowVar-NoVar,' Type'
          ConsType = ListGetString(Solver % Values,TRIM(str))
        END IF
        RowDofs = Var % Dofs
        RowInd0 = Offset(RowVar)
        
        ! Variables over columns
        !------------------------------------------
        DO ColVar = 1,NoVar          
          WRITE (str,'(A,I2)') 'Variable',ColVar
          ColName = ListGetString( Solver % Values, TRIM(str), GotIt )
          Var => VariableGet( Model % Variables, TRIM(ColName) )
          
          ! Constrain only the target variable
          !-----------------------------------------------
          IF(RowVar > NoVar) THEN
            IF( ColName /= ConsTarget ) CYCLE
          END IF
          
          ColPerm => Var % Perm
          ColDofs = Var % Dofs
          ColInd0 = Offset(ColVar)
          
          ! Load the assembly procudure
          ! If not found check for constraints
          !-----------------------------------------
          IF( BulkMode ) THEN
            WRITE (str,'(A,I1,I1)') 'Bulk Assembly Procedure ',RowVar,ColVar
          ELSE
            WRITE (str,'(A,I1,I1)') 'Boundary Assembly Procedure ',RowVar,ColVar
          END IF
          
          ProcName = ListGetString( Solver % Values, TRIM(str), GotProc )
          Equality = .FALSE.
          IF(.NOT. GotProc ) THEN
            IF( RowVar > NoVar) THEN
              CALL Info('GenericSolver','Using built-in constraint')
            ELSE
              IF( BulkMode .AND. RowVar == ColVar ) THEN
                CALL Fatal('GenericSolver','Diagonal bulk entries must be assembled!')
              ELSE
                WRITE (str,'(A,I1,I1)') 'Equality ',RowVar,ColVar
                Equality = ListGetLogical( Solver % Values, TRIM(str), GotIt )
                IF( Equality ) THEN
                  CALL Info('GenericSolver','Testing for equality')               
                ELSE
                  CYCLE
                END IF
              END IF
            END IF
          END IF
          
          IF( GotProc ) THEN
            ProcPntr = GetProcAddr( TRIM(ProcName), abort=.FALSE.,quiet=.FALSE.)
            IF ( ProcPntr == 0 ) THEN
              CALL Fatal('GenericSolver','AssemblyRoutine not found: '//TRIM(ProcName))
            ELSE
              CALL Info('GenericSolver','AssemblyRoutine: '//TRIM(ProcName))
            END IF
          END IF

          
          ! The assembly loop for a submatrix starts here
          !------------------------------------------------------------------------------             
          DO t=ElementsFirst,ElementsLast

            Element => Solver % Mesh % Elements(t)
            Model % CurrentElement => Element
            
            n  = GetElementNOFNodes( Element )
            
!!!!!!!!!! How to treat non-nodal elements must be rethought 
!!!!!!!!!!           nd = GetElementNOFDOFs( Element, Solver )                  
            Indexes => Element % NodeIndexes
            
            ! Set the permutations unless for constraints
            !----------------------------------------------------
            IF( RowVar <= NoVar ) THEN
              Nrow = n
              RowInds(1:Nrow) = RowPerm( Indexes )
              IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE
            END IF
            
            Ncol = n
            ColInds(1:n) = ColPerm( Indexes )
            IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 
            
            ! For constrains check coupling to bodies and BCs
            !----------------------------------------------------             
            
            IF( RowVar > NoVar ) THEN
              Coupling = .FALSE.
              
              IF( BulkMode ) THEN
                ! Check coupling to bodies using Body/Equation section
                body_id = Element % BodyId               
                Coupling = GetLogical(Model % Bodies(body_id) % Values, &
                    RowName, gotIt)
              ELSE 
                DO i=1,Model % NumberOfBCs
                  IF ( Element % BoundaryInfo % Constraint == &
                      Model % BCs(i) % Tag ) THEN
                    Coupling = GetLogical(Model % BCs(i) % Values, &
                        RowName, gotIt)
                    IF( Coupling ) EXIT
                  END IF
                END DO
              END IF
              
              IF( .NOT. Coupling ) CYCLE
            END IF
            
            ! For Equality check couplings
            !----------------------------------------------------             
            IF( Equality ) THEN
              Coupling = .FALSE.
              WRITE (str,'(A,I1,I1)') 'Equality ',RowVar,ColVar
              
              IF( BulkMode ) THEN
                ! Check coupling to bodies using Body/Equation section
                body_id = Element % BodyId               
                Coupling = GetLogical(Model % Bodies(body_id) % Values, &
                    str, gotIt)
              ELSE 
                DO i=1,Model % NumberOfBCs
                  IF ( Element % BoundaryInfo % Constraint == &
                      Model % BCs(i) % Tag ) THEN
                    Coupling = GetLogical(Model % BCs(i) % Values, &
                        str, gotIt)
                    IF( Coupling ) EXIT
                  END IF
                END DO
              END IF
              
              IF( .NOT. Coupling ) CYCLE
              ! PRINT *,'we have equality',RowVar,ColVar,i
            END IF
   
! Do the assembly, now really
!---------------------------------------------------------------------------------------
            
            STIFF = 0.0_dp
            DAMP = 0.0_dp
            MASS = 0.0_dp
            FORCE = 0.0_dp
            
            IF( GotProc ) THEN
              CALL ExecLocalAssembly( ProcPntr, CurrentModel, Solver, &
                  dt, Transient, MASS, DAMP, STIFF, FORCE, Element, &
                  Nrow, Ncol )
              
            ELSE IF(Equality) THEN
!!!!!!!!! Works generally only for one-components cases
              
              DO i=1,Nrow
                DO k=0,RowDofs-1
                  Row  = RowInd0 + RowDofs * RowInds(i) - k
                  Col  = ColInd0 + ColDofs * ColInds(i) - k
                  
                  IF( AllDir(Row) ) CYCLE

                  PRINT *,'Row',Row,'Col',Col

                  AllDir(Row) = .TRUE.
                  CALL MoveRow( Amat, Row, Col ) 
                  
                  ForceVector(Col) = ForceVector(Col) + ForceVector(Row)
                  ForceVector(Row) = 0.0_dp
                  
                  CALL SetMatrixElement( Amat,Row,Row,1.0_dp )
                  CALL SetMatrixElement( Amat,Row,Col,-1.0_dp )
                END DO
              END DO
              CYCLE
            ELSE
              IF( TRIM(ConsType) == 'integral') THEN
                CALL IntegralConstraint( MASS, DAMP, STIFF, FORCE, Element, Ncol )
              ELSE
                CALL Warn('GenericSolver','Unknown constraint type: '//TRIM(str))
              END IF
            END IF
            
            IF ( Transient ) THEN
              IF( Solver % TimeOrder == 1 ) THEN
                CALL Default1stOrderTime( MASS,STIFF,FORCE)
              ELSE IF( Solver % TimeOrder == 2) THEN
                CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
              END IF
            END IF
            
            ! Assemble the matrix with offset
            !-----------------------------------------------
            CALL GlueLocalSubMatrix( Solver % Matrix,&
                RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
                RowDofs,ColDofs,STIFF )

            
            ! Assemble the r.h.s with offset
            !-----------------------------------------------
            DO i=1,Nrow
              DO j=1,RowDofs
                Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
                ForceVector(Row) = ForceVector(Row) + &
                    FORCE(RowDofs*(i-1)+j)
              END DO
            END DO
           
 
            ! For constraints assemble also the transpose
            !-----------------------------------------------
            IF( RowVar > NoVar ) THEN
              CALL GlueLocalSubMatrix( Solver % Matrix,&
                  ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                  ColDofs,RowDofs,TRANSPOSE(STIFF) )               
            END IF

          END DO
        END DO

        
        ! For constraints do some special setting
        !---------------------------------------------------
        IF( BulkMode .AND. RowVar > NoVar ) THEN

          ! Add the diagonal entry expected by some subroutines
          !-------------------------------------------------------          
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              CALL AddToMatrixElement( Solver % Matrix, Row, Row, 0.0_dp )
            END DO
          END DO

          ! Set the target for the constraint
          !--------------------------------------------------------
          PRINT *,'Constraint Volume: ',ConsVolume
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              ForceVector(Row) = ConsValue
            END DO
          END DO
        END IF
        
      END DO
      
      IF(BulkMode) THEN
        CALL Info( 'GenericSolver', 'Bulk assembly done', Level=4 )
        BulkMode = .FALSE.
        GOTO 100
      ELSE 
        CALL Info( 'GenericSolver', 'Boundary assembly done', Level=4 )
      END IF
      
      ! The CRS matrix may be created only when the matrix structure is known
      !----------------------------------------------------------------------
      IF( Solver % Matrix % FORMAT == MATRIX_LIST ) THEN
        CALL ListToCRSMatrix(Amat)
      END IF
      CALL DefaultFinishAssembly()
      
!------------------------------------------------------------------------------
!    Do the Dirichlet conditions using offset
!------------------------------------------------------------------------------          

      DO i = 1,NoVar
        WRITE (str,'(A,I2)') 'Variable',i
        VarName = ListGetString( Solver % Values, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        
        Var => VariableGet( Model % Variables, TRIM(VarName) )
        IF(.NOT. ASSOCIATED( Var )) EXIT 
        
        IF( Var % Dofs == 1) THEN
          CALL SetDirichletBoundaries( CurrentModel, Amat, ForceVector, &
              VarName, 1, 1, Var % Perm, OffSet(i) )       
        ELSE          
          DO j=1,Var % Dofs
            CALL SetDirichletBoundaries( CurrentModel, Amat, ForceVector, &
                ComponentName(VarName,j), j, Var % Dofs, Var % Perm, OffSet(i) )       
          END DO
        END IF
      END DO
      CALL Info( 'GenericSolver', 'Dirichlet conditions done', Level=4 )
      
!------------------------------------------------------------------------------
!   Finally solve the system
!------------------------------------------------------------------------------          
   
      Norm = DefaultSolve()     
      CALL Info('GenericSolver','-------------------------------------------------',Level=5)
      
      IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
    END DO
    
!------------------------------------------------------------------------------          
! Map the result back to the original vectors
!----------------------------------------------------------------------------------
    CALL Info('GenericSolver','Copying results into original variables',Level=5)
     DO i = 1,NoVar + NoCons
      IF( i <= NoVar ) THEN
        WRITE (str,'(A,I2)') 'Variable',i
      ELSE
        WRITE (str,'(A,I2)') 'Constraint',i-NoVar        
      END IF
      VarName = ListGetString( Solver % Values, TRIM(str), GotIt )
      Var => VariableGet( Model % Variables, TRIM(VarName) )

      IF( i > NoVar ) THEN
         PRINT *,TRIM(str),': ',Var % Values       
      END IF
     
      CALL Info('GenericSolver','Variable: '//TRIM(VarName),Level=5)
      DO j=1,SIZE(Var % Values)
        Var % Values(j) = Solver % Variable % Values(Offset(i)+j)
      END DO
    END DO
    

    DEALLOCATE( FORCE, STIFF, DAMP, MASS, ColInds, RowInds )
    Visited = .TRUE.

    CALL Info('GenericSolver','All done')
    CALL Info('GenericSolver','-------------------------------------------------',Level=5)


  CONTAINS 


    SUBROUTINE IntegralConstraint( Mass, Damp, Stiff, Force, Element, n )
!------------------------------------------------------------------------------
      
      IMPLICIT NONE
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: Stiff(:,:), Damp(:,:), Mass(:,:), Force(:)
      TYPE(Element_t), POINTER :: Element
      INTEGER :: n
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------

      TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
      TYPE(Nodes_t) :: Nodes
      REAL(KIND=dp) :: Basis(n)
      REAL(KIND=dp) :: Weight, DetJ
      INTEGER :: i,j,t,p,q
      LOGICAL :: Visited = .FALSE., Found
      
      SAVE Visited, Nodes
      
      IF( .NOT. Visited ) THEN
        ALLOCATE( Nodes % x(n), Nodes % y(n), Nodes % z(n) )     
        CALL info('IntegralConstraint','1st time')
      END IF
      
      CALL GetElementNodes( Nodes ) 
      IntegStuff = GaussPoints( Element )
      
      DO t=1,IntegStuff % n
        Found = ElementInfo( Element, Nodes, IntegStuff % u(t), &
            IntegStuff % v(t), IntegStuff % w(t), detJ, Basis )     
        Weight = IntegStuff % s(t) * detJ
        DO p=1,n
          STIFF(1,p) = STIFF(1,p) + Weight * Basis(p)
          FORCE(p) = FORCE(p) + ConsValue * Weight * Basis(p)
        END DO

        ConsVolume = ConsVolume + Weight 
      END DO

      Visited = .TRUE.

!------------------------------------------------------------------------------
    END SUBROUTINE IntegralConstraint
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
END SUBROUTINE GenericSolver
!------------------------------------------------------------------------------
 


!------------------------------------------------------------------------------
  SUBROUTINE SolverActivate( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation
     REAL(KIND=dp) :: dt, OrigDT, DTScal
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, GB, FirstTime=.TRUE., MeActive
     INTEGER :: i, j, SolverAddr, BDOFs, execi, timestep, maxdim
     REAL(KIND=dp) :: st
     TYPE(Variable_t), POINTER :: TimeVar, IterV
     TYPE(Element_t), POINTER :: CurrentElement
     CHARACTER(LEN=MAX_NAME_LEN) :: EquationName, str
     SAVE TimeVar, FirstTime
!------------------------------------------------------------------------------
     CALL SetCurrentMesh( Model, Solver % Mesh )
     Model % Solver => Solver

     st = ListGetConstReal( Solver % Values, 'Start Time', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Time' )
       IF ( TimeVar % Values(1) < st ) RETURN
     END IF

     execi = ListGetInteger( Solver % Values, 'Exec Interval', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Timestep' )
       execi = MOD( NINT(Timevar % Values(1))-1, execi )
       IF ( execi /= 0 ) RETURN
     END IF

     IF ( Solver % Mesh % Changed .OR. Solver % NumberOfActiveElements <= 0 ) THEN
       Solver % NumberOFActiveElements = 0
       EquationName = ListGetString( Solver % Values, 'Equation', stat )

       IF ( Stat ) THEN
          IF (  ASSOCIATED( Solver % ActiveElements ) ) DEALLOCATE( Solver % ActiveElements )
          ALLOCATE( Solver % ActiveElements( Solver % Mesh % NumberOfBulkElements + &
                       Solver % Mesh % NumberOFBoundaryElements ) )

          Maxdim = 0
          DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
             CurrentElement => Solver % Mesh % Elements(i)
             IF ( CheckElementEquation( Model, CurrentElement, EquationName ) ) THEN
                Solver % NumberOfActiveElements = Solver % NumberOFActiveElements + 1
                Solver % ActiveElements( Solver % NumberOFActiveElements ) = i
                Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
             END IF
          END DO
          CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
       END IF

       CALL CalculateNodalWeights(Solver)
     END IF
!------------------------------------------------------------------------------
     Solver % Mesh % OutputActive = .TRUE.
     OrigDT = dt
     DTScal = ListGetConstReal( Solver % Values, "Timestep Scale", Found )
     IF ( .NOT. Found ) DTScal = 1.0d0
     Solver % dt = DTScal * dt

     MeActive = ASSOCIATED(Solver % Matrix)
     IF ( MeActive ) &
        MeActive = MeActive .AND. (Solver % Matrix % NumberOfRows > 0)
     CALL ParallelActive( MeActive )

     str = ListGetString( Solver % Values, 'Namespace', Found )
     IF (Found) CALL ListSetNamespace(TRIM(str))

     iterV => VariableGet( Solver % Mesh % Variables, 'nonlin iter' )
     iterV % Values(1) = 1

     str = ListGetString( Solver  % Values, 'Procedure', Found )

#ifdef SGIn32
      SolverAddr = Solver % PROCEDURE
      CALL ExecSolver( SolverAddr, Model, Solver, DTScal*dt, TransientSimulation)
#else
      CALL ExecSolver( &
             Solver % PROCEDURE, Model, Solver, DTScal*dt, TransientSimulation)
#endif

     CALL ListSetNamespace('')

     Solver % dt = OrigDT
!------------------------------------------------------------------------------
   END SUBROUTINE SolverActivate
!------------------------------------------------------------------------------

END MODULE MainUtils

