!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - Scientific Computing Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Utility routines for the elmer main program.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Ville Savolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - Scientific Computing Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/
! *
! * $Log: MainUtils.src,v $
! * Revision 1.20  2006/12/18 13:06:24  jpr
! * Harmonic analysis additions.
! *
! * Revision 1.19  2006/12/18 12:23:07  jpr
! * Added 'Harmonic analysis' option.
! *
! * Revision 1.18  2006/12/01 09:02:17  jpr
! * Initial changes to enable 'constant bulk system' for time dependent
! * simulations.
! *
! * Revision 1.17  2006/11/27 10:23:57  jpr
! * Removed some execess (unrelated) use of TRIM & POINTER.
! *
! * Revision 1.16  2006/11/08 07:46:42  jpr
! * *** empty log message ***
! *
! * Revision 1.15  2006/11/03 08:31:03  jpr
! * *** empty log message ***
! *
! *
! * Revision 1.13  2006/10/09 09:33:52  jpr
! * Added 'exec interval'-keyword to solver stuff.
! *
! * Revision 1.9  2006/01/10 08:51:49  apursula
! * Updated header information (GPL).
! *
! * Revision 1.8  2005/12/22 10:27:00  jpr
! * Added solver section keyword 'Timestep scale'.
! *
! * Revision 1.7  2005/12/07 12:54:15  jpr
! * Changes to have gfortran happy / bug fix in "exported variable" defs.
! *
! * Revision 1.6  2005/07/07 09:12:27  jpr
! * Changed ElementInfo to have dBasisdx,ddBasisddx as OPTIONAL arguments.
! * Changed all calls to ElementInfo accordingly.
! *
! * Revision 1.5  2005/07/06 08:38:00  jpr
! * Some comments added.
! *
! * Revision 1.4  2005/06/22 04:40:52  jpr
! * Bubbles to global system by default.
! *
! * Revision 1.3  2005/05/26 12:33:14  jpr
! * Removed explicit DLLEXPORT definitions
! *
! * Revision 1.2  2005/05/26 11:32:55  vierinen
! * umfpack changes
! *
! * Revision 1.1  2005/05/26 08:24:30  vierinen
! * moved .f90 to .src because .f90 is needed for preprosessed files
! *
! * Revision 1.2  2005/05/04 09:16:04  vierinen
! * minor modifications
! *
! * Revision 1.157  2005/04/14 11:36:15  jpr
! * Removed the Sparse library interface.
! *
! * Revision 1.148  2004/03/03 10:22:37  jpr
! * Corrected bug in radiation factors&matrix structured introduced
! * by previous changes.
! *
! * Revision 1.147  2004/03/03 09:40:36  jpr
! * Changed strategy of allocation of solver primary variables somewhat.
! *
! * 
! * $Id: MainUtils.src,v 1.20 2006/12/18 13:06:24 jpr Exp $
! *****************************************************************************/

MODULE MainUtils

!------------------------------------------------------------------------------

  USE SolverUtils
  USE ModelDescription

!------------------------------------------------------------------------------
  IMPLICIT NONE
!------------------------------------------------------------------------------

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION GetMatrixFormat( Model, Equation ) RESULT(FORMAT)
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    CHARACTER(LEN=*) :: Equation
!------------------------------------------------------------------------------
    INTEGER :: FORMAT

    INTEGER :: i
    LOGICAL :: Found
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
!
!
    FORMAT = MATRIX_CRS

!
! TODO: The following code always selects the MATRIX_CRS as format
! and should be removed...
! -----------------------------------------------------------------
    DO i=1,Model % NumberOfSolvers
       IF (  &
            ListGetString(Model % Solvers(i) % Values, 'Equation') == Equation &
            ) THEN

          str = ListGetString( Model % Solvers(i) % Values, & 
                  'Linear System Solver', Found )
          IF ( .NOT. Found ) str = 'direct'

          IF ( str == 'direct' ) THEN
             str = ListGetString(Model % Solvers(i) % Values, &
                  'Linear System Direct Method', Found )

             IF ( .NOT. Found ) THEN
                FORMAT = MATRIX_CRS
             ELSE
                SELECT CASE( str )
                CASE( 'banded', 'symmetric banded' )
                   FORMAT = MATRIX_CRS

                CASE( 'umfpack' )
#include "../config.h"
#ifdef HAVE_UMFPACK
                   FORMAT = MATRIX_CRS
#else
                   CALL Fatal( 'GetMatrixFormat', 'UMPACK solver has not been installed.' )
#endif

                CASE DEFAULT
                   CALL Warn( 'GetMatrixFormat', 'Unknown direct solver method: ' // TRIM(str) )
                   CALL Warn( 'GetMatrixFormat', 'band solver (LAPACK) will be used.' )
                   FORMAT = MATRIX_CRS
                END SELECT
             END IF
          ELSE IF ( str == 'iterative' ) THEN
             FORMAT = MATRIX_CRS
          ELSE IF ( str == 'multigrid' ) THEN
             FORMAT = MATRIX_CRS
          ELSE
             CALL Fatal( 'GetMatrixFormat', 'Unknown linear system solver: ' // TRIM(str) )
             STOP
          END IF

          EXIT
       END IF
    END DO
!------------------------------------------------------------------------------
  END FUNCTION GetMatrixFormat
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddSolverProcedure( Solver,PROCEDURE  )
!------------------------------------------------------------------------------
    TYPE(Solver_t) :: Solver
    EXTERNAL :: PROCEDURE
    INTEGER  :: PROCEDURE
!------------------------------------------------------------------------------
    INTEGER(KIND=AddrInt) :: AddrFunc
!------------------------------------------------------------------------------
    Solver % PROCEDURE = AddrFunc( PROCEDURE )
!------------------------------------------------------------------------------
  END SUBROUTINE AddSolverProcedure
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddEquation( Solver, Name,Transient )
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
    CHARACTER(LEN=*) :: Name
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: Solution(:), Component(:)

    INTEGER, POINTER :: Perm(:)

    INTEGER :: i,j,k,l,NDeg,Nrows,nSize,n,DOFs,MatrixFormat,istat
    INTEGER :: MaxDGDOFs, MaxNDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs

    LOGICAL :: Found, BandwidthOptimize, EigAnal, ComplexFlag, &
    MultigridActive, VariableOutput, GlobalBubbles, HarmonicAnal

    CHARACTER(LEN=MAX_NAME_LEN) :: str,eq,var_name, tmpname

    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix
    TYPE(Element_t), POINTER :: CurrentElement

    TYPE(Variable_t), POINTER :: Var
    TYPE(Variable_t), POINTER :: NewVariable

    REAL(KIND=dp) :: tt, CPUTime

    REAL(KIND=dp), POINTER :: freqv(:,:)

    EXTERNAL FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver
    INTEGER :: FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver

    !------------------------------------------------------------------------------
    MaxNDOFs  = 0
    MaxDGDOFs = 0
	DO i=1,Solver % Mesh % NumberOFBulkElements
	CurrentElement => Solver % Mesh % Elements(i)
	MaxDGDOFs = MAX( MaxDGDOFs, CurrentElement % DGDOFs )
MaxNDOFs  = MAX( MaxNDOFs,  CurrentElement % NDOFs )
	END DO

	MaxEDOFs = 0
	DO i=1,Solver % Mesh % NumberOFEdges 
	CurrentElement => Solver % Mesh % Edges(i)
MaxEDOFs  = MAX( MaxEDOFs,  CurrentElement % BDOFs )
	END DO

	MaxFDOFs = 0
	DO i=1,Solver % Mesh % NumberOFFaces 
	CurrentElement => Solver % Mesh % Faces(i)
MaxFDOFs  = MAX( MaxFDOFs,  CurrentElement % BDOFs )
	END DO

	MaxBDOFs = 0
	DO i=1,Solver % Mesh % NumberOFBulkElements
	CurrentElement => Solver % Mesh % Elements(i)
MaxBDOFs  = MAX( MaxBDOFs,  CurrentElement % BDOFs )
	END DO

	GlobalBubbles = ListGetLogical( Solver % Values, 'Bubbles in Global System', Found )
	IF (.NOT.Found) GlobalBubbles=.TRUE.

	Ndeg = 0
	Ndeg = Ndeg + Solver % Mesh % NumberOfNodes 
	IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Solver % Mesh % NumberOFEdges
	IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Solver % Mesh % NumberOFFaces
	IF ( GlobalBubbles ) &
	Ndeg = Ndeg + MaxBDOFs * Solver % Mesh % NumberOfBulkElements
	Ndeg = MAX( NDeg, MaxDGDOFs * (Solver % Mesh % NumberOfBulkElements+ &
				Solver % Mesh % NumberOfBoundaryElements) )

	Solver % Order = 1

	IF ( Transient ) THEN
	str = ListGetString( Solver % Values, 'Timestepping Method',Found )
	IF ( .NOT. Found ) THEN
	str = ListGetString( CurrentModel % Simulation, 'Timestepping Method',Found )
	IF ( Found ) THEN
	CALL ListAddString( Solver % Values, 'Timestepping Method', str )
	END IF
	END IF

	IF ( Found ) THEN
	IF (str=='bdf') THEN
	Solver % Order = ListGetInteger( Solver % Values, &
			'BDF Order', Found, minv=1, maxv=5 )
	IF ( .NOT. Found ) THEN
	Solver % Order = ListGetInteger( CurrentModel % &
			Simulation, 'BDF Order', Found, minv=1, maxv=5 )
	END IF
	IF ( .NOT.Found ) THEN
	Solver % Order = 2
	CALL Warn( 'AddEquation', 'BDF order defaulted to 2.' )
	END IF
	ELSE IF ( str=='runge-kutta') THEN
	Solver % Order = ListGetInteger( CurrentModel % &
			Simulation, 'Runge-Kutta Order', Found, minv=2, maxv=4 )
	IF ( .NOT.Found ) Solver % Order = 2
	END IF
	ELSE
	CALL Warn( 'AddEquation', 'Time stepping method defaulted to IMPLICIT EULER' )
	CALL ListAddString( Solver % Values, 'Timestepping Method', 'Implicit Euler' )
	END IF
	END IF

	Solver % TimeOrder = 1
	!------------------------------------------------------------------------------

DOFs = CoordinateSystemDimension()
	IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = DOFs + 1

MatrixFormat = GetMatrixFormat( CurrentModel, Name )

	BandwidthOptimize = ListGetLogical( Solver % Values, &
			'Optimize Bandwidth', Found )
	IF ( .NOT. Found ) BandwidthOptimize = .TRUE.

	VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
	IF ( .NOT. Found ) VariableOutput = .TRUE.

	var_name = ListGetString( Solver % Values, 'Variable', Found )
	IF ( Found ) THEN
	IF ( var_name(1:9) == '-nooutput' ) THEN
	VariableOutput = .FALSE.
var_name(1:LEN(var_name)-10) = var_name(11:)
	END IF
	END IF

	!------------------------------------------------------------------------------
SELECT CASE( Name )       
	!------------------------------------------------------------------------------

	!------------------------------------------------------------------------------
	CASE('navier-stokes')
	!------------------------------------------------------------------------------
	Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Flow Solution')

	IF ( ASSOCIATED( Solver % Variable ) ) THEN
	Perm => Solver % Variable % Perm
	ELSE
ALLOCATE( Perm(Ndeg), STAT=istat )
	IF ( istat /= 0 ) THEN
	CALL Fatal( 'AddEquation', 'Memory allocation error.' )
	END IF
	END IF

	Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, Perm, &
			DOFs+1, MatrixFormat, BandwidthOptimize, 'Navier-Stokes', GlobalBubbles=GlobalBubbles )

	Nrows =(DOFs+1)* Ndeg
	IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
	IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
ALLOCATE( Solution(Nrows), STAT=istat )

	! First add components to the variable list separately (must be done
			! this way for the output routines to work properly...):
	!---------------------------------------------------------------------
Component => Solution( 1 : Nrows: DOFs+1 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 1', &
			1, Component, Perm, Output=VariableOutput )

Component => Solution( 2 : Nrows: DOFs+1 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 2', &
			1, Component, Perm, Output=VariableOutput )

	IF ( DOFs+1 == 3 ) THEN
Component => Solution( 3 : Nrows: DOFs+1 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
			1, Component, Perm, Output=VariableOutput )
	ELSE
Component => Solution( 3 : Nrows: DOFs+1 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 3', &
			1, Component, Perm, Output=VariableOutput )

Component => Solution( 4 : Nrows : DOFs+1 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
			1, Component, Perm, Output=VariableOutput )
	END IF

	! Then add the thing itself:
	!---------------------------
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Flow Solution',DOFs+1,Solution,Perm, Output=VariableOutput )

	Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Flow Solution' )
	Solution = 1.0d-6
	END IF
CALL AddSolverProcedure( Solver, FlowSolver )
	!------------------------------------------------------------------------------


	!------------------------------------------------------------------------------
	CASE('magnetic induction')
	!------------------------------------------------------------------------------
	Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Magnetic Field')

	IF ( ASSOCIATED( Solver % Variable ) ) THEN
	Perm => Solver % Variable % Perm
	ELSE
ALLOCATE( Perm(NDeg),STAT=istat )
	IF ( istat /= 0 ) THEN
	CALL Fatal( 'AddEquation', 'Elmer Solver: Memory allocation error.' )
	END IF
	END IF

	Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
			Perm,3, MatrixFormat, BandwidthOptimize, 'Magnetic Induction', GlobalBubbles=GlobalBubbles )

	Nrows = 3*Ndeg
	IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
	IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
ALLOCATE( Solution(Nrows), STAT=istat )

Component => Solution( 1 : Nrows : 3 )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
			'Magnetic Field 1', 1, Component, Perm,Output=VariableOutput )

Component => Solution( 2 : Nrows : 3 )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
			'Magnetic Field 2', 1, Component, Perm,Output=VariableOutput )

Component => Solution( 3 : Nrows : 3 )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
			'Magnetic Field 3', 1, Component, Perm,Output=VariableOutput )
	!------------------------------------------------------------------------------
	!         Then add the thing itself
	!------------------------------------------------------------------------------
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Magnetic Field',3,Solution,Perm,Output=VariableOutput )

	Solver % Variable => VariableGet( Solver % Mesh % Variables, &
			'Magnetic Field' )

	Solution = 0.0d0
	!------------------------------------------------------------------------------
	!         Add first components to the variable list separately...
	!------------------------------------------------------------------------------
ALLOCATE( Solution(Nrows), STAT=istat )

Component => Solution( 1 : Nrows : 3 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Electric Current 1', 1, Component, Perm,Output=VariableOutput )

Component => Solution( 2 : Nrows : 3 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Electric Current 2', 1, Component, Perm,Output=VariableOutput )

Component => Solution( 3 : Nrows : 3 )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Electric Current 3', 1, Component, Perm,Output=VariableOutput )
	!------------------------------------------------------------------------------
	!         Then add the thing itself
	!------------------------------------------------------------------------------
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
			'Electric Current', 3, Solution, Perm, Output=VariableOutput )
	Solution = 0.0d0
	END IF
CALL AddSolverProcedure( Solver, MagneticSolver )
	!------------------------------------------------------------------------------


	!------------------------------------------------------------------------------
	CASE('stress analysis')
	!------------------------------------------------------------------------------
	IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2

	Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')
	IF ( ASSOCIATED( Solver % Variable ) ) THEN
	Perm => Solver % Variable % Perm
	ELSE
ALLOCATE( Perm(NDeg),STAT=istat )
	IF ( istat /= 0 ) THEN
	CALL Fatal( 'AddEquation', 'Memory allocation error.' )
	END IF
	END IF

	Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
			Perm, DOFs, MatrixFormat, BandwidthOptimize, 'Stress Analysis', GlobalBubbles=GlobalBubbles )

	Nrows = DOFs*Ndeg
	IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
	IF ( .NOT.ASSOCIATED( Solver % Variable ) ) THEN
ALLOCATE( Solution(Nrows), STAT=istat )

	! First add the components to the variable list separately:
	!----------------------------------------------------------
Component => Solution( 1 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Displacement 1',1, Component, Perm,Output=VariableOutput )

Component => Solution( 2 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
			'Displacement 2', 1, Component, Perm,Output=VariableOutput )

	IF ( CoordinateSystemDimension() >= 3 ) THEN
Component => Solution( 3 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver,  &
			'Displacement 3', 1, Component, Perm, Output=VariableOutput )
	END IF

	! Then add the thing itself:
	!---------------------------
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
			'Displacement',DOFs,Solution,Perm,Output=VariableOutput )

	Solver % Variable => VariableGet( Solver % Mesh % Variables, &
			'Displacement' )

	Solution = 0.0D0
	END IF
CALL AddSolverProcedure( Solver, StressSolver )
	!------------------------------------------------------------------------------


	!------------------------------------------------------------------------------
	CASE('mesh update')
	!------------------------------------------------------------------------------
	IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2

	Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Mesh Update')
	IF ( ASSOCIATED( Solver % Variable ) ) THEN
	Perm => Solver % Variable % Perm
	ELSE
ALLOCATE( Perm(Ndeg), STAT=istat )
	IF ( istat /= 0 ) THEN
	CALL Fatal( 'AddEquation', 'Memory allocation error.' )
	END IF
	END IF

	Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
			Perm, DOFs, MatrixFormat, BandwidthOptimize, 'Mesh Update', GlobalBubbles=GlobalBubbles )
	IF ( .NOT. ASSOCIATED( Solver % Matrix ) )  RETURN

	Nrows = DOFs*Ndeg
	IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
	IF (.NOT. ASSOCIATED( Solver % Variable ) ) THEN
ALLOCATE( Solution(Nrows), STAT=istat )

	! First add the components to the variable list separately:
	!----------------------------------------------------------
Component => Solution( 1 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
			'Mesh Update 1',1, Component, Perm,Output=VariableOutput )

Component => Solution( 2 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
			'Mesh Update 2', 1, Component, Perm,Output=VariableOutput )

	IF ( CoordinateSystemDimension() >= 3 ) THEN
Component => Solution( 3 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver,  &
			'Mesh Update 3', 1, Component, Perm,Output=VariableOutput )
	END IF

	!      Then add the thing itself...
	!------------------------------------------------------------------------------
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
			'Mesh Update',DOFs,Solution,Perm,Output=VariableOutput )
	Solution = 0.0d0
	Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Mesh Update' )
	END IF

	Var =>  VariableGet( Solver % Mesh % Variables, 'Mesh Velocity')
	IF ( .NOT. ASSOCIATED(Var) ) THEN
	IF ( Transient ) THEN
ALLOCATE( Solution(Nrows), STAT=istat )
	IF ( istat /= 0 ) THEN
	CALL Fatal( 'AddEquation', 'Memory allocation error.' )
	END IF

Component => Solution( 1 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, &
			Solver, 'Mesh Velocity 1',1, Component, Perm,Output=VariableOutput )

Component => Solution( 2 : Nrows : DOFs )
	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, &
			Solver, 'Mesh Velocity 2', 1, Component, Perm,Output=VariableOutput )

	IF ( CoordinateSystemDimension() >= 3 ) THEN
Component => Solution( 3 : Nrows : DOFs )
	CALL VariableAdd(Solver % Mesh % Variables,Solver % Mesh, &
			Solver, 'Mesh Velocity 3', 1, Component, Perm,Output=VariableOutput )
	END IF

	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
			'Mesh Velocity',DOFs,Solution,Perm,Output=VariableOutput )

	Solution = 0.0D0
	END IF
	END IF

CALL AddSolverProcedure( Solver, MeshSolver )
	!------------------------------------------------------------------------------
	!------------------------------------------------------------------------------


	!------------------------------------------------------------------------------
	CASE('heat equation')
	!------------------------------------------------------------------------------
	Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )

	IF ( ASSOCIATED( Solver % Variable ) ) THEN
	Perm => Solver % Variable % Perm
	ELSE
ALLOCATE( Perm(Ndeg),STAT=istat )
	END IF

	eq = ListGetString( CurrentModel % Simulation, 'Gebhardt Factors',Found )
	IF ( Found ) THEN
CALL LoadGebhardtFactors( Solver % Mesh,eq )
	ELSE
CALL RadiationFactors( Solver, .TRUE.)
	END IF

	Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
			Perm,1, MatrixFormat, BandwidthOptimize, 'Heat Equation', GlobalBubbles=GlobalBubbles)

	Nrows = Ndeg
	IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
	IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
ALLOCATE( Solution(Nrows),STAT=istat )
	IF ( istat /= 0 ) THEN
	CALL Fatal( 'AddEquation', 'Memory allocation error.' )
	END IF

	CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, Solver,&
			'Temperature',1, Solution, Perm, Output=VariableOutput )

	Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )
	Solution = 0.0d0
	END IF
CALL AddSolverProcedure( Solver, HeatSolver )
	!------------------------------------------------------------------------------

	!------------------------------------------------------------------------------
	CASE DEFAULT
	!------------------------------------------------------------------------------
	NULLIFY( Solver % Matrix )
NULLIFY( Solver % Variable )
	Solver % TimeOrder = 0

	eq = ListGetString( Solver  % Values, 'Equation', Found )

	IF ( Found ) THEN
	var_name = ListGetString( Solver % Values, 'Variable', Found )

	IF ( Ndeg >= 1 .AND. Found ) THEN
	DOFs = ListGetInteger( Solver % Values, 'Variable DOFs', Found, minv=1 )
	IF ( .NOT. Found ) THEN
	j = 0
	DOFs = 0
DO WHILE( .TRUE. )
	i = INDEX( var_name(j+1:), ':' ) + j
	IF ( i<=j ) EXIT
	READ( var_name(i+1:),'(i1)' ) k
	DOFs = DOFs + k
	j = i + 1
	END DO
	END IF

	VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
	IF ( .NOT. Found ) VariableOutput = .TRUE.

	DO WHILE( var_name(1:1) == '-' )
	IF ( var_name(1:10) == '-nooutput ' ) THEN
	VariableOutput = .FALSE.
var_name(1:LEN(var_name)-10) = var_name(11:)
	END IF

	IF ( var_name(1:6) == '-dofs ' ) THEN
	READ( var_name(7:), * ) DOFs
	i = 7
j = LEN_TRIM( var_name )
	DO WHILE( var_name(i:i) /= ' '  )
	i = i + 1
	IF ( i > j ) EXIT
	END DO
var_name(1:LEN(var_name)-i) = var_name(i+1:)
	END IF
	END DO
	IF ( DOFs == 0 ) DOFs = 1

	n = LEN_TRIM(var_name)
Solver % Variable => VariableGet( Solver % Mesh % Variables,var_name(1:n) )
	IF ( ASSOCIATED( Solver % Variable ) ) THEN
	Perm => Solver % Variable % Perm
	ELSE
ALLOCATE( Perm(Ndeg) )
	END IF

	Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
			Perm, DOFs, MatrixFormat, BandwidthOptimize, eq(1:LEN_TRIM(eq)), &
			ListGetLogical( Solver % Values, &
				'Discontinuous Galerkin', Found ), GlobalBubbles=GlobalBubbles )

	Nrows = DOFs * Ndeg
	IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows

	IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
ALLOCATE( Solution( Nrows ) )
	Solution = 0.0d0

	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
			var_name(1:n), DOFs, Solution, Perm, Output=VariableOutput )

Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )

	IF ( DOFs > 1 ) THEN
	DO i=1,DOFs
	tmpname = ComponentName( var_name(1:n), i )
Component => Solution( i:Nrows-DOFs+i:DOFs )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
			tmpname, 1, Component, Perm, Output=VariableOutput )
	END DO
	END IF
	END IF
	ELSE
ALLOCATE( Solver % Variable )
	Solver % Variable % Norm = 0.0d0
NULLIFY( Solver % Variable % Values )
	END IF
	ELSE
ALLOCATE( Solver % Variable )
	Solver % Variable % Norm = 0.0d0
NULLIFY( Solver % Variable % Values )
	END IF


	l = 1
DO WHILE( .TRUE. )
	str = ComponentName( 'exported variable', l )
var_name = ListGetString( Solver % Values, str, Found )

	IF ( Found ) THEN
	str = TRIM( ComponentName( 'exported variable', l ) ) // ' Output'
VariableOutput = ListGetLogical( Solver % Values, str, Found )
	IF ( .NOT. Found ) VariableOutput = .TRUE.

	str = TRIM( ComponentName( 'exported variable', l ) ) // ' DOFs'
DOFs = ListGetInteger( Solver % Values, str, Found )
	IF ( .NOT. Found ) THEN
	j = 0
	DOFs = 0
DO WHILE( .TRUE. )
	i = INDEX( var_name(j+1:), ':' ) + j
	IF ( i<=j ) EXIT
	READ( var_name(i+1:),'(i1)' ) k
	DOFs = DOFs + k
	j = i + 1
	END DO
	END IF

	VariableOutput = .TRUE.
	DO WHILE( var_name(1:1) == '-' )
	IF ( var_name(1:10) == '-nooutput ' ) THEN
	VariableOutput = .FALSE.
var_name(1:LEN(var_name)-10) = var_name(11:)
	END IF

	IF ( var_name(1:6) == '-dofs ' ) THEN
	READ( var_name(7:), * ) DOFs 
j = LEN_TRIM( var_name )
	k = 7
	DO WHILE( var_name(k:k) /= ' '  )
	k = k + 1
	IF ( k > j ) EXIT
	END DO
var_name(1:LEN(var_name)-(k+2)) = var_name(k+1:)
	END IF
	END DO
	IF ( DOFs == 0 ) DOFs = 1

NewVariable => VariableGet( Solver % Mesh % Variables, Var_name )

	IF ( .NOT. ASSOCIATED(NewVariable) ) THEN
	nSize = Nrows * DOFs / Solver % Variable % DOFs
ALLOCATE( Solution(nSize) )
	Solution = 0.0d0
	Perm => Solver % Variable % Perm

	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
			var_name, DOFs, Solution, Solver % Variable % Perm,Output=VariableOutput )

	IF ( DOFs > 1 ) THEN
n = LEN_TRIM( var_name )
	DO j=1,DOFs
	tmpname = ComponentName( var_name(1:n), j )
Component => Solution( j:nSize-DOFs+j:DOFs )
	CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
			tmpname, 1, Component, Perm, Output=VariableOutput )
	END DO
	END IF
	END IF
	ELSE
	EXIT
	END IF
	l = l + 1
	END DO

	str = ListGetString( Solver  % Values, 'Procedure' )
Solver % PROCEDURE = GetProcAddr( str )
	!------------------------------------------------------------------------------
	END SELECT
	!------------------------------------------------------------------------------

	Solver % NOFEigenValues = 0
	!   NULLIFY( Solver % Variable % PrevValues )
	!   NULLIFY( Solver % Variable % EigenValues )
!   NULLIFY( Solver % Variable % EigenVectors )

	Solver % DoneTime  = 0
	Solver % MultiGridLevel = 1
	Solver % MultiGridTotal = 0
	Solver % MultiGridSolver = .FALSE.
	Solver % MultiGridEqualSplit = .FALSE.
	!------------------------------------------------------------------------------
	!
	!   Check for special solvers, to be executed only
	!   at a certain points in simulation:
	!   ----------------------------------------------

	Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS

	SELECT CASE( ListGetString( Solver % Values, 'Exec Solver', Found )  )
	CASE( 'never' )
	Solver % SolverExecWhen = SOLVER_EXEC_NEVER
	CASE( 'always' )
	Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
	CASE( 'after simulation', 'after all' )
	Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
      CASE( 'before simulation', 'before all' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
      CASE( 'before timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
      CASE( 'after timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
      CASE DEFAULT
         Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
    END SELECT

    IF ( ListGetLogical( Solver % Values, 'Before All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'After Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
    END IF

    Solver % LinAfterProc  = 0
    Solver % LinBeforeProc = 0
    str = ListGetString( Solver  % Values, 'Before Linsolve', Found )
    IF ( Found ) Solver % LinBeforeProc = GetProcAddr( str )

    str = ListGetString( Solver  % Values, 'After Linsolve', Found )
    IF ( Found ) Solver % LinAfterProc = GetProcAddr( str )

!------------------------------------------------------------------------------
    IF ( .NOT. ASSOCIATED( Solver % Variable % Values ) ) RETURN
!------------------------------------------------------------------------------

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
       ALLOCATE( Solver % Matrix % RHS(Solver % Matrix % NumberOFRows) )
       Solver % Matrix % RHS = 0.0d0
    END IF
!------------------------------------------------------------------------------

    HarmonicAnal = ListGetLogical( Solver % Values, 'Harmonic Analysis', Found )
    EigAnal = ListGetLogical( Solver % Values, 'Eigen Analysis', Found )

    IF ( Transient .AND. .NOT. EigAnal .AND. .NOT. HarmonicAnal ) THEN
       k = ListGetInteger( Solver % Values, 'Time Derivative Order', Found, &
                  minv=0, maxv=2 )
       Solver % TimeOrder = 1
       IF ( Found ) Solver % TimeOrder = MIN(MAX(1,k),2)

       IF ( ASSOCIATED( Solver % Matrix ) ) THEN
          ALLOCATE( Solver % Matrix % Force(Solver % Matrix % NumberOFRows, &
                          Solver % TimeOrder+1) )
          Solver % Matrix % Force = 0.0d0
       END IF

       IF ( .NOT. ASSOCIATED( Solver % Variable % PrevValues ) ) THEN
          IF ( Solver % TimeOrder == 2 ) THEN
             ALLOCATE( Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values),5) )
          ELSE IF ( Solver % Order > Solver % TimeOrder ) THEN
             ALLOCATE(Solver % Variable % PrevValues( &
                   SIZE(Solver % Variable % Values), Solver % Order))
          ELSE
             ALLOCATE(Solver % Variable % PrevValues( &
                   SIZE(Solver % Variable % Values), Solver % TimeOrder))
          END IF
          Solver % Variable % PrevValues = 0.0d0

          IF ( Solver % Variable % DOFs > 1 ) THEN
             IF ( Solver % Variable % Name == 'flow solution' ) THEN
               DO k=1,Solver % Variable % DOFs-1
                  str = 'Velocity ' // CHAR(k+ICHAR('0'))
                  Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                  Var % PrevValues =>  &
                      Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
               END DO
               Var => VariableGet( Solver % Mesh % Variables, 'Pressure', .TRUE. )
               Var % PrevValues =>  &
                     Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
             ELSE
               DO k=1,Solver % Variable % DOFs
                  str = ComponentName( Solver % Variable % Name, k )
                  Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                  Var % PrevValues =>  &
                      Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
               END DO
             END IF
          END IF
       END IF
    ELSE
       Solver % TimeOrder = 0
       IF ( EigAnal ) THEN
          ComplexFlag = ListGetLogical( Solver % Values,  'Eigen System Complex', Found )
          IF ( .NOT. Found ) ComplexFlag = .FALSE.

          n = ListGetInteger( Solver % Values,  'Eigen System Values', Found )
          IF ( Found .AND. n > 0 ) THEN
             Solver % NOFEigenValues = n
             IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
               ALLOCATE( Solver % Variable % EigenValues(n) )
               ALLOCATE( Solver % Variable % EigenVectors(n, &
                    SIZE( Solver % Variable % Values ) ) )

               Solver % Variable % EigenValues  = 0.0d0
               Solver % Variable % EigenVectors = 0.0d0

               DO k=1,Solver % Variable % DOFs
                 str = ComponentName( Solver % Variable % Name, k )
                 Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                 IF ( ASSOCIATED( Var ) ) THEN
                    Var % EigenValues => Solver % Variable % EigenValues
                    IF ( ComplexFlag ) THEN
                       Var % EigenVectors => Solver % Variable % EigenVectors
                    ELSE
                       Var % EigenVectors =>  & 
                          Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs )
                    END IF
                 END IF
               END DO
             END IF
             ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
             Solver % Matrix % MassValues = 0.0d0
          END IF
       ELSE IF ( HarmonicAnal ) THEN
          freqv => ListGetConstRealArray( Solver % Values, 'Frequency', Found )
          IF ( Found ) THEN
             n = SIZE(Freqv,1)
             Solver % NOFEigenValues = n
             IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
               ALLOCATE( Solver % Variable % EigenValues(n) )
               ALLOCATE( Solver % Variable % EigenVectors(n, &
                    SIZE( Solver % Variable % Values ) ) )

               Solver % Variable % EigenValues  = 0.0d0
               Solver % Variable % EigenVectors = 0.0d0

               DO k=1,Solver % Variable % DOFs
                 str = ComponentName( Solver % Variable % Name, k )
                 Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                 IF ( ASSOCIATED( Var ) ) THEN
                    Var % EigenValues => Solver % Variable % EigenValues
                    Var % EigenVectors => Solver % Variable % EigenVectors
                 END IF
               END DO
             END IF
             ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
             Solver % Matrix % MassValues = 0.0d0
          ELSE
             CALL Fatal( 'AddEquation', 'Frequency must be given for harmonic analysis.' )
          END IF
       END IF
    END IF

!------------------------------------------------------------------------------

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
       Solver % Matrix % Symmetric = ListGetLogical( Solver % Values, &
                  'Linear System Symmetric', Found )

       Solver % Matrix % Lumped = ListGetLogical( Solver % Values, &
                  'Lumped Mass Matrix', Found )

       MultigridActive = &
         ListGetString( Solver % Values, 'Linear System Solver', Found ) == 'multigrid' .OR. &
         ListGetString( Solver % Values, 'Linear System Preconditioning', Found ) == 'multigrid'


!      Check for multigrid solver:
!      ---------------------------
       IF ( MultigridActive ) THEN

          Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
                        'MG Levels', Found, minv=1 )

          IF ( .NOT. Found ) THEN
             Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
                     'Multigrid Levels', Found, minv=1 )
          END IF
          IF ( .NOT. Found ) Solver % MultiGridTotal = 1
!
!         Check if h/2 splitting of mesh requested:
!         ------------------------------------------
          Solver % MultiGridEqualSplit = ListGetLogical( &
             Solver % Values, 'MG Equal Split', Found )

          IF ( Solver % MultiGridEqualSplit ) THEN
             CALL ParallelInitMatrix( Solver, Solver % Matrix )
             Solver % MultiGridLevel = 1
             DO WHILE( Solver % MultiGridLevel < Solver % MultiGridTotal )
                IF ( ASSOCIATED( Solver % Mesh % Child ) ) THEN
                   NewMesh => Solver % Mesh % Child

                   OldMesh   => Solver % Mesh
                   OldMatrix => Solver % Matrix

                   CALL UpdateSolverMesh( Solver, NewMesh )
                   Solver % Mesh % Changed = .FALSE.
                ELSE
                   NewMesh => SplitMeshEqual( Solver % Mesh )
                   NewMesh % Next => CurrentModel % Meshes
                   CurrentModel % Meshes => NewMesh

                   OldMesh   => Solver % Mesh
                   OldMatrix => Solver % Matrix

                   CALL UpdateSolverMesh( Solver, NewMesh )
                   Solver % Mesh % Changed = .FALSE.

                   NewMesh % Parent => OldMesh
                   OldMesh % Child  => NewMesh
                   NewMesh % Name = OldMesh % Name
                END IF

                NewMatrix => Solver % Matrix
                NewMatrix % Parent => OldMatrix
                OldMatrix % Child  => NewMatrix

                CALL ParallelInitMatrix( Solver, Solver % Matrix )
                Solver % MultiGridLevel = Solver % MultiGridLevel + 1
             END DO
          END IF
          CALL MeshStabParams( Solver % Mesh )
          Solver % MultiGridSolver = ListGetString(Solver % Values, &
             'Linear System Solver', Found ) == 'multigrid'
          Solver % MultiGridLevel  = Solver % MultiGridTotal
       END IF
    END IF
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE AddEquation
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolveEquations( Model, dt, TransientSimulation, &
      CoupledMinIter, CoupledMaxIter, SteadyStateReached )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    INTEGER :: CoupledMinIter, CoupledMaxIter
    LOGICAL :: TransientSimulation, SteadyStateReached
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: PrevNorm, RelativeChange, Tolerance, PrevDT = 0.0d0
    INTEGER :: i,j,k,n
    LOGICAL :: Found, AbsNorm, Convergence, RungeKutta
    LOGICAL, ALLOCATABLE :: DoneThis(:)
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Mesh_t),   POINTER :: Mesh
    CHARACTER(LEN=max_name_len) :: When
    REAL(KIND=dp), ALLOCATABLE :: k1(:), k2(:), k3(:), k4(:)
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!   Intialize equation solvers for new timestep
!------------------------------------------------------------------------------
    IF ( TransientSimulation ) THEN
       DO k=1,Model % NumberOfSolvers
          Solver => Model % Solvers(k)
          CALL InitializeTimestep( Solver )
       END DO
    END IF
!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)

      when  = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF ( Found ) THEN
         IF ( When == 'before timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AHEAD_TIME ) THEN
            CALL SolverActivate( Model,Solver,dt,TransientSimulation )
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------

    ALLOCATE( DoneThis( Model % NumberOfSolvers ) )

    IF ( PrevDT == 0.0d0 ) PrevDT = dt
!------------------------------------------------------------------------------
    DO i=1,CoupledMaxIter
       IF ( TransientSimulation ) THEN
          CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Info( 'SolveEquations', Message, Level=3 )
          CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )
       END IF

       DoneThis = .FALSE.

!      Initialize the mesh output flag to FALSE here, reactivated
!      later for meshes connected to active solvers.
!      ----------------------------------------------------------
       Mesh => Model % Meshes
       DO WHILE( ASSOCIATED( Mesh ) )
          Mesh % OutputActive = .FALSE.
          Mesh => Mesh % Next
       END DO
!------------------------------------------------------------------------------
!      Go trough number of solvers (heat,laminar or turbulent flow, etc...)
!------------------------------------------------------------------------------
       DO k=1,Model % NumberOfSolvers
!------------------------------------------------------------------------------
          Solver => Model % Solvers(k)

          When = ListGetString( Solver % Values, 'Exec Solver', Found )
          IF ( Found ) THEN
             IF ( When /= 'always' ) THEN
                DoneThis(k) = .TRUE.
                CYCLE
             END IF
          ELSE
            IF ( Solver % SolverExecWhen /= SOLVER_EXEC_ALWAYS ) THEN
               DoneThis(k) = .TRUE.
               CYCLE
            END IF
          END IF
!------------------------------------------------------------------------------

          RungeKutta = .FALSE.
          IF ( TransientSimulation .AND. Solver % TimeOrder == 1 ) THEN
             RungeKutta = ListGetString( Solver % Values, &
                    'Timestepping Method', Found ) == 'runge-kutta'
          END IF

          PrevNorm = Solver % Variable % Norm
          IF ( RungeKutta ) THEN
            n = SIZE(Solver % Variable % Values)

            SELECT CASE( Solver % Order )
            CASE(2)
              ALLOCATE( k1(n), k2(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k2 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                  ( k1 + k2 ) / 2
              DEALLOCATE( k1, k2 )


            CASE DEFAULT
              ALLOCATE( k1(n), k2(n), k3(n), k4(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1/2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k2 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k3 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k3
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k4 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                ( k1 + 2*k2 + 2*k3 + k4 ) / 6
              DEALLOCATE( k1, k2, k3, k4 )
            END SELECT
            Solver %  Variable % Norm = &
                    SQRT( SUM( Solver % Variable % Values(1:n)**2 ) / n )
          ELSE
             CALL SolverActivate( Model,Solver,dt,TransientSimulation )
          END IF
!------------------------------------------------------------------------------
!         check for coupled system convergence
!------------------------------------------------------------------------------
          IF ( i >= CoupledMinIter .OR. .NOT. TransientSimulation ) THEN
             IF ( i /= CoupledMaxIter .OR..NOT. TransientSimulation ) THEN
                IF ( PrevNorm + Solver % Variable % Norm == 0.0d0 ) THEN
                   RelativeChange = 0.0d0
                ELSE
                   RelativeChange = 2.0d0*ABS(PrevNorm-Solver % Variable % Norm)/&
                            ( PrevNorm + Solver % Variable % Norm )
                END IF

                WRITE( Message, '(a,g20.12,g20.12,a)') &
                  '(NRM,RELC): (',Solver % Variable % Norm, RelativeChange, &
                      '  ) :: ' // TRIM(ListGetString( Solver % Values, 'Equation'))
                CALL Info( 'SolveEquations', Message, Level=3 )

                absnorm = ListGetLogical( Solver % Values, 'Use Absolute Norm for Convergence', Found )
                IF ( .NOT. Found ) absnorm = .FALSE.

                Tolerance = ListGetConstReal( Solver % Values,   &
                              'Steady State Convergence Tolerance', Found ) 

                Convergence = .FALSE.
                Convergence = Convergence .OR. (RelativeChange < Tolerance) .AND. .NOT. Absnorm
                Convergence = Convergence .OR. (Solver % Variable % Norm < Tolerance) .AND. Absnorm

                IF ( Found .AND. .NOT. Convergence ) THEN
                   DoneThis(k) = .FALSE.
                ELSE
                   DoneThis(k) = .TRUE.
                   IF( ALL(DoneThis) ) EXIT
                END IF
             END IF
          END IF
!------------------------------------------------------------------------------
       END DO
!------------------------------------------------------------------------------
       Model % Mesh % Changed = .FALSE.
       IF ( ALL(DoneThis) ) EXIT
    END DO
    PrevDT = dt

    IF ( TransientSimulation .AND. .NOT. ALL(DoneThis) ) THEN
       IF ( ListGetLogical( Model % Simulation,  &
               'Coupled System Abort Not Converged', Found ) ) THEN
          CALL Error( 'SolveEquations', ' ' )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Error( 'SolveEquations', Message )
          CALL Fatal( 'SolveEquations', ' ' )
       ELSE
!         CALL Error( 'SolveEquations', ' ' )
!         WRITE( Message, * ) 'Coupled system iteration: ', i
!         CALL Error( 'SolveEquations', Message )
!         CALL Error( 'SolveEquations', ' ' )
       END IF
    END IF

!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)

      When = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF (  Found ) THEN
         IF ( When == 'after timestep' ) THEN
             CALL SolverActivate( Model,Solver,dt,TransientSimulation )
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AFTER_TIME ) &
            CALL SolverActivate( Model,Solver,dt,TransientSimulation )
      END IF
    END DO

!------------------------------------------------------------------------------
    IF ( .NOT.TransientSimulation ) SteadyStateReached = ALL(DoneThis)
!------------------------------------------------------------------------------
    DEALLOCATE( DoneThis )
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE SolveEquations
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolverActivate( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation
     REAL(KIND=dp) :: dt, OrigDT, DTScal
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, GB, FirstTime=.TRUE.
     INTEGER :: i, j, SolverAddr, BDOFs, execi, timestep
     REAL(KIND=dp) :: st
     TYPE(Variable_t), POINTER :: TimeVar
     TYPE(Element_t), POINTER :: CurrentElement
     CHARACTER(LEN=MAX_NAME_LEN) :: EquationName, str

     SAVE TimeVar, FirstTime
!------------------------------------------------------------------------------
     CALL SetCurrentMesh( Model, Solver % Mesh )
     Model % Solver => Solver

     st = ListGetConstReal( Solver % Values, 'Start Time', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Time' )
       IF ( TimeVar % Values(1) < st ) RETURN
     END IF

     execi = ListGetInteger( Solver % Values, 'Exec Interval', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Timestep' )
       execi = MOD( NINT(Timevar % Values(1))-1, execi )
       IF ( execi /= 0 ) RETURN
     END IF

     IF ( Solver % Mesh % Changed .OR. Solver % NumberOfActiveElements <= 0 ) THEN
        Solver % NumberOFActiveElements = 0
        EquationName = ListGetString( Solver % Values, 'Equation', stat )

        IF ( Stat ) THEN
           IF (  ASSOCIATED( Solver % ActiveElements ) ) DEALLOCATE( Solver % ActiveElements )
           ALLOCATE( Solver % ActiveElements( Solver % Mesh % NumberOfBulkElements + &
                        Solver % Mesh % NumberOFBoundaryElements ) )

           GB = ListGetLogical( Solver % Values,'Bubbles in Global System', Found )
           IF ( .NOT.Found ) GB=.TRUE.
           BDOFs  = 0
           DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
              CurrentElement => Solver % Mesh % Elements(i)
              IF ( CheckElementEquation( Model, CurrentElement, EquationName ) ) THEN
                 Solver % NumberOfActiveElements = Solver % NumberOFActiveElements + 1
                 Solver % ActiveElements( Solver % NumberOFActiveElements ) = i

                 IF ( .NOT. GB .AND. CurrentElement % BDOFs > 0 ) THEN
                    ALLOCATE(CurrentElement % BubbleIndexes(CurrentElement % BDOFs))
                    DO j=1,CurrentElement %  BDOFs
                       BDOFs = BDOFs + 1
                       CurrentElement % BubbleIndexes(j) = BDOFs
                    END DO
                 END IF
              END IF
           END DO

           IF ( BDOFs>0 ) THEN
             ALLOCATE( Solver % Variable % Pvalues(BDOFs*Solver % Variable % DOFs))
             Solver % Variable % PValues = 0.0d0
           END IF
        END IF

     END IF
!------------------------------------------------------------------------------
     Solver % Mesh % OutputActive = .TRUE.
     OrigDT = dt
     DTScal = ListGetConstReal( Solver % Values, "Timestep Scale", Found )
     IF ( .NOT. Found ) DTScal = 1.0d0
     Solver % dt = DTScal * dt

#ifdef SGIn32
     SolverAddr = Solver % PROCEDURE
     CALL ExecSolver( SolverAddr, Model, Solver, DTScal * dt, TransientSimulation )
#else
     CALL ExecSolver( &
              Solver % PROCEDURE, Model, Solver, DTScal * dt, TransientSimulation )
#endif
     Solver % dt = OrigDT
!------------------------------------------------------------------------------
   END SUBROUTINE SolverActivate
!------------------------------------------------------------------------------

END MODULE MainUtils
