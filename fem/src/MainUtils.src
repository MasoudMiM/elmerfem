!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *

! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Utility routines for the elmer main program.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen, Ville Savolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/

MODULE MainUtils

!------------------------------------------------------------------------------

  USE SolverUtils
  USE ModelDescription

!------------------------------------------------------------------------------
  IMPLICIT NONE
!------------------------------------------------------------------------------

CONTAINS

!------------------------------------------------------------------------------
  FUNCTION GetMatrixFormat( Model, Equation ) RESULT(FORMAT)
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    CHARACTER(LEN=*) :: Equation
!------------------------------------------------------------------------------
    INTEGER :: FORMAT

    INTEGER :: i
    LOGICAL :: Found
    CHARACTER(LEN=MAX_NAME_LEN) :: str
!------------------------------------------------------------------------------
!
!
    FORMAT = MATRIX_CRS

!
! TODO: The following code always selects the MATRIX_CRS as format
! and should be removed...
! -----------------------------------------------------------------
    DO i=1,Model % NumberOfSolvers
       FORMAT = MATRIX_CRS

       IF (  &
            ListGetString(Model % Solvers(i) % Values, 'Equation') == Equation &
            ) THEN

          str = ListGetString( Model % Solvers(i) % Values, & 
                  'Linear System Solver', Found )

          IF ( str == 'direct' ) THEN
             str = ListGetString(Model % Solvers(i) % Values, &
                  'Linear System Direct Method', Found )

             IF ( ParEnv % PEs>1 ) THEN
               IF ( str /= 'mumps' ) &
                 CALL Fatal( 'GetMatrixFormat', 'Only MUMPS direct solver' // &
                                ' implemented in parallel!')
             ELSE
               IF ( str == 'mumps' ) &
                 CALL Fatal( 'GetMatrixFormat', 'Currently no serial version' // &
                           ' of the MUMPS solver implemented, sorry!')
             END IF

             IF ( .NOT. Found ) THEN
             ELSE
                SELECT CASE( str )
                CASE( 'umfpack', 'big umfpack' )
#include "../config.h"
#ifndef HAVE_UMFPACK
                   CALL Fatal( 'GetMatrixFormat', 'UMPACK solver has not been installed.' )
#endif
                CASE( 'mumps' )
#ifndef HAVE_MUMPS
                   CALL Fatal( 'GetMatrixFormat', 'MUMPS solver has not been installed.' )
#endif
                CASE( 'superlu' )
#ifndef HAVE_SUPERLU
                   CALL Fatal( 'GetMatrixFormat', 'SuperLU solver has not been installed.' )
#endif
                CASE( 'pardiso' )
#ifndef HAVE_PARDISO
                   CALL Fatal( 'GetMatrixFormat', 'Pardiso solver has not been installed.' )
#endif
                CASE DEFAULT
                   CALL Warn( 'GetMatrixFormat', 'Unknown direct solver method: ' // TRIM(str) )
                   CALL Warn( 'GetMatrixFormat', 'band solver (LAPACK) will be used.' )
                END SELECT
             END IF
          END IF

          EXIT
       END IF
    END DO
!------------------------------------------------------------------------------
  END FUNCTION GetMatrixFormat
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddSolverProcedure( Solver,PROCEDURE  )
!------------------------------------------------------------------------------
    TYPE(Solver_t) :: Solver
    EXTERNAL :: PROCEDURE
    INTEGER  :: PROCEDURE
!------------------------------------------------------------------------------
    INTEGER(KIND=AddrInt) :: AddrFunc
!------------------------------------------------------------------------------
    Solver % PROCEDURE = AddrFunc( PROCEDURE )
!------------------------------------------------------------------------------
  END SUBROUTINE AddSolverProcedure
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddEquation( Solver, Name,Transient )
!------------------------------------------------------------------------------
    TYPE(Solver_t), POINTER :: Solver
    LOGICAL :: Transient
    CHARACTER(LEN=*) :: Name
!------------------------------------------------------------------------------
    REAL(KIND=dp), POINTER :: Solution(:), Component(:)

    INTEGER, POINTER :: Perm(:)

    INTEGER(KIND=AddrInt) :: InitProc

    INTEGER :: MaxDGDOFs, MaxNDOFs, MaxEDOFs, MaxFDOFs, MaxBDOFs
    INTEGER :: i,j,k,l,NDeg,Nrows,nSize,n,DOFs,MatrixFormat,istat,Maxdim

    LOGICAL :: Found, BandwidthOptimize, EigAnal, ComplexFlag, &
    MultigridActive, VariableOutput, GlobalBubbles, HarmonicAnal, MGAlgebraic

    CHARACTER(LEN=MAX_NAME_LEN) :: str,eq,var_name, tmpname

    TYPE(Mesh_t),   POINTER :: NewMesh,OldMesh
    TYPE(Element_t), POINTER :: CurrentElement
    TYPE(Matrix_t), POINTER :: NewMatrix, Oldmatrix

    TYPE(Variable_t), POINTER :: Var
    TYPE(Variable_t), POINTER :: NewVariable

    REAL(KIND=dp) :: tt, CPUTime
    REAL(KIND=dp), POINTER :: freqv(:,:)

    EXTERNAL FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver
    INTEGER :: FlowSolver, HeatSolver, MagneticSolver, StressSolver, MeshSolver

    !------------------------------------------------------------------------------

    eq = ListGetString( Solver % Values, 'Equation', Found )
    IF ( Found ) THEN
      MAXdim = 0
      DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
        CurrentElement => Solver % Mesh % Elements(i)
        IF ( CheckElementEquation( CurrentModel, CurrentElement, eq ) ) THEN
          Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
        END IF
      END DO
      CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
    END IF

    str = ListGetString( Solver  % Values, 'Procedure', Found )
    IF ( Found ) THEN
      InitProc = GetProcAddr( TRIM(str)//'_Init', abort=.FALSE. )
      IF ( InitProc /= 0 ) THEN
        CALL ExecSolver( InitProc, CurrentModel, Solver, &
            Solver % dt, Transient )
      END IF
    END IF
 
    ! Computation of dofs makes only sense if it has been decleared where the solver is active
    !-----------------------------------------------------------------------------------------
    Ndeg = 0
    eq = ListGetString( Solver  % Values, 'Equation', Found )
    IF( Found ) THEN
      MaxNDOFs  = 0
      MaxDGDOFs = 0
      DO i=1,Solver % Mesh % NumberOFBulkElements
        CurrentElement => Solver % Mesh % Elements(i)
        MaxDGDOFs = MAX( MaxDGDOFs, CurrentElement % DGDOFs )
        MaxNDOFs  = MAX( MaxNDOFs,  CurrentElement % NDOFs )
      END DO
      
      MaxEDOFs = 0
      DO i=1,Solver % Mesh % NumberOFEdges 
        CurrentElement => Solver % Mesh % Edges(i)
        MaxEDOFs  = MAX( MaxEDOFs,  CurrentElement % BDOFs )
      END DO
      
      MaxFDOFs = 0
      DO i=1,Solver % Mesh % NumberOFFaces 
        CurrentElement => Solver % Mesh % Faces(i)
        MaxFDOFs  = MAX( MaxFDOFs,  CurrentElement % BDOFs )
      END DO
      
      MaxBDOFs = 0
      DO i=1,Solver % Mesh % NumberOFBulkElements
        CurrentElement => Solver % Mesh % Elements(i)
        MaxBDOFs  = MAX( MaxBDOFs,  CurrentElement % BDOFs )
      END DO
      
      GlobalBubbles = ListGetLogical( Solver % Values, 'Bubbles in Global System', Found )
      IF (.NOT.Found) GlobalBubbles=.TRUE.
      
      Ndeg = Ndeg + Solver % Mesh % NumberOfNodes 
      IF ( MaxEDOFs > 0 ) Ndeg = Ndeg + MaxEDOFs * Solver % Mesh % NumberOFEdges
      IF ( MaxFDOFs > 0 ) Ndeg = Ndeg + MaxFDOFs * Solver % Mesh % NumberOFFaces
      IF ( GlobalBubbles ) &
          Ndeg = Ndeg + MaxBDOFs * Solver % Mesh % NumberOfBulkElements
      IF ( ListGetLogical( Solver % Values, 'Discontinuous Galerkin', Found ) ) &
          Ndeg = MAX( NDeg, MaxDGDOFs * (Solver % Mesh % NumberOfBulkElements+ &
          Solver % Mesh % NumberOfBoundaryElements) )
    END IF


    ! Default order of equation
    !--------------------------
    Solver % Order = 1
    Solver % TimeOrder = 1
    
    IF ( Transient ) THEN
      str = ListGetString( Solver % Values, 'Timestepping Method',Found )
      IF ( .NOT. Found ) THEN
        str = ListGetString( CurrentModel % Simulation, 'Timestepping Method',Found )
        IF ( Found ) THEN
          CALL ListAddString( Solver % Values, 'Timestepping Method', str )
        END IF
      END IF
      
      IF ( Found ) THEN
        IF (str=='bdf') THEN
          Solver % Order = ListGetInteger( Solver % Values, &
              'BDF Order', Found, minv=1, maxv=5 )
          IF ( .NOT. Found ) THEN
            Solver % Order = ListGetInteger( CurrentModel % &
                Simulation, 'BDF Order', Found, minv=1, maxv=5 )
          END IF
          IF ( .NOT.Found ) THEN
            Solver % Order = 2
            CALL Warn( 'AddEquation', 'BDF order defaulted to 2.' )
          END IF
        ELSE IF ( str=='runge-kutta') THEN
          Solver % Order = ListGetInteger( CurrentModel % &
              Simulation, 'Runge-Kutta Order', Found, minv=2, maxv=4 )
          IF ( .NOT.Found ) Solver % Order = 2
        END IF
      ELSE
        CALL Warn( 'AddEquation', 'Time stepping method defaulted to IMPLICIT EULER' )
        CALL ListAddString( Solver % Values, 'Timestepping Method', 'Implicit Euler' )
      END IF
    END IF

    !------------------------------------------------------------------------------

    DOFs = CoordinateSystemDimension()
    IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = DOFs + 1
    
    MatrixFormat = GetMatrixFormat( CurrentModel, Name )
    
    BandwidthOptimize = ListGetLogical( Solver % Values, &
        'Optimize Bandwidth', Found )
    IF ( .NOT. Found ) BandwidthOptimize = .TRUE.
    
    VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
    IF ( .NOT. Found ) VariableOutput = .TRUE.
    
    var_name = ListGetString( Solver % Values, 'Variable', Found )
    IF ( Found ) THEN
      IF ( var_name(1:9) == '-nooutput' ) THEN
        VariableOutput = .FALSE.
        var_name(1:LEN(var_name)-10) = var_name(11:)
      END IF
    END IF

    !------------------------------------------------------------------------------
    SELECT CASE( Name )       
      !------------------------------------------------------------------------------
      
      !------------------------------------------------------------------------------
    CASE('navier-stokes')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Flow Solution')
      
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg), STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, Perm, &
          DOFs+1, MatrixFormat, BandwidthOptimize, 'Navier-Stokes', GlobalBubbles=GlobalBubbles )

      Nrows =(DOFs+1)* Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )
        
        ! First add components to the variable list separately (must be done
        ! this way for the output routines to work properly...):
        !---------------------------------------------------------------------
        Component => Solution( 1 : Nrows: DOFs+1 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 1', &
            1, Component, Perm, Output=VariableOutput )
        
        Component => Solution( 2 : Nrows: DOFs+1 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 2', &
            1, Component, Perm, Output=VariableOutput )
        
        IF ( DOFs+1 == 3 ) THEN
          Component => Solution( 3 : Nrows: DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
              1, Component, Perm, Output=VariableOutput )
        ELSE
          Component => Solution( 3 : Nrows: DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Velocity 3', &
              1, Component, Perm, Output=VariableOutput )
          
          Component => Solution( 4 : Nrows : DOFs+1 )
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,'Pressure', &
              1, Component, Perm, Output=VariableOutput )
        END IF
        
        ! Then add the thing itself:
        !---------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Flow Solution',DOFs+1,Solution,Perm, Output=VariableOutput )
        
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Flow Solution' )
        Solution = 1.0d-6
      END IF
      CALL AddSolverProcedure( Solver, FlowSolver )
      !------------------------------------------------------------------------------


      !------------------------------------------------------------------------------
    CASE('magnetic induction')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Magnetic Field')
      
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(NDeg),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Elmer Solver: Memory allocation error.' )
        END IF
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm,3, MatrixFormat, BandwidthOptimize, 'Magnetic Induction', GlobalBubbles=GlobalBubbles )
      
      Nrows = 3*Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )
        
        Component => Solution( 1 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
            'Magnetic Field 1', 1, Component, Perm,Output=VariableOutput )

        Component => Solution( 2 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
            'Magnetic Field 2', 1, Component, Perm,Output=VariableOutput )

        Component => Solution( 3 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
            'Magnetic Field 3', 1, Component, Perm,Output=VariableOutput )
        !------------------------------------------------------------------------------
        !         Then add the thing itself
        !------------------------------------------------------------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Magnetic Field',3,Solution,Perm,Output=VariableOutput )
        
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Magnetic Field' )
        
        Solution = 0.0d0
        !------------------------------------------------------------------------------
        !         Add first components to the variable list separately...
        !------------------------------------------------------------------------------
        ALLOCATE( Solution(Nrows), STAT=istat )
        
        Component => Solution( 1 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Electric Current 1', 1, Component, Perm,Output=VariableOutput )
        
        Component => Solution( 2 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Electric Current 2', 1, Component, Perm,Output=VariableOutput )
        
        Component => Solution( 3 : Nrows : 3 )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Electric Current 3', 1, Component, Perm,Output=VariableOutput )
        !------------------------------------------------------------------------------
        !         Then add the thing itself
        !------------------------------------------------------------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
            'Electric Current', 3, Solution, Perm, Output=VariableOutput )
        Solution = 0.0d0
      END IF
      CALL AddSolverProcedure( Solver, MagneticSolver )
      !------------------------------------------------------------------------------
      
      
      !------------------------------------------------------------------------------
    CASE('stress analysis')
      !------------------------------------------------------------------------------
      IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2
      
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(NDeg),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm, DOFs, MatrixFormat, BandwidthOptimize, &
          'Stress Analysis', GlobalBubbles=GlobalBubbles )
      
      Nrows = DOFs * Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF ( .NOT.ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )
        
        ! First add the components to the variable list separately:
        !----------------------------------------------------------
        Component => Solution( 1 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Displacement 1',1, Component, Perm,Output=VariableOutput )
        
        Component => Solution( 2 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
            'Displacement 2', 1, Component, Perm,Output=VariableOutput )
        
        IF ( CoordinateSystemDimension() >= 3 ) THEN
          Component => Solution( 3 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver,  &
              'Displacement 3', 1, Component, Perm, Output=VariableOutput )
        END IF
        
        ! Then add the thing itself:
        !---------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
            'Displacement',DOFs,Solution,Perm,Output=VariableOutput )
        
        Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Displacement')
        
        Solution = 0.0D0
      END IF
      CALL AddSolverProcedure( Solver, StressSolver )
      !------------------------------------------------------------------------------
      
      
      !------------------------------------------------------------------------------
    CASE('mesh update')
      !------------------------------------------------------------------------------
      IF ( CurrentCoordinateSystem() == CylindricSymmetric ) DOFs = 2
      
      Solver % Variable => VariableGet(Solver % Mesh % Variables, 'Mesh Update')
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg), STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm, DOFs, MatrixFormat, BandwidthOptimize, 'Mesh Update', GlobalBubbles=GlobalBubbles )
      IF ( .NOT. ASSOCIATED( Solver % Matrix ) )  RETURN
      
      Nrows = DOFs * Ndeg
      IF ( ASSOCIATED( Solver % Matrix ) ) Nrows = Solver % Matrix % NumberOfRows
      IF (.NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows), STAT=istat )
        
        ! First add the components to the variable list separately:
        !----------------------------------------------------------
        Component => Solution( 1 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver, &
            'Mesh Update 1',1, Component, Perm,Output=VariableOutput )
        
        Component => Solution( 2 : Nrows : DOFs )
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver, &
            'Mesh Update 2', 1, Component, Perm,Output=VariableOutput )
        
        IF ( CoordinateSystemDimension() >= 3 ) THEN
          Component => Solution( 3 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh,Solver,  &
              'Mesh Update 3', 1, Component, Perm,Output=VariableOutput )
        END IF
        
        !      Then add the thing itself...
        !------------------------------------------------------------------------------
        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
            'Mesh Update',DOFs,Solution,Perm,Output=VariableOutput )
        Solution = 0.0d0
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Mesh Update' )
      END IF
      
      Var =>  VariableGet( Solver % Mesh % Variables, 'Mesh Velocity')
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        IF ( Transient ) THEN
          ALLOCATE( Solution(Nrows), STAT=istat )
          IF ( istat /= 0 ) THEN
            CALL Fatal( 'AddEquation', 'Memory allocation error.' )
          END IF
          
          Component => Solution( 1 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, &
              Solver, 'Mesh Velocity 1',1, Component, Perm,Output=VariableOutput)
          
          Component => Solution( 2 : Nrows : DOFs )
          CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, &
              Solver, 'Mesh Velocity 2', 1, Component, Perm,Output=VariableOutput)
          
          IF ( CoordinateSystemDimension() >= 3 ) THEN
            Component => Solution( 3 : Nrows : DOFs )
            CALL VariableAdd(Solver % Mesh % Variables,Solver % Mesh, &
                Solver, 'Mesh Velocity 3', 1, Component, Perm,Output=VariableOutput)
          END IF
          
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh,Solver,&
              'Mesh Velocity',DOFs,Solution,Perm,Output=VariableOutput )
          
          Solution = 0.0D0
        END IF
      END IF
      CALL AddSolverProcedure( Solver, MeshSolver )
      !------------------------------------------------------------------------------
      !------------------------------------------------------------------------------

      
      !------------------------------------------------------------------------------
    CASE('heat equation')
      !------------------------------------------------------------------------------
      Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )
      
      IF ( ASSOCIATED( Solver % Variable ) ) THEN
        Perm => Solver % Variable % Perm
      ELSE
        ALLOCATE( Perm(Ndeg),STAT=istat )
      END IF
      
      eq = ListGetString( CurrentModel % Simulation, 'Gebhardt Factors',Found )
      IF ( Found ) THEN
        CALL LoadGebhardtFactors( Solver % Mesh,eq )
      ELSE
        CALL RadiationFactors( Solver, .TRUE.)
      END IF
      
      Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
          Perm,1, MatrixFormat, BandwidthOptimize, &
          'Heat Equation', GlobalBubbles=GlobalBubbles)
      
      Nrows = Ndeg
      IF (ASSOCIATED( Solver % Matrix)) Nrows=Solver % Matrix % NumberOfRows
      IF ( .NOT. ASSOCIATED( Solver % Variable ) ) THEN
        ALLOCATE( Solution(Nrows),STAT=istat )
        IF ( istat /= 0 ) THEN
          CALL Fatal( 'AddEquation', 'Memory allocation error.' )
        END IF
        
        CALL VariableAdd( Solver % Mesh % Variables,Solver % Mesh, Solver,&
            'Temperature',1, Solution, Perm, Output=VariableOutput )
        
        Solver % Variable => VariableGet( Solver % Mesh % Variables, 'Temperature' )
        Solution = 0.0d0
      END IF
      CALL AddSolverProcedure( Solver, HeatSolver )
      !------------------------------------------------------------------------------

      !------------------------------------------------------------------------------
    CASE DEFAULT

      !------------------------------------------------------------------------------
      str = ListGetString( Solver % Values, 'Procedure', Found )
      IF(Found) Solver % PROCEDURE = GetProcAddr(str)
      
      Solver % TimeOrder = 0
      ALLOCATE( Solver % Variable )
      Solver % Variable % Name = ''
      Solver % Variable % NameLen = 0
      Solver % Variable % Norm = 0.0d0
      NULLIFY( Solver % Variable % Values )
      NULLIFY( Solver % Matrix )
     
      
      ! Check if a variable for the solver exists
      ! It may be a normal field variable or a global (0D) variable
      !------------------------------------------------------------------------
      var_name = ListGetString( Solver % Values, 'Variable', Found )
      IF ( Found ) THEN
        DOFs = ListGetInteger( Solver % Values, 'Variable DOFs', Found, minv=1 )
        IF ( .NOT. Found ) THEN
          j = 0
          DOFs = 0
          DO WHILE( .TRUE. )
            i = INDEX( var_name(j+1:), ':' ) + j
            IF ( i<=j ) EXIT
            READ( var_name(i+1:),'(i1)' ) k
            DOFs = DOFs + k
            j = i + 1
          END DO
        END IF
        
        VariableOutput = ListGetLogical( Solver % Values, 'Variable Output', Found )
        IF ( .NOT. Found ) VariableOutput = .TRUE.
        
        DO WHILE( var_name(1:1) == '-' )
          IF ( var_name(1:10) == '-nooutput ' ) THEN
            VariableOutput = .FALSE.
            var_name(1:LEN(var_name)-10) = var_name(11:)
          END IF
          
          IF ( var_name(1:6) == '-dofs ' ) THEN
            READ( var_name(7:), * ) DOFs
            i = 7
            j = LEN_TRIM( var_name )
            DO WHILE( var_name(i:i) /= ' '  )
              i = i + 1
              IF ( i > j ) EXIT
            END DO
            var_name(1:LEN(var_name)-i) = var_name(i+1:)
          END IF
        END DO
        IF ( DOFs == 0 ) DOFs = 1
        
        n = LEN_TRIM(var_name)
        Solver % Variable => VariableGet( Solver % Mesh % Variables,var_name(1:n) )
        

        ! If the variable is a field variable create a permutation and matrix related to it
        !----------------------------------------------------------------------------------
        eq = ListGetString( Solver  % Values, 'Equation', Found )
        IF( Found ) THEN
          IF ( ASSOCIATED( Solver % Variable ) ) THEN
            Perm => Solver % Variable % Perm
          ELSE
            ALLOCATE( Perm(Ndeg) )
          END IF
          
          Solver % Matrix => CreateMatrix( CurrentModel, Solver, Solver % Mesh, &
              Perm, DOFs, MatrixFormat, BandwidthOptimize, eq(1:LEN_TRIM(eq)), &
              ListGetLogical( Solver % Values, &
              'Discontinuous Galerkin', Found ), GlobalBubbles=GlobalBubbles )
          
          Nrows = DOFs * Ndeg
          IF (ASSOCIATED(Solver % Matrix)) Nrows = Solver % Matrix % NumberOfRows
          
          IF (.NOT.ASSOCIATED(Solver % Variable)) THEN
            ALLOCATE( Solution( Nrows ) )
            Solution = 0.0d0
            
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
                var_name(1:n), DOFs, Solution, Perm, Output=VariableOutput )
            
            Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )
            
            IF ( DOFs > 1 ) THEN
              DO i=1,DOFs
                tmpname = ComponentName( var_name(1:n), i )
                Component => Solution( i:Nrows-DOFs+i:DOFs )
                CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                    tmpname, 1, Component, Perm, Output=VariableOutput )
              END DO
            END IF
          END IF
        ELSE IF( ListGetLogical(Solver % Values,'Global Variable',Found) ) THEN
          ALLOCATE( Solution( DOFs ) )
          Solution = 0.0_dp
          
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver, &
              var_name(1:n), DOFs, Solution )
          Solver % Variable => VariableGet( Solver % Mesh % Variables, var_name(1:n) )
          IF( DOFs > 1 ) THEN
            DO i=1,DOFs
              tmpname = ComponentName( var_name(1:n), i )
              Component => Solution( i:i )
              CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                  tmpname, 1, Component )
            END DO
          END IF
        ELSE            
          CALL Warn('AddEquation','Solver has a variable but is not associated to any equation')
        END IF
      END IF


      !------------------------------------------------------------------------------
    END SELECT

    l = 1
    DO WHILE( .TRUE. )
      str = ComponentName( 'exported variable', l )
      var_name = ListGetString( Solver % Values, str, Found )
      
      IF ( Found ) THEN
        str = TRIM( ComponentName( 'exported variable', l ) ) // ' Output'
        VariableOutput = ListGetLogical( Solver % Values, str, Found )
        IF ( .NOT. Found ) VariableOutput = .TRUE.
        
        str = TRIM( ComponentName( 'exported variable', l ) ) // ' DOFs'
        DOFs = ListGetInteger( Solver % Values, str, Found )
        IF ( .NOT. Found ) THEN
          j = 0
          DOFs = 0
          DO WHILE( .TRUE. )
            i = INDEX( var_name(j+1:), ':' ) + j
            IF ( i<=j ) EXIT
            READ( var_name(i+1:),'(i1)' ) k
            DOFs = DOFs + k
            j = i + 1
          END DO
        END IF

        VariableOutput = .TRUE.
        DO WHILE( var_name(1:1) == '-' )
          IF ( var_name(1:10) == '-nooutput ' ) THEN
            VariableOutput = .FALSE.
            var_name(1:LEN(var_name)-10) = var_name(11:)
          END IF
          
          IF ( var_name(1:6) == '-dofs ' ) THEN
            READ( var_name(7:), * ) DOFs 
            j = LEN_TRIM( var_name )
            k = 7
            DO WHILE( var_name(k:k) /= ' '  )
              k = k + 1
              IF ( k > j ) EXIT
            END DO
            var_name(1:LEN(var_name)-(k+2)) = var_name(k+1:)
          END IF
        END DO
        IF ( DOFs == 0 ) DOFs = 1
        
        NewVariable => VariableGet( Solver % Mesh % Variables, Var_name )
        
        IF ( .NOT. ASSOCIATED(NewVariable) ) THEN
          nSize = DOFs * SIZE(Solver % Variable % Values) / Solver % Variable % DOFs
          ALLOCATE( Solution(nSize) )
          Solution = 0.0d0
          Perm => Solver % Variable % Perm
          IF( ASSOCIATED(Perm) ) THEN
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                var_name, DOFs, Solution, Solver % Variable % Perm,Output=VariableOutput )
          ELSE          
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                var_name, DOFs, Solution )
          END IF

          IF ( DOFs > 1 ) THEN
            n = LEN_TRIM( var_name )
            DO j=1,DOFs
              tmpname = ComponentName( var_name(1:n), j )
              Component => Solution( j:nSize-DOFs+j:DOFs )
              IF( ASSOCIATED(Perm) ) THEN
                CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                    tmpname, 1, Component, Perm, Output=VariableOutput )
              ELSE
                CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                    tmpname, 1, Component )               
              END IF
            END DO
          END IF
        END IF
      ELSE
        EXIT
      END IF
      l = l + 1
    END DO

    IF ( ListGetLogical( Solver % Values,'Calculate Loads', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Loads'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        ALLOCATE( Solution(SIZE(Solver % Variable % Values)) )
        DOFs = Solver % Variable % DOFs
        Solution = 0.0d0
        Perm => Solver % Variable % Perm

        CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
            var_name, Solver % Variable % DOFs, Solution, &
            Solver % Variable % Perm, Output=VariableOutput )

        IF ( DOFs > 1 ) THEN
          n = LEN_TRIM( Var_name )
          DO j=1,DOFs
            tmpname = ComponentName( var_name(1:n), j )
            Component => Solution( j:nRows-DOFs+j:DOFs )
            CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
                tmpname, 1, Component, Perm, Output=VariableOutput )
          END DO
        END IF
      END IF
    END IF

    !------------------------------------------------------------------------------
    ! Add computation of the weights resulting from Galerkin integration
    
    IF ( ListGetLogical( Solver % Values,'Calculate Weights', Found ) ) THEN
      Var_name = GetVarName(Solver % Variable) // ' Weights'
      Var => VariableGet( Solver % Mesh % Variables, var_name )
      IF ( .NOT. ASSOCIATED(Var) ) THEN
        Perm => Solver % Variable % Perm
        IF( ASSOCIATED( Perm ) ) THEN
          ALLOCATE( Solution(SIZE(Solver % Variable % Perm)) )
          Solution = 0.0d0        
          CALL VariableAdd( Solver % Mesh % Variables, Solver % Mesh, Solver,&
              var_name, 1, Solution, &
              Solver % Variable % Perm, Output=VariableOutput )
        END IF
      END IF
    END IF
    !------------------------------------------------------------------------------

    Solver % NOFEigenValues = 0
    !   NULLIFY( Solver % Variable % PrevValues )
    !   NULLIFY( Solver % Variable % EigenValues )
    !   NULLIFY( Solver % Variable % EigenVectors )

    Solver % DoneTime  = 0
    Solver % MultiGridLevel = 1
    Solver % MultiGridTotal = 0
    Solver % MultiGridSolver = .FALSE.
    Solver % MultiGridEqualSplit = .FALSE.
    !------------------------------------------------------------------------------
    !
    ! Check for special solvers, to be executed only
    ! at a certain points in simulation:
    ! ----------------------------------------------

    Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS

    SELECT CASE( ListGetString( Solver % Values, 'Exec Solver', Found )  )
      CASE( 'never' )
      Solver % SolverExecWhen = SOLVER_EXEC_NEVER
      CASE( 'always' )
      Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
      CASE( 'after simulation', 'after all' )
      Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
      CASE( 'before simulation', 'before all' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
      CASE( 'before timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
      CASE( 'after timestep' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
      CASE( 'before saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
      CASE( 'after saving' )
         Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
      CASE DEFAULT
         Solver % SolverExecWhen = SOLVER_EXEC_ALWAYS
    END SELECT


    IF ( ListGetLogical( Solver % Values, 'Before All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After All', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'After Simulation', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_ALL
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'After Timestep', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_TIME
    ELSE IF ( ListGetLogical( Solver % Values, 'Before Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AHEAD_SAVE
    ELSE IF ( ListGetLogical( Solver % Values, 'After Saving', Found ) ) THEN
       Solver % SolverExecWhen = SOLVER_EXEC_AFTER_SAVE
    END IF

    Solver % LinAfterProc  = 0
    Solver % LinBeforeProc = 0
    str = ListGetString( Solver  % Values, 'Before Linsolve', Found )
    IF ( Found ) Solver % LinBeforeProc = GetProcAddr( str )

    str = ListGetString( Solver  % Values, 'After Linsolve', Found )
    IF ( Found ) Solver % LinAfterProc = GetProcAddr( str )


!------------------------------------------------------------------------------
    IF ( .NOT. ASSOCIATED( Solver % Variable % Values ) ) RETURN
!------------------------------------------------------------------------------

    HarmonicAnal = ListGetLogical( Solver % Values, 'Harmonic Analysis', Found )

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
       ALLOCATE( Solver % Matrix % RHS(Solver % Matrix % NumberOFRows) )
       Solver % Matrix % RHS = 0.0d0

       Solver % Matrix % RHS_im => NULL()
       IF ( HarmonicAnal ) THEN
         ALLOCATE( Solver % Matrix % RHS_im(Solver % Matrix % NumberOFRows) )
         Solver % Matrix % RHS_im = 0.0d0
       END IF
    END IF
!------------------------------------------------------------------------------

    EigAnal = ListGetLogical( Solver % Values, 'Eigen Analysis', Found )

    IF ( Transient .AND. .NOT. EigAnal .AND. .NOT. HarmonicAnal ) THEN
       k = ListGetInteger( Solver % Values, 'Time Derivative Order', Found, &
                  minv=0, maxv=2 )
       Solver % TimeOrder = 1
       IF ( Found ) Solver % TimeOrder = MIN(MAX(1,k),2)

       IF ( ASSOCIATED( Solver % Matrix ) ) THEN
          ALLOCATE( Solver % Matrix % Force(Solver % Matrix % NumberOFRows, &
                          Solver % TimeOrder+1) )
          Solver % Matrix % Force = 0.0d0
       END IF

       IF ( .NOT. ASSOCIATED( Solver % Variable % PrevValues ) ) THEN
          IF ( Solver % TimeOrder == 2 ) THEN
             ALLOCATE( Solver % Variable % PrevValues( &
              SIZE(Solver % Variable % Values),5) )
          ELSE IF ( Solver % Order > Solver % TimeOrder ) THEN
             ALLOCATE(Solver % Variable % PrevValues( &
                   SIZE(Solver % Variable % Values), Solver % Order))
          ELSE
             ALLOCATE(Solver % Variable % PrevValues( &
                   SIZE(Solver % Variable % Values), Solver % TimeOrder))
          END IF
          Solver % Variable % PrevValues = 0.0d0

          IF ( Solver % Variable % DOFs > 1 ) THEN
             IF ( Solver % Variable % Name == 'flow solution' ) THEN
               DO k=1,Solver % Variable % DOFs-1
                  str = 'Velocity ' // CHAR(k+ICHAR('0'))
                  Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                  Var % PrevValues =>  &
                      Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
               END DO
               Var => VariableGet( Solver % Mesh % Variables, 'Pressure', .TRUE. )
               Var % PrevValues =>  &
                     Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
             ELSE
               DO k=1,Solver % Variable % DOFs
                  str = ComponentName( Solver % Variable % Name, k )
                  Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                  Var % PrevValues =>  &
                      Solver % Variable % PrevValues(k::Solver % Variable % DOFs,:)
               END DO
             END IF
          END IF
       END IF
    ELSE
       Solver % TimeOrder = 0
       IF ( EigAnal ) THEN
          ComplexFlag = ListGetLogical( Solver % Values,  'Eigen System Complex', Found )
          IF ( .NOT. Found ) ComplexFlag = .FALSE.

          n = ListGetInteger( Solver % Values,  'Eigen System Values', Found )
          IF ( Found .AND. n > 0 ) THEN
             Solver % NOFEigenValues = n
             IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
               ALLOCATE( Solver % Variable % EigenValues(n) )
               ALLOCATE( Solver % Variable % EigenVectors(n, &
                    SIZE( Solver % Variable % Values ) ) )

               Solver % Variable % EigenValues  = 0.0d0
               Solver % Variable % EigenVectors = 0.0d0

               DO k=1,Solver % Variable % DOFs
                 str = ComponentName( Solver % Variable % Name, k )
                 Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                 IF ( ASSOCIATED( Var ) ) THEN
                    Var % EigenValues => Solver % Variable % EigenValues
                    IF ( ComplexFlag ) THEN
                       Var % EigenVectors => Solver % Variable % EigenVectors
                    ELSE
                       Var % EigenVectors =>  & 
                          Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs )
                    END IF
                 END IF
               END DO
             END IF
             ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
             Solver % Matrix % MassValues = 0.0d0
          END IF
       ELSE IF ( HarmonicAnal ) THEN
          freqv => ListGetConstRealArray( Solver % Values, 'Frequency', Found )
          IF ( Found ) THEN
             n = SIZE(Freqv,1)
             Solver % NOFEigenValues = n
             IF ( .NOT. ASSOCIATED( Solver % Variable % EigenValues ) ) THEN
               ALLOCATE( Solver % Variable % EigenValues(n) )
               ALLOCATE( Solver % Variable % EigenVectors(n, &
                    SIZE( Solver % Variable % Values ) ) )

               Solver % Variable % EigenValues  = 0.0d0
               Solver % Variable % EigenVectors = 0.0d0

               DO k=1,Solver % Variable % DOFs
                 str = ComponentName( Solver % Variable % Name, k )
                 Var => VariableGet( Solver % Mesh % Variables, str, .TRUE. )
                 IF ( ASSOCIATED( Var ) ) THEN
                    Var % EigenValues => Solver % Variable % EigenValues
                    Var % EigenVectors => &
                        Solver % Variable % EigenVectors(:,k::Solver % Variable % DOFs)
                 END IF
               END DO
             END IF
             ALLOCATE( Solver % Matrix % MassValues(SIZE(Solver % Matrix % Values)) )
             Solver % Matrix % MassValues = 0.0d0
          ELSE
             CALL Fatal( 'AddEquation', 'Frequency must be given for harmonic analysis.' )
          END IF
       END IF
    END IF

!------------------------------------------------------------------------------

    IF ( ASSOCIATED( Solver % Matrix ) ) THEN
       Solver % Matrix % Symmetric = ListGetLogical( Solver % Values, &
                  'Linear System Symmetric', Found )

       Solver % Matrix % Lumped = ListGetLogical( Solver % Values, &
                  'Lumped Mass Matrix', Found )

       MultigridActive = &
         ListGetString( Solver % Values, 'Linear System Solver', Found ) == 'multigrid' .OR. &
         ListGetString( Solver % Values, 'Linear System Preconditioning', Found ) == 'multigrid'


!      Check for multigrid solver:
!      ---------------------------
       IF ( MultigridActive ) THEN

          str = ListGetString( Solver % Values,'MG Method',Found) 
          IF( Found ) THEN
            MGAlgebraic = ( str == 'algebraic' ) .OR. ( str == 'cluster')
          ELSE	    
            MGAlgebraic = ListGetLogical( Solver % Values, 'MG Algebraic', Found ) &
	       .OR. ListGetLogical( Solver % Values, 'MG Cluster', Found )
          END IF

          Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
                        'MG Levels', Found, minv=1 )

          IF ( .NOT. Found ) THEN
             Solver % MultiGridTotal = ListGetInteger( Solver % Values, &
                     'Multigrid Levels', Found, minv=1 )
          END IF
          IF ( .NOT. Found ) THEN
	    IF( MGAlgebraic ) THEN 
	      Solver % MultiGridTotal = 10
            ELSE
	      Solver % MultiGridTotal = 3	    
	    END IF
          END IF

!         Check if h/2 splitting of mesh requested:
!         ------------------------------------------
          Solver % MultiGridEqualSplit = ListGetLogical( &
             Solver % Values, 'MG Equal Split', Found )

          IF ( Solver % MultiGridEqualSplit ) THEN
             CALL ParallelInitMatrix( Solver, Solver % Matrix )
             Solver % MultiGridLevel = 1
             DO WHILE( Solver % MultiGridLevel < Solver % MultiGridTotal )
                IF ( ASSOCIATED( Solver % Mesh % Child ) ) THEN
                   NewMesh => Solver % Mesh % Child

                   OldMesh   => Solver % Mesh
                   OldMatrix => Solver % Matrix

                   CALL UpdateSolverMesh( Solver, NewMesh )
                   Solver % Mesh % Changed = .FALSE.
                ELSE
                   NewMesh => SplitMeshEqual( Solver % Mesh )
                   NewMesh % Next => CurrentModel % Meshes
                   CurrentModel % Meshes => NewMesh

                   OldMesh   => Solver % Mesh
                   OldMatrix => Solver % Matrix

                   CALL UpdateSolverMesh( Solver, NewMesh )
                   Solver % Mesh % Changed = .FALSE.

                   NewMesh % Parent => OldMesh
                   OldMesh % Child  => NewMesh
                   NewMesh % Name = OldMesh % Name
                END IF

                NewMatrix => Solver % Matrix
                NewMatrix % Parent => OldMatrix
                OldMatrix % Child  => NewMatrix
                CALL ParallelInitMatrix( Solver, Solver % Matrix )
                Solver % MultiGridLevel = Solver % MultiGridLevel + 1
             END DO
          END IF
          CALL MeshStabParams( Solver % Mesh )
          Solver % MultiGridSolver = ListGetString(Solver % Values, &
             'Linear System Solver', Found ) == 'multigrid'
          Solver % MultiGridLevel  = Solver % MultiGridTotal
       END IF
    END IF

!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE AddEquation
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE SolveEquations( Model, dt, TransientSimulation, &
      CoupledMinIter, CoupledMaxIter, SteadyStateReached )
!------------------------------------------------------------------------------
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    INTEGER :: CoupledMinIter, CoupledMaxIter
    LOGICAL :: TransientSimulation, SteadyStateReached
!------------------------------------------------------------------------------
    REAL(KIND=dp) :: RelativeChange, Tolerance, PrevDT = 0.0d0, Relaxation
    INTEGER :: i,j,k,l,n,ierr,istat
    LOGICAL :: Found, Stat, AbsNorm, Scanning, Convergence, RungeKutta, MeActive, &
	Relax, NeedSol
    LOGICAL, ALLOCATABLE :: DoneThis(:)
    TYPE(Solver_t), POINTER :: Solver
    TYPE(Mesh_t),   POINTER :: Mesh
    CHARACTER(LEN=max_name_len) :: When
    TYPE(Variable_t), POINTER :: IterV
    REAL(KIND=dp), POINTER :: steadyIt,nonlnIt
    REAL(KIND=dp), ALLOCATABLE :: k1(:), k2(:), k3(:), k4(:), Values0(:)
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!   Intialize equation solvers for new timestep
!------------------------------------------------------------------------------
    Scanning = &
      ListGetString( CurrentModel % Simulation, 'Simulation Type', Found ) == 'scanning'

    IF ( TransientSimulation ) THEN
       DO k=1,Model % NumberOfSolvers
          Solver => Model % Solvers(k)
          IF ( Solver % PROCEDURE /= 0 ) CALL InitializeTimestep( Solver )
       END DO
    END IF	

    IF( TransientSimulation .OR. Scanning ) THEN
       IterV => VariableGet(Model % Solvers(1) % Mesh % Variables, 'coupled iter')
       steadyIt => IterV % Values(1)
    END IF
!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      when  = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF ( Found ) THEN
         IF ( When == 'before timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AHEAD_TIME ) THEN
            CALL SolverActivate( Model,Solver,dt,TransientSimulation )
            CALL ParallelBarrier
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------

    ALLOCATE( DoneThis( Model % NumberOfSolvers ) )

    IF ( PrevDT == 0.0d0 ) PrevDT = dt
!------------------------------------------------------------------------------
    DO i=1,CoupledMaxIter
       IF ( TransientSimulation .OR. Scanning ) THEN
          CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Info( 'SolveEquations', Message, Level=3 )
          CALL Info( 'SolveEquations', '-------------------------------------', Level=3 )

          steadyIt = i
       END IF

       DoneThis = .FALSE.

!      Initialize the mesh output flag to FALSE here, reactivated
!      later for meshes connected to active solvers.
!      ----------------------------------------------------------
       Mesh => Model % Meshes
       DO WHILE( ASSOCIATED( Mesh ) )
          Mesh % OutputActive = .FALSE.
          Mesh => Mesh % Next
       END DO
!------------------------------------------------------------------------------
!      Go trough number of solvers (heat,laminar or turbulent flow, etc...)
!------------------------------------------------------------------------------
       DO k=1,Model % NumberOfSolvers
!------------------------------------------------------------------------------

          Solver => Model % Solvers(k)
          IF ( Solver % PROCEDURE == 0 ) THEN

!!!!!!!!!!!! This is still experimental
             IF( ListGetLogical(Solver % Values,'Generic Solver',Found) ) THEN 
                CALL GenericSolver( Model, Solver, dt, TransientSimulation )
             END IF

             DoneThis(k) = .TRUE.
             CYCLE
          END IF

          When = ListGetString( Solver % Values, 'Exec Solver', Found )
          IF ( Found ) THEN
             IF ( When /= 'always' ) THEN
                DoneThis(k) = .TRUE.
                CYCLE
             END IF
          ELSE
            IF ( Solver % SolverExecWhen /= SOLVER_EXEC_ALWAYS ) THEN
               DoneThis(k) = .TRUE.
               CYCLE
            END IF
          END IF
!------------------------------------------------------------------------------

          RungeKutta = .FALSE.
          IF ( TransientSimulation .AND. Solver % TimeOrder == 1 ) THEN
             RungeKutta = ListGetString( Solver % Values, &
                    'Timestepping Method', Found ) == 'runge-kutta'
          END IF

          n = 0
          IF ( ASSOCIATED(Solver % Variable) ) THEN
            IF ( ASSOCIATED(Solver % Variable % Values) ) &
              n = SIZE(Solver % Variable % Values)
            Solver % Variable % PrevNorm = Solver % Variable % Norm
          END IF

!------------------------------------------------------------------------------
          Relaxation = ListGetConstReal( Solver % Values, &
              'Steady State Relaxation Factor', Relax )
          Relax = Relax .AND. (Relaxation /= 1.0d0)

          NeedSol = ( ListGetString( Solver % Values, &
              'Steady State Convergence Measure', Stat ) /= 'norm')  
          NeedSol = NeedSol .AND. Stat

          IF ( ( Relax .OR. NeedSol ) .AND. n>0 ) THEN
            Stat = ASSOCIATED(Solver % Variable % SteadyValues)
            IF(Stat .AND. SIZE(Solver % Variable % SteadyValues) /= n) THEN
              DEALLOCATE(Solver % Variable % SteadyValues)
              Stat = .FALSE.
            END IF
            IF(.NOT. Stat) THEN
              ALLOCATE( Solver % Variable % SteadyValues(n), STAT=istat ) 
              IF ( istat /= 0 ) CALL Fatal( 'SolveEquations', 'Memory allocation error.' )
            END IF
            Solver % Variable % SteadyValues(1:n) = Solver % Variable % Values(1:n)
          END IF


          IF ( RungeKutta .AND. n>0 ) THEN

            SELECT CASE( Solver % Order )
            CASE(2)
              ALLOCATE( k1(n), k2(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k2 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                  ( k1 + k2 ) / 2
              DEALLOCATE( k1, k2 )


            CASE DEFAULT
              ALLOCATE( k1(n), k2(n), k3(n), k4(n) )

              k1 = Solver % Variable % PrevValues(:,1)-Solver % Variable % PrevValues(:,2)
              k1 = dt * k1 / PrevDT
              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k1/2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k2 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k2
              CALL SolverActivate( Model,Solver,dt/2,TransientSimulation )
              k3 = 2*(Solver % Variable % Values - Solver % Variable % PrevValues(:,1))

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + k3
              CALL SolverActivate( Model,Solver,dt,TransientSimulation )
              k4 = Solver % Variable % Values - Solver % Variable % PrevValues(:,1)

              Solver % Variable % Values = Solver % Variable % PrevValues(:,1) + &
                                ( k1 + 2*k2 + 2*k3 + k4 ) / 6
              DEALLOCATE( k1, k2, k3, k4 )
            END SELECT
            Solver % Variable % Norm = &
                   ComputeNorm(Solver, n, Solver % Variable % Values)
           ELSE
             CALL SolverActivate(Model,Solver,dt,TransientSimulation)
           END IF
!------------------------------------------------------------------------------
!         check for coupled system convergence
!------------------------------------------------------------------------------

          IF ( i >= CoupledMinIter .OR. .NOT. TransientSimulation ) THEN
             IF ( i /= CoupledMaxIter .OR. .NOT. TransientSimulation ) THEN

               IF ( ParEnv % PEs>1 ) THEN
                 IF ( ParEnv % Active(ParEnv % MyPE+1) ) &
                   CALL ComputeChange(Solver,.TRUE., n)
               ELSE
                 CALL ComputeChange(Solver,.TRUE., n)
               END IF
               RelativeChange = Solver % Variable % SteadyChange	
               Tolerance = ListGetConstReal( Solver % Values,   &
                   'Steady State Convergence Tolerance', Found ) 
               
               IF ( Found ) THEN
                 DoneThis(k) = (RelativeChange < Tolerance)
               ELSE
                 DoneThis(k) = .TRUE.
               END IF
             END IF
	  END IF 

          CALL ParallelAllReduceAnd( DoneThis(k) )
          IF( ALL(DoneThis) ) EXIT
!------------------------------------------------------------------------------
       END DO
!------------------------------------------------------------------------------
       Model % Mesh % Changed = .FALSE.
       IF ( ALL(DoneThis) ) EXIT
    END DO
    PrevDT = dt

    IF ( TransientSimulation .AND. .NOT. ALL(DoneThis) ) THEN
       IF ( ListGetLogical( Model % Simulation,  &
               'Coupled System Abort Not Converged', Found ) ) THEN
          CALL Error( 'SolveEquations', ' ' )
          WRITE( Message, * ) 'Coupled system iteration: ', i
          CALL Error( 'SolveEquations', Message )
          CALL Fatal( 'SolveEquations', ' ' )
       ELSE
!         CALL Error( 'SolveEquations', ' ' )
!         WRITE( Message, * ) 'Coupled system iteration: ', i
!         CALL Error( 'SolveEquations', Message )
!         CALL Error( 'SolveEquations', ' ' )
       END IF
    END IF

!------------------------------------------------------------------------------

    DO k=1,Model % NumberOfSolvers
      Solver => Model % Solvers(k)
      IF ( Solver % PROCEDURE==0 ) CYCLE

      When = ListGetString( Solver % Values, 'Exec Solver', Found )
      IF (  Found ) THEN
         IF ( When == 'after timestep' ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      ELSE
         IF ( Solver % SolverExecWhen == SOLVER_EXEC_AFTER_TIME ) THEN
           CALL SolverActivate( Model,Solver,dt,TransientSimulation )
           CALL ParallelBarrier
         END IF
      END IF
    END DO

!------------------------------------------------------------------------------
    IF ( .NOT.TransientSimulation ) SteadyStateReached = ALL(DoneThis)
!------------------------------------------------------------------------------
    DEALLOCATE( DoneThis )
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  END SUBROUTINE SolveEquations
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE GenericSolver( Model, Solver, dt, Transient )
!------------------------------------------------------------------------------
!  
! Provide assembly loop and solution of linear and nonlinear systems
    
    USE DefUtils
    
    IMPLICIT NONE
!------------------------------------------------------------------------------
    TYPE(Solver_t), TARGET :: Solver
    TYPE(Model_t) :: Model
    REAL(KIND=dp) :: dt
    LOGICAL :: Transient
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------
    TYPE(Variable_t), POINTER :: Var
    TYPE(Element_t),POINTER :: Element
    INTEGER :: i,j,k,l,t,n,nd,NoIterations,iter,istat
    REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), DAMP(:,:), MASS(:,:), FORCE(:)
    CHARACTER(LEN=MAX_NAME_LEN) :: ProcName
    LOGICAL :: GotIt, GotIt2, GotProc, BulkMode, Visited = .FALSE., &
        ThisConstraint
    INTEGER(KIND=AddrInt) :: ProcPntr    
    INTEGER :: Row, Col, ColDofs, RowDofs, ColInd0, RowInd0, MaxDofs, &
         ColVar, RowVar, Nrow, Ncol, NoVar, NoCons, TotSize, ConDofs, OffSet(20), &
         VarSizes(20), VarDofs(20)
    INTEGER :: ElementsFirst, ElementsLast, bf_id, bc_id
    INTEGER, POINTER :: ColPerm(:), RowPerm(:), ColInds(:), RowInds(:), DirPerm(:)
    REAL(KIND=dp), POINTER :: ConsValues(:)
    REAL(KIND=dp) :: NonlinearTol, Norm, ConsValue, ConsVolume
    CHARACTER(LEN=max_name_len) :: str, VarName, ColName, RowName, ConsType
    LOGICAL :: Coupling, Equality, AssemblySymmetric, AssemblyAntisymmetric
    INTEGER, POINTER :: Rows(:),Cols(:),Diag(:),Indexes(:),AllPerm(:)
    TYPE(ListMatrix_t), POINTER :: Alist(:) => NULL()
    REAL(KIND=dp), POINTER :: ForceVector(:),AllValues(:)
    LOGICAL, POINTER :: AllDir(:)
    TYPE (Matrix_t), POINTER :: Amat
    INTEGER, POINTER :: VarInds(:)

    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(ValueList_t), POINTER :: SolverParams

    INTERFACE 
      SUBROUTINE ExecLocalAssembly( Proc, Model, Solver, dt, Transient, &
          M, D, S, F, Element, Nrow, Ncol )
        USE Types
        INTEGER(KIND=AddrInt) :: Proc
        TYPE(Model_t)   :: Model
        TYPE(Solver_t)  :: Solver
        REAL(KIND=dp)   :: dt
        LOGICAL :: Transient
        REAL(KIND=dp) :: S(:,:), D(:,:), M(:,:), F(:)
        TYPE(Element_t) :: Element
        INTEGER :: Nrow, Ncol
      END SUBROUTINE ExecLocalAssembly
    END INTERFACE
    
    SAVE Visited 
    
    CALL Info('GenericSolver','---------------------------------------',Level=5)
    CALL Info('GenericSolver','Solving a Generic equation',Level=5)
    CALL Info('GenericSolver','---------------------------------------',Level=5)


!!!!!!!!!! This should be done externally when routine is taken into proper use

    Model % Solver => Solver
    Mesh => GetMesh()
    SolverParams => GetSolverParams()

!------------------------------------------------------------------------------
! Check out which variables the coupled model includes
! and compure size information related to the new coupled dof.
!------------------------------------------------------------------------------

    !----------------------------------------------------------------------------
    ! Currently the list of active variables and their permutation vectors must be
    ! provided using other solvers for initiazalition. This could be allocated 
    ! internally using the Variable = AllDofs[VectorDof:3 ScalarDof:1] system
    !--------------------------------------------------------------------------
    Offset = 0
    VarSizes = 0    
    NoVar = 0
    NoCons = 0
    VarDofs = 0

    DO i = 1,9
      WRITE (str,'(A,I2)') 'Variable',i
      VarName = ListGetString( SolverParams, TRIM(str), GotIt )
      IF(.NOT. GotIt) EXIT
      Var => VariableGet( Mesh % Variables, TRIM(VarName) )
      IF(.NOT. ASSOCIATED( Var )) EXIT 
      
      NoVar = NoVar + 1
      VarDofs(NoVar) = Var % Dofs
      VarSizes(NoVar) = SIZE( Var % Values )
      Offset(NoVar+1) = Offset(NoVar) + VarSizes(NoVar)
    END DO


    !------------------------------------------------------------------------------------
    ! Here is a hack for taking constraints into account where dofs are created on-the-fly
    ! might be better to create special solvers somewhere else.
    ! The size of constraint is deduced directly from its type.
    !-------------------------------------------------------------------------------------
    DO i = 1,9
      WRITE (str,'(A,I2)') 'Constraint',i
      VarName = ListGetString( SolverParams, TRIM(str), GotIt )
      IF(.NOT. GotIt) EXIT
      
      NoCons = NoCons + 1      
      
      WRITE (str,'(A,I2,A)') 'Constraint',i,' Type'
      ConsType = ListGetString( SolverParams,TRIM(str))
           
      SELECT CASE( ConsType )

        CASE('integral')
          ConDofs = 1
          
        CASE('floating')
          ConDofs = 1

        CASE('equality')
          ConDofs = 0

        CASE DEFAULT          
          CALL Warn('GenericSolver','Generic constraint does not really work yet')
          WRITE (str,'(A,I2,A)') 'Constraint',i,' DOFs'
          ConDofs = ListGetInteger( SolverParams, str)

      END SELECT

      ! Create the constrained variables for possible other use
      !-----------------------------------------------------------
      IF( ConDofs > 0 ) THEN
        Var => VariableGet( Mesh % Variables, VarName )
        IF( .NOT. ASSOCIATED(Var) ) THEN
          ALLOCATE(ConsValues(ConDofs))
          CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
            VarName, ConDofs, ConsValues, Output = .FALSE. )          
          Var => VariableGet( Mesh % Variables, VarName )         
        END IF
      END IF

      j = NoVar + NoCons
      VarDofs(j) = ConDofs
      VarSizes(j) = 1
      Offset(j+1) = Offset(j) + VarSizes(j)
    END DO

    DO j=1,NoVar+NoCons
      WRITE(Message,'(A,I2,A,T35,I10)') 'Permutation offset',j,': ',OffSet(j)
      CALL Info('GenericSolver',Message)
    END DO


    TotSize = SUM( VarSizes )
    MaxDofs = MAXVAL( VarDofs )

    WRITE(Message,'(A,T35,I10)') 'Number of coupled variables: ',NoVar
    CALL Info('GenericSolver',Message)
  
    WRITE(Message,'(A,T35,I10)') 'Number of constraints: ',NoCons
    CALL Info('GenericSolver',Message)
  
    WRITE(Message,'(A,T35,I10)') 'Size of coupled system: ',TotSize
    CALL Info('GenericSolver',Message)


!------------------------------------------------------------------------------
! Do some initial stuff
!------------------------------------------------------------------------------
  
    N = Mesh % MaxElementDOFs

    ALLOCATE( FORCE( MaxDofs*N ),      &
        STIFF( MaxDofs*N, MaxDofs*N ), &
        DAMP( MaxDofs*N, MaxDofs*N ),  &
        MASS(  MaxDofs*N, MaxDofs*N ), &
        ColInds( N ), RowInds( N ),    &
        Indexes(N), STAT=istat )
    IF ( istat /= 0 ) CALL FATAL('GenericSolver','Memory allocation error')
    
    NoIterations = GetInteger( SolverParams,'Nonlinear System Max Iterations',GotIt)
    IF(.NOT. GotIt) NoIterations = 1
    NonlinearTol = GetCReal( SolverParams,'Nonlinear System Convergence Tolerance',gotIt)
    
    IF(.NOT. Visited ) THEN
      Amat => AllocateMatrix()
      Amat % ListMatrix => Alist
      Amat % FORMAT = MATRIX_LIST      
      Solver % Matrix => Amat

      ALLOCATE(AllPerm(TotSize),AllValues(TotSize),ForceVector(TotSize))
      DO i=1,TotSize
        AllPerm(i) = i
        AllValues(i) = 0.0_dp
      END DO
      CALL VariableAdd( Mesh % Variables, Mesh, Solver, &
          'AllDofs',1,AllValues,AllPerm,Output=.FALSE.)
      CALL Info('GenericSolver','New coupled variable added: Alldofs', Level=5)

      Amat % Rhs => ForceVector
      Solver % Variable => VariableGet(Mesh % Variables, 'Alldofs')

      ALLOCATE( AllDir(TotSize) ) 
      AllDir = .FALSE.
      Visited = .TRUE.
    END IF
    Amat => GetMatrix()

!------------------------------------------------------------------------------
! Iterate over any nonlinearity of material or source
!------------------------------------------------------------------------------
    CALL Info('GenericSolver','-------------------------------------------------',Level=5)
    
    DO iter = 1,NoIterations
      
      WRITE(Message,'(A,T35,I5)') 'Generic iteration:',iter
      CALL Info('GenericSolver',Message,Level=5)
      
      IF( Amat % FORMAT == MATRIX_CRS ) CALL DefaultInitialize()
      AllDir = .FALSE.

      !-----------------------------------------------
      ! Start of normal assemly process
      ! This is the basic loop without any constraints.
      !-----------------------------------------------
      BulkMode = .TRUE.
100   IF(BulkMode) THEN
        CALL Info('GenericSolver','Starting bulk assembly',Level=5)
        ElementsFirst = 1
        ElementsLast = Mesh % NumberOFBulkElements
      ELSE
        CALL Info('GenericSolver','Starting boundary assembly',Level=5)
        ElementsFirst = Mesh % NumberOFBulkElements+1
        ElementsLast = Mesh % NumberOfBulkElements + &
               Mesh % NumberOFBoundaryElements
      END IF
      
      ! Variables over rows
      !-------------------------------------------
      DO RowVar = 1,NoVar 

        WRITE (str,'(A,I2)') 'Variable',RowVar
        RowName = ListGetString( SolverParams, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(RowName) ) 

        RowDofs = Var % Dofs
        RowPerm => Var % Perm
        RowInd0 = Offset(RowVar)
        
        ! Variables over columns
        !------------------------------------------
        DO ColVar = 1,NoVar          
          WRITE (str,'(A,I2)') 'Variable',ColVar
          ColName = ListGetString( SolverParams, TRIM(str), GotIt )
          Var => VariableGet( Mesh % Variables, TRIM(ColName) )
          
          ColDofs = Var % Dofs
          ColPerm => Var % Perm
          ColInd0 = Offset(ColVar)
           
          ! These could be user provided for each block
          !-----------------------------------------
          AssemblySymmetric = .FALSE.
          AssemblyAntiSymmetric = .FALSE.

          ! Load the assembly procudure
          !-----------------------------------------
          IF( BulkMode ) THEN
            WRITE (str,'(A,I1,I1)') 'Bulk Assembly Procedure ',RowVar,ColVar
          ELSE
            WRITE (str,'(A,I1,I1)') 'Boundary Assembly Procedure ',RowVar,ColVar
          END IF
          
          ProcName = ListGetString( SolverParams, TRIM(str), GotProc )
          IF( .NOT. GotProc ) THEN
            IF( BulkMode .AND. RowVar == ColVar) THEN
              CALL Warn('GenericSolver','Diagonal bulk entries should be assembled!')
            END IF
            CYCLE
          END IF
          
          ProcPntr = GetProcAddr( TRIM(ProcName), abort=.FALSE.,quiet=.FALSE.)
          IF ( ProcPntr == 0 ) THEN
            CALL Fatal('GenericSolver','AssemblyRoutine not found: '//TRIM(ProcName))
          ELSE
            CALL Info('GenericSolver','AssemblyRoutine: '//TRIM(ProcName))
          END IF
          
          ! The assembly loop for a submatrix starts here
          !------------------------------------------------------------------------------             
          DO t=ElementsFirst,ElementsLast
            
            Element => Mesh % Elements(t)
            Model % CurrentElement => Element

            !-----------------------------------------------------------------
            n  = GetElementNOFNodes()
            nd = GetElementDOFs(Indexes)

            Nrow = nd
            RowInds(1:Nrow) = RowPerm(Indexes(1:nd))
            IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE
            
            Ncol = nd
            ColInds(1:Ncol) = ColPerm(Indexes(1:nd))
            IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 

! Do the assembly, now really
!---------------------------------------------------------------------------------------
            
            STIFF = 0.0_dp
            DAMP = 0.0_dp
            MASS = 0.0_dp
            FORCE = 0.0_dp
            
            CALL ExecLocalAssembly( ProcPntr, CurrentModel, Solver, &
                dt, Transient, MASS, DAMP, STIFF, FORCE, Element, &
                Nrow, Ncol )
            
            IF ( Transient ) THEN
              IF( Solver % TimeOrder == 1 ) THEN
                CALL Default1stOrderTime( MASS,STIFF,FORCE)
              ELSE IF( Solver % TimeOrder == 2) THEN
                CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
              END IF
            END IF

            IF ( Solver % NOFEigenValues>0 ) THEN
              IF( Solver % TimeOrder == 1 ) THEN
                CALL DefaultUpdateMass(MASS)
              ELSE IF( Solver % TimeOrder == 2) THEN
                CALL DefaultUpdateDamp(DAMP)
                CALL DefaultUpdateMass(MASS)
              END IF
            END IF
            
            ! Assemble the matrix with offset
            !-----------------------------------------------

            CALL GlueLocalSubMatrix( Amat, &
                RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
                RowDofs,ColDofs,STIFF )
            
            ! Assemble the r.h.s with offset
            !-----------------------------------------------
            DO i=1,Nrow
              DO j=1,RowDofs
                Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
                ForceVector(Row) = ForceVector(Row) + &
                    FORCE(RowDofs*(i-1)+j)
              END DO
            END DO
                      
            ! For some constraints assemble also the transpose
            !--------------------------------------------------
            IF( AssemblySymmetric ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                  ColDofs,RowDofs,TRANSPOSE(STIFF) )               
            ELSE IF( AssemblyAntisymmetric ) THEN
              CALL GlueLocalSubMatrix( Amat, &
                  ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                  ColDofs,RowDofs,-TRANSPOSE(STIFF) )               
            END IF

          END DO
        END DO
      END DO
      
      IF(BulkMode) THEN
        CALL Info( 'GenericSolver', 'Bulk assembly done for blocks', Level=4 )
        BulkMode = .FALSE.
        GOTO 100
      ELSE 
        CALL Info( 'GenericSolver', 'Boundary assembly done for blocks', Level=4 )
      END IF
      

      !-----------------------------------------------------------------------------------
      ! Start of constraints assembly
      ! Some constraints are assembled by integration while others are done by elimination.
      ! It is important that constraints are applied after the normal assembly process. 
      !-----------------------------------------------------------------------------------
      BulkMode = .TRUE.
200   IF(BulkMode) THEN
        CALL Info('GenericSolver','Starting bulk assembly',Level=5)
        ElementsFirst = 1
        ElementsLast = Mesh % NumberOfBulkElements 
      ELSE
        CALL Info('GenericSolver','Starting boundary assembly',Level=5)
        ElementsFirst = Mesh % NumberOfBulkElements + 1
        ElementsLast =  Mesh % NumberOfBulkElements + &
              Mesh % NumberOfBoundaryElements
      END IF
      
      ! Variables over rows
      !-------------------------------------------
      DO RowVar = 1,NoCons        

        RowDofs = VarDofs(NoVar + RowVar) 
        RowInd0 = Offset(NoVar + RowVar)

        AssemblySymmetric = .FALSE.
        AssemblyAntiSymmetric = .FALSE.

        WRITE (str,'(A,I2)') 'Constraint',RowVar
        RowName = ListGetString( Solver % Values, TRIM(str), GotIt )

        WRITE (str,'(A,I2,A)') 'Constraint',RowVar,' Variables'
        VarInds => ListGetIntegerArray( Solver % Values, TRIM(str) )

        IF( ASSOCIATED(VarInds)) THEN
          ColVar =  VarInds(1) 
        ELSE        
          CALL Fatal('GenericSolver','Cannot continue without pointer to variables')
        END IF

        WRITE (str,'(A,I2,A)') 'Constraint',RowVar,' Value'
        ConsValue = GetCReal(Solver % Values,TRIM(str))

        IF ( ConsType == 'equality' ) THEN
          WRITE (str,'(A,I2)') 'Variable',VarInds(2)
          VarName = ListGetString( SolverParams, TRIM(str) )
          Var => VariableGet( Mesh % Variables, TRIM(VarName) ) 
          RowPerm => Var % Perm
          RowDofs = VarDofs(VarInds(2))
          RowInd0 = Offset(VarInds(2)) 
        ELSE
          Nrow = 1
          RowInds(1:Nrow) = 1         
          Var => VariableGet( Mesh % Variables, TRIM(RowName) )      
          
          ! Add the diagonal entry expected by some subroutines
          !-------------------------------------------------------          
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              CALL AddToMatrixElement( Amat, Row, Row, 0.0_dp )
            END DO
          END DO
        END IF
         
        IF( ConsType == 'integral') THEN
          AssemblySymmetric = .TRUE.
          ConsVolume = 0.0_dp
        END IF

        WRITE (str,'(A,I2)') 'Variable',ColVar
        ColName = ListGetString( Solver % Values, TRIM(str), GotIt )
        Var => VariableGet( Mesh % Variables, TRIM(ColName) )
          
        ! Constrain only the target variable
        !-----------------------------------------------
        
        ColPerm => Var % Perm
        ColDofs = Var % Dofs
        ColInd0 = Offset(ColVar)
          
        ! The assembly loop for a submatrix starts here
        !------------------------------------------------------------------------------             
        DO t=ElementsFirst,ElementsLast

          Element => Mesh % Elements(t)
          Model % CurrentElement => Element
          
          ! How to treat non-nodal elements must be rethought 
          ! nd = GetElementNOFDOFs( Element, Solver )                  
          !-----------------------------------------------------------------
          n  = GetElementNOFNodes()
          nd = GetElementDOFs(Indexes)
                        
          ! Set the permutations for equality constraint
          !----------------------------------------------------
          IF( ConsType == 'equality') THEN
            Nrow = nd
            RowInds(1:Nrow) = RowPerm(Indexes)
            IF(.NOT. ALL(RowInds(1:Nrow) > 0)) CYCLE
          END IF
            
          Ncol = nd
          ColInds(1:n) = ColPerm(Indexes)
          IF(.NOT. ALL(ColInds(1:Ncol) > 0)) CYCLE                 

            
          ! Check where constraints are active, both bodies and BCs
          !-------------------------------------------------------------------                         
          Coupling = .FALSE.              
          IF( BulkMode ) THEN
            ! Check coupling to bodies using Body/Equation section
            Coupling = GetLogical( GetBodyForce(), RowName, gotIt)
          ELSE 
            Coupling = GetLogical( GetBC(), RowName, gotIt)
          END IF
          IF( .NOT. Coupling ) CYCLE
              
          ! These two constraints are based on moving already assembled information
          ! rather than assembling new information. If the row is already treated cycle.
          ! The constrainst have been tested only with one-component cases.
          !-----------------------------------------------------------------------------
          IF( ConsType == 'floating' .OR. ConsType == 'equality') THEN

            DO i=1,Ncol                
              DO k=0,ColDofs-1
                
                ! Note that for this type the column is rather also a row
                !--------------------------------------------------------
                Col  = ColInd0 + ColDofs * ColInds(i) - k                  
                IF( AllDir(Col) ) CYCLE
                AllDir(Col) = .TRUE.
                
                IF( ConsType == 'floating') THEN
                  Row = RowInd0 + 1
                  CALL MoveRow( Amat, Col, Row ) 
                  ! ForceVector(Row) = ForceVector(Row) + ForceVector(Col)
                ELSE 
                  Row = RowInd0 + RowDofs * RowInds(i) - k
                  CALL MoveRow( Amat, Col, Row ) 
                  ForceVector(Row) = ForceVector(Row) + ForceVector(Col)
                END IF
                
                ForceVector(Col) = 0.0_dp                                                      
                CALL SetMatrixElement( Amat,Col,Col,1.0_dp )
                CALL SetMatrixElement( Amat,Col,Row,-1.0_dp )
              END DO
            END DO
            CYCLE
          END IF

          ! Do the assembly, now really (active only for some constraints)
          !----------------------------------------------------------------
            
          STIFF = 0.0_dp
          DAMP = 0.0_dp
          MASS = 0.0_dp
          FORCE = 0.0_dp
          
          CALL IntegralConstraint( MASS, DAMP, STIFF, FORCE, Element, Ncol )
          
          IF ( Transient ) THEN
            IF( Solver % TimeOrder == 1 ) THEN
              CALL Default1stOrderTime( MASS,STIFF,FORCE)
            ELSE IF( Solver % TimeOrder == 2) THEN
              CALL Default2ndOrderTime( MASS,DAMP,STIFF,FORCE )
            END IF
          END IF
           
          ! Assemble the matrix with offset
          !-----------------------------------------------
          CALL GlueLocalSubMatrix( Amat, &
              RowInd0,ColInd0,Nrow,Ncol,RowInds,ColInds,&
              RowDofs,ColDofs,STIFF )
          
          
          ! Assemble the r.h.s with offset
          !-----------------------------------------------
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              ForceVector(Row) = ForceVector(Row) + &
                  FORCE(RowDofs*(i-1)+j)
            END DO
          END DO
          
          ! For some constraints assemble also the transpose
          !--------------------------------------------------
          IF( AssemblySymmetric ) THEN
            CALL GlueLocalSubMatrix( Amat, &
                ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                ColDofs,RowDofs,TRANSPOSE(STIFF) )               
          ELSE IF( AssemblyAntisymmetric ) THEN
            CALL GlueLocalSubMatrix( Amat, &
                ColInd0,RowInd0,Ncol,Nrow,ColInds,RowInds,&
                ColDofs,RowDofs,-TRANSPOSE(STIFF) )               
          END IF
          
        END DO
      
        ! For constraints do some special setting
        !---------------------------------------------------
        IF( ConsType == 'integral' ) THEN
          PRINT *,'Constraint Volume: ',ConsVolume
          DO i=1,Nrow
            DO j=1,RowDofs
              Row = RowInd0 + RowDofs * (RowInds(i)-1) + j
              ForceVector(Row) = ConsValue
            END DO
          END DO
        END IF
      END DO
      
      IF(BulkMode) THEN
        CALL Info( 'GenericSolver', 'Bulk assembly done for constraints', Level=4 )
        BulkMode = .FALSE.
        GOTO 200
      ELSE 
        CALL Info( 'GenericSolver', 'Boundary assembly done for constraints', Level=4 )
      END IF
      
!----------------------------------------------------------------------
! The CRS matrix may be created only when the matrix structure is known
!----------------------------------------------------------------------
      IF( Amat % FORMAT == MATRIX_LIST ) CALL List_ToCRSMatrix(Amat)
      CALL DefaultFinishAssembly()
      
!------------------------------------------------------------------------------
!    Do the Dirichlet conditions using offset
!------------------------------------------------------------------------------          
      DO i = 1,NoVar
        WRITE (str,'(A,I2)') 'Variable',i
        VarName = ListGetString( SolverParams, TRIM(str), GotIt )
        IF(.NOT. GotIt) EXIT
        
        Var => VariableGet( Mesh % Variables, TRIM(VarName) )
        IF (.NOT. ASSOCIATED(Var)) EXIT 
        
        CALL DefaultDirichletBCs( Ux=Var, UOffset=Offset(i) )
      END DO
      CALL Info( 'GenericSolver', 'Dirichlet conditions done', Level=4 )
      
!------------------------------------------------------------------------------
!   Finally solve the system
!   This could be divided into solution & update making different 
!   robust solution methods possible.
!------------------------------------------------------------------------------          
   
      Norm = DefaultSolve()     
      CALL Info('GenericSolver','-------------------------------------------------',Level=5)
      
      IF(Solver % Variable % NonlinChange < NonlinearTol) EXIT
    END DO
    
!------------------------------------------------------------------------------          
! Map the result back to the original vectors
!----------------------------------------------------------------------------------
    CALL Info('GenericSolver','Copying results into original variables',Level=5)
    DO i = 1,NoVar + NoCons
      IF( VarDofs(i) == 0 ) CYCLE

      IF( i <= NoVar ) THEN
        WRITE (str,'(A,I2)') 'Variable',i
      ELSE
        WRITE (str,'(A,I2)') 'Constraint',i-NoVar        
      END IF
      VarName = ListGetString( SolverParams, TRIM(str), GotIt )
      Var => VariableGet( Mesh % Variables, TRIM(VarName) )
      
      CALL Info('GenericSolver','Variable: '//TRIM(VarName),Level=5)
      DO j=1,SIZE(Var % Values)
        Var % Values(j) = Solver % Variable % Values(Offset(i)+j)
      END DO
      
      IF( i > NoVar ) THEN
        PRINT *,TRIM(str),': ',Var % Values       
      END IF
    END DO
    
    DEALLOCATE( FORCE, STIFF, DAMP, MASS, ColInds, RowInds, Indexes )
    Visited = .TRUE.
    
    CALL Info('GenericSolver','All done')
    CALL Info('GenericSolver','-------------------------------------------------',Level=5)


  CONTAINS 


!------------------------------------------------------------------------------
   SUBROUTINE IntegralConstraint( Mass, Damp, Stiff, Force, Element, n )
!------------------------------------------------------------------------------
! Integration routine for intgral type of constraints i.e. body or boundary
! integral of some dof is known a priori.
!------------------------------------------------------------------------------

      
      IMPLICIT NONE
!------------------------------------------------------------------------------
      REAL(KIND=dp) :: Stiff(:,:), Damp(:,:), Mass(:,:), Force(:)
      TYPE(Element_t), POINTER :: Element
      INTEGER :: n
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
      TYPE(GaussIntegrationPoints_t) :: IntegStuff
      REAL(KIND=dp) :: Basis(n)
      REAL(KIND=dp) :: Weight, DetJ
      INTEGER :: i,j,t,p,q
      LOGICAL :: Visited = .FALSE., Found
      
      TYPE(Nodes_t),SAVE :: Nodes
      
      CALL GetElementNodes( Nodes ) 
      IntegStuff = GaussPoints( Element )
      
      DO t=1,IntegStuff % n
        Found = ElementInfo( Element, Nodes, IntegStuff % u(t), &
            IntegStuff % v(t), IntegStuff % w(t), detJ, Basis )     
        Weight = IntegStuff % s(t) * detJ
        DO p=1,n
          STIFF(1,p) = STIFF(1,p) + Weight * Basis(p)
          FORCE(p) = FORCE(p) + ConsValue * Weight * Basis(p)
        END DO
        ConsVolume = ConsVolume + Weight 
      END DO
      Visited = .TRUE.
!------------------------------------------------------------------------------
    END SUBROUTINE IntegralConstraint
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
END SUBROUTINE GenericSolver
!------------------------------------------------------------------------------
 


!------------------------------------------------------------------------------
  SUBROUTINE SolverActivate( Model, Solver, dt, TransientSimulation )
!------------------------------------------------------------------------------
     TYPE(Model_t)  :: Model
     TYPE(Solver_t),POINTER :: Solver
     LOGICAL :: TransientSimulation
     REAL(KIND=dp) :: dt, OrigDT, DTScal
!------------------------------------------------------------------------------
     LOGICAL :: stat, Found, GB, FirstTime=.TRUE., MeActive
     INTEGER :: i, j, n, SolverAddr, BDOFs, execi, timestep, maxdim
     REAL(KIND=dp) :: st
     TYPE(Variable_t), POINTER :: TimeVar, IterV
     TYPE(Element_t), POINTER :: CurrentElement
     CHARACTER(LEN=MAX_NAME_LEN) :: EquationName, str

     INTEGER :: comm_active, group_active, group_world, ierr
     INTEGER, ALLOCATABLE :: memb(:)

     SAVE TimeVar, FirstTime
!------------------------------------------------------------------------------
     CALL SetCurrentMesh( Model, Solver % Mesh )
     Model % Solver => Solver

     st = ListGetConstReal( Solver % Values, 'Start Time', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Time' )
       IF ( TimeVar % Values(1) < st ) RETURN
     END IF

     execi = ListGetInteger( Solver % Values, 'Exec Interval', Found )
     IF ( Found ) THEN
       TimeVar => VariableGet( Model % Variables, 'Timestep' )
       execi = MOD( NINT(Timevar % Values(1))-1, execi )
       IF ( execi /= 0 ) RETURN
     END IF

     IF ( Solver % Mesh % Changed .OR. Solver % NumberOfActiveElements <= 0 ) THEN
       Solver % NumberOFActiveElements = 0
       EquationName = ListGetString( Solver % Values, 'Equation', stat )

       IF ( Stat ) THEN
          IF (  ASSOCIATED( Solver % ActiveElements ) ) DEALLOCATE( Solver % ActiveElements )
          ALLOCATE( Solver % ActiveElements( Solver % Mesh % NumberOfBulkElements + &
                       Solver % Mesh % NumberOFBoundaryElements ) )

          Maxdim = 0
          DO i=1,Solver % Mesh % NumberOfBulkElements+Solver % Mesh % NumberOFBoundaryElements
             CurrentElement => Solver % Mesh % Elements(i)
             IF ( CheckElementEquation( Model, CurrentElement, EquationName ) ) THEN
                Solver % NumberOfActiveElements = Solver % NumberOFActiveElements + 1
                Solver % ActiveElements( Solver % NumberOFActiveElements ) = i
                Maxdim = MAX( CurrentElement % TYPE % DIMENSION, Maxdim )
             END IF
          END DO
          CALL ListAddInteger( Solver % Values, 'Active Mesh Dimension', Maxdim )
       END IF

       CALL CalculateNodalWeights(Solver)
     END IF
!------------------------------------------------------------------------------
     Solver % Mesh % OutputActive = .TRUE.
     OrigDT = dt
     DTScal = ListGetConstReal( Solver % Values, "Timestep Scale", Found )
     IF ( .NOT. Found ) DTScal = 1.0d0
     Solver % dt = DTScal * dt

     MeActive = ASSOCIATED(Solver % Matrix)
     IF ( MeActive ) &
        MeActive = MeActive .AND. (Solver % Matrix % NumberOfRows>0)
     CALL ParallelActive( MeActive )

     IF ( MeActive ) &
       Solver % Matrix % Comm = MPI_COMM_WORLD
     IF ( ParEnv % PEs>1 ) THEN
       DO i=1,ParEnv % PEs
         IF ( ParEnv % Active(i) ) THEN
           EXIT
         END IF
       END DO

       OutputPE = -1
       IF ( i-1==ParEnv % MyPE ) OutputPE=0

       n = COUNT(ParEnv % Active)
       IF ( n>0 ) THEN
         CALL MPI_Comm_group( MPI_COMM_WORLD, group_world, ierr )
         ALLOCATE(memb(n))
         n = 0
         DO i=1,ParEnv % PEs
           IF ( ParEnv % Active(i) ) THEN
             n=n+1
             memb(n)=i-1
           END IF
         END DO
         CALL MPI_Group_incl( group_world, n, memb, group_active, ierr)
         DEALLOCATE(memb)
         CALL MPI_Comm_create( MPI_COMM_WORLD, group_active, &
                 comm_active, ierr)
         IF ( MeActive ) Solver % Matrix % Comm = comm_active
       END IF
     END IF

     str = ListGetString( Solver % Values, 'Namespace', Found )
     IF (Found) CALL ListSetNamespace(TRIM(str))

     iterV => VariableGet( Solver % Mesh % Variables, 'nonlin iter' )
     iterV % Values(1) = 1

     str = ListGetString( Solver  % Values, 'Procedure', Found )

#ifdef SGIn32
      SolverAddr = Solver % PROCEDURE
      CALL ExecSolver( SolverAddr, Model, Solver, DTScal*dt, TransientSimulation)
#else
      CALL ExecSolver( &
             Solver % PROCEDURE, Model, Solver, DTScal*dt, TransientSimulation)
#endif

     CALL ListSetNamespace('')

     Solver % dt = OrigDT
!------------------------------------------------------------------------------
   END SUBROUTINE SolverActivate
!------------------------------------------------------------------------------

END MODULE MainUtils

