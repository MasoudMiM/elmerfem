!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - Scientific Computing Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module containing a band matrix solver for linear system given in
! *  CRS format.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - Scientific Computing Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/
! *
! * $Id: DirectSolve.src,v 1.8 2006/11/30 12:49:43 jpr Exp $
! ******************************************************************************

MODULE DirectSolve

   USE CRSMatrix
   USE Lists
   USE BandMatrix
   USE SParIterSolve
   USE SparIterGlobals

   IMPLICIT NONE

CONTAINS


!------------------------------------------------------------------------------
   SUBROUTINE ComplexBandSolver( A,x,b )
!------------------------------------------------------------------------------

     REAL(KIND=dp) :: x(*),b(*)
     TYPE(Matrix_t), POINTER :: A
!------------------------------------------------------------------------------

   
     INTEGER :: i,j,k,istat,Subband,N
     COMPLEX(KIND=dp), ALLOCATABLE :: BA(:,:)

     SAVE BA
!------------------------------------------------------------------------------

     n = A % NumberOfRows
     x(1:n) = b(1:n)
     n = n / 2

     IF ( A % Format == MATRIX_CRS .AND. .NOT. A % Symmetric ) THEN
       Subband = 0
       DO i=1,N
         DO j=A % Rows(2*i-1),A % Rows(2*i)-1,2
           Subband = MAX(Subband,ABS((A % Cols(j)+1)/2-i))
         END DO
       END DO

       IF ( .NOT.ALLOCATED( BA ) ) THEN

         ALLOCATE( BA(3*SubBand+1,N),stat=istat )

         IF ( istat /= 0 ) THEN
           CALL Fatal( 'ComplexBandSolver', 'Memory allocation error.' )
         END IF

       ELSE IF ( SIZE(BA,1) /= 3*Subband+1 .OR. SIZE(BA,2) /= N ) THEN

         DEALLOCATE( BA )
         ALLOCATE( BA(3*SubBand+1,N),stat=istat )

         IF ( istat /= 0 ) THEN
           CALL Fatal( 'ComplexBandSolver', 'Memory allocation error.' )
         END IF

       END IF

       BA = 0.0D0
       DO i=1,N
         DO j=A % Rows(2*i-1),A % Rows(2*i)-1,2
           k = i - (A % Cols(j)+1)/2 + 2*Subband + 1
           BA(k,(A % Cols(j)+1)/2) = CMPLX( A % Values(j), -A % Values(j+1), KIND=dp )
         END DO
       END DO

       CALL SolveComplexBandLapack( N,1,BA,x,Subband,3*Subband+1 )

     ELSE IF ( A % Format == MATRIX_CRS ) THEN

       Subband = 0
       DO i=1,N
         DO j=A % Rows(2*i-1),A % Diag(2*i-1)
           Subband = MAX(Subband,ABS((A % Cols(j)+1)/2-i))
         END DO
       END DO

       IF ( .NOT.ALLOCATED( BA ) ) THEN

         ALLOCATE( BA(SubBand+1,N),stat=istat )

         IF ( istat /= 0 ) THEN
           CALL Fatal( 'ComplexBandSolver', 'Memory allocation error.' )
         END IF

       ELSE IF ( SIZE(BA,1) /= Subband+1 .OR. SIZE(BA,2) /= N ) THEN

         DEALLOCATE( BA )
         ALLOCATE( BA(SubBand+1,N),stat=istat )

         IF ( istat /= 0 ) THEN
           CALL Fatal( 'ComplexBandSolver', 'Direct solver memory allocation error.' )
         END IF

       END IF

       BA = 0.0D0
       DO i=1,N
         DO j=A % Rows(2*i-1),A % Diag(2*i-1)
           k = i - (A % Cols(j)+1)/2 + 1
           BA(k,(A % Cols(j)+1)/2) = CMPLX( A % Values(j), -A % Values(j+1), KIND=dp )
         END DO
       END DO

       CALL SolveComplexSBandLapack( N,1,BA,x,Subband,Subband+1 )

     END IF
!------------------------------------------------------------------------------
  END SUBROUTINE ComplexBandSolver 
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE BandSolver( A,x,b )
!------------------------------------------------------------------------------

     REAL(KIND=dp) :: x(*),b(*)
     TYPE(Matrix_t), POINTER :: A
!------------------------------------------------------------------------------

     INTEGER :: i,j,k,istat,Subband,N
     REAL(KIND=dp), ALLOCATABLE :: BA(:,:)

     SAVE BA
!------------------------------------------------------------------------------
     N = A % NumberOfRows

     x(1:n) = b(1:n)

     IF ( A % Format == MATRIX_CRS ) THEN ! .AND. .NOT. A % Symmetric ) THEN
        Subband = 0
        DO i=1,N
          DO j=A % Rows(i),A % Rows(i+1)-1
            Subband = MAX(Subband,ABS(A % Cols(j)-i))
          END DO
        END DO

        IF ( .NOT.ALLOCATED( BA ) ) THEN

          ALLOCATE( BA(3*SubBand+1,N),stat=istat )

          IF ( istat /= 0 ) THEN
            CALL Fatal( 'BandSolver', 'Memory allocation error.' )
          END IF

        ELSE IF ( SIZE(BA,1) /= 3*Subband+1 .OR. SIZE(BA,2) /= N ) THEN

          DEALLOCATE( BA )
          ALLOCATE( BA(3*SubBand+1,N),stat=istat )

          IF ( istat /= 0 ) THEN
            CALL Fatal( 'BandSolver', 'Memory allocation error.' )
          END IF

       END IF

       BA = 0.0D0
       DO i=1,N
         DO j=A % Rows(i),A % Rows(i+1)-1
           k = i - A % Cols(j) + 2*Subband + 1
           BA(k,A % Cols(j)) = A % Values(j)
         END DO
       END DO

       CALL SolveBandLapack( N,1,BA,x,Subband,3*Subband+1 )

     ELSE IF ( A % Format == MATRIX_CRS ) THEN

       Subband = 0
       DO i=1,N
         DO j=A % Rows(i),A % Diag(i)
           Subband = MAX(Subband,ABS(A % Cols(j)-i))
         END DO
       END DO

       IF ( .NOT.ALLOCATED( BA ) ) THEN

         ALLOCATE( BA(SubBand+1,N),stat=istat )

         IF ( istat /= 0 ) THEN
           CALL Fatal( 'BandSolver', 'Memory allocation error.' )
         END IF

       ELSE IF ( SIZE(BA,1) /= Subband+1 .OR. SIZE(BA,2) /= N ) THEN

         DEALLOCATE( BA )
         ALLOCATE( BA(SubBand+1,N),stat=istat )

         IF ( istat /= 0 ) THEN
           CALL Fatal( 'BandSolver', 'Memory allocation error.' )
         END IF

       END IF

       BA = 0.0D0
       DO i=1,N
         DO j=A % Rows(i),A % Diag(i)
           k = i - A % Cols(j) + 1
           BA(k,A % Cols(j)) = A % Values(j)
         END DO
       END DO

       CALL SolveSBandLapack( N,1,BA,x,Subband,Subband+1 )

     ELSE IF ( A % Format == MATRIX_BAND ) THEN

       CALL SolveBandLapack( N,1,A % Values(1:N*(3*A % Subband+1)), &
                     x,A % Subband,3*A % Subband+1 )

     ELSE IF ( A % Format == MATRIX_SBAND ) THEN

       CALL SolveSBandLapack( N,1,A % Values,x,A % Subband,A % Subband+1 )

     END IF

!------------------------------------------------------------------------------
  END SUBROUTINE BandSolver 
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE UMFPack_SolveSystem( Solver,A,x,b )
!------------------------------------------------------------------------------
#include "../config.h"
#ifdef HAVE_UMFPACK
  INTERFACE
    SUBROUTINE umf4def( control )
       USE Types
       REAL(KIND=dp) :: control(*) 
    END SUBROUTINE umf4def

    SUBROUTINE umf4sym( m,n,rows,cols,values,symbolic,control,iinfo )
       USE Types
       INTEGER :: m,n,rows(*),cols(*)
       INTEGER(KIND=AddrInt) ::  symbolic
       REAL(KIND=dp) :: Values(*), control(*),iinfo(*)
    END SUBROUTINE umf4sym

    SUBROUTINE umf4num( rows,cols,values,symbolic,numeric, control,iinfo )
       USE Types
       INTEGER :: rows(*),cols(*)
       INTEGER(KIND=AddrInt) ::  numeric, symbolic
       REAL(KIND=dp) :: Values(*), control(*),iinfo(*)
    END SUBROUTINE umf4num

    SUBROUTINE umf4sol( sys, x, b, numeric, control, iinfo )
       USE Types
       INTEGER :: sys
       INTEGER(KIND=AddrInt) :: numeric
       REAL(KIND=dp) :: x(*), b(*), control(*), iinfo(*)
    END SUBROUTINE umf4sol

    SUBROUTINE umf4_l_def( control )
       USE Types
       REAL(KIND=dp) :: control(*) 
    END SUBROUTINE umf4_l_def

    SUBROUTINE umf4_l_sym( m,n,rows,cols,values,symbolic,control,iinfo )
       USE Types
       INTEGER(KIND=AddrInt) :: m,n,rows(*),cols(*)
       INTEGER(KIND=AddrInt) ::  symbolic
       REAL(KIND=dp) :: Values(*), control(*),iinfo(*)
    END SUBROUTINE umf4_l_sym

    SUBROUTINE umf4_l_num( rows,cols,values,symbolic,numeric, control,iinfo )
       USE Types
       INTEGER(KIND=AddrInt) :: rows(*),cols(*)
       INTEGER(KIND=AddrInt) ::  numeric, symbolic
       REAL(KIND=dp) :: Values(*), control(*),iinfo(*)
    END SUBROUTINE umf4_l_num

    SUBROUTINE umf4_l_sol( sys, x, b, numeric, control, iinfo )
       USE Types
       INTEGER(KIND=AddrInt) :: sys
       INTEGER(KIND=AddrInt) :: numeric
       REAL(KIND=dp) :: x(*), b(*), control(*), iinfo(*)
    END SUBROUTINE umf4_l_sol
  END INTERFACE
#endif


  TYPE(Matrix_t), POINTER :: A
  TYPE(Solver_t) :: Solver
  INTEGER :: n
  REAL(KIND=dp), TARGET :: x(*), b(*)

#ifdef HAVE_UMFPACK
  INTEGER :: status, sys
  REAL(KIND=dp) :: iInfo(90), Control(20)
  INTEGER(KIND=AddrInt) :: symbolic, zero=0, ln, lsys
  INTEGER(KIND=AddrInt), ALLOCATABLE :: LRows(:), LCols(:)

  SAVE iInfo, Control
 
  LOGICAL :: Factorize, FreeFactorize, stat, BigMode

  BigMode = ListGetString( Solver % Values, &
      'Linear System Direct Method' ) == 'big umfpack'

  Factorize = ListGetLogical( Solver % Values, &
     'Linear System Refactorize', stat )
  IF ( .NOT. stat ) Factorize = .TRUE.

  n = A % NumberofRows
  IF ( Factorize .OR. A% UmfPack_Numeric==0 ) THEN
    IF ( A % UMFPack_Numeric /= 0 ) THEN
      IF( BigMode ) THEN
        CALL umf4_l_fnum( A % UMFPack_Numeric )
      ELSE
        CALL umf4fnum( A % UMFPack_Numeric )
      END IF
      A % UMFPack_Numeric = 0
    END IF

    IF ( BigMode ) THEN
      ALLOCATE( LRows(SIZE(A % Rows)), LCols(SIZE(A % Cols)) )
      LRows = A % Rows-1
      LCols = A % Cols-1
      ln = n
      CALL umf4_l_def( Control )
      CALL umf4_l_sym( ln,ln, LRows, LCols, A % Values, Symbolic, Control, iInfo )
    ELSE
      A % Rows = A % Rows-1
      A % Cols = A % Cols-1
      CALL umf4def( Control )
      CALL umf4sym( n,n, A % Rows, A % Cols, A % Values, Symbolic, Control, iInfo )
    END IF

    IF (iinfo(1)<0) THEN
      PRINT *, 'Error occurred in umf4sym: ', iinfo(1)
      STOP
    END IF

    IF ( BigMode ) THEN
      CALL umf4_l_num(LRows, LCols, A % Values, Symbolic, A % UMFPack_Numeric, Control, iInfo )
    ELSE
      CALL umf4num( A % Rows, A % Cols, A % Values, Symbolic, A % UMFPack_Numeric, Control, iInfo )
    END IF

    IF (iinfo(1)<0) THEN
      PRINT*, 'Error occurred in umf4num: ', iinfo(1)
      STOP
    ENDIF

    IF ( BigMode ) THEN
      DEALLOCATE( LRows, LCols )
      CALL umf4_l_fsym( Symbolic )
    ELSE
      A % Rows = A % Rows+1
      A % Cols = A % Cols+1
      CALL umf4fsym( Symbolic )
    END IF
  END IF

  IF ( BigMode ) THEN
    lsys = 2
    CALL umf4_l_sol( lsys, x, b, A % UMFPack_Numeric, Control, iInfo )
  ELSE
    sys = 2
    CALL umf4sol( sys, x, b, A % UMFPack_Numeric, Control, iInfo )
  END IF

  IF (iinfo(1)<0) THEN
    PRINT*, 'Error occurred in umf4sol: ', iinfo(1)
    STOP
  END IF
 
  FreeFactorize = ListGetLogical( Solver % Values, &
      'Linear System Free Factorization', stat )
  IF ( .NOT. stat ) FreeFactorize = .TRUE.

  IF ( Factorize .AND. FreeFactorize ) THEN
    IF ( BigMode ) THEN
      CALL umf4_l_fnum(A % UMFPack_Numeric)
    ELSE
      CALL umf4fnum(A % UMFPack_Numeric)
    END IF
    A % UMFPack_Numeric = 0
  END IF
#else
   CALL Fatal( 'UMFPack_SolveSystem', 'UMFPACK Solver has not been installed.' )
#endif
!------------------------------------------------------------------------------
  END SUBROUTINE UMFPack_SolveSystem
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE Mumps_SolveSystem( Solver,A,x,b )
!------------------------------------------------------------------------------
  TYPE(Matrix_t), POINTER :: A
  TYPE(Solver_t) :: Solver
  REAL(KIND=dp), TARGET :: x(*), b(*)

#ifdef HAVE_MUMPS
  INCLUDE 'mpif.h'

  INTEGER, ALLOCATABLE :: Owner(:)
  INTEGER :: i,j,n,ip,ierr
  LOGICAL :: Factorize, FreeFactorize, stat

  INTEGER, ALLOCATABLE :: memb(:)
  INTEGER :: Comm_active, Group_active, Group_world

  Factorize = ListGetLogical( Solver % Values, &
     'Linear System Refactorize', stat )
  IF ( .NOT. stat ) Factorize = .TRUE.

  IF ( Factorize .OR. .NOT.ASSOCIATED(A % MumpsID) ) THEN
    IF ( ASSOCIATED(A % MumpsID) ) THEN
      DEALLOCATE( A % MumpsID % irn_loc, &
         A % MumpsID % jcn_loc, A % MumpsID % Rhs,  &
            A % MumpsID % isol_loc, A % MumpsID % sol_loc, A % Gorder)
      A % MumpsID % job = -2
      CALL DMumps(A % MumpsID)
      DEALLOCATE(A % MumpsID)
    END IF

    ALLOCATE(A % MumpsID)

    A % MumpsID % Comm = A % Comm
    A % MumpsID % par  =  1
    A % MumpsID % job  = -1
    CALL DMumps(A % MumpsID)

    n = SIZE(A % ParallelInfo % GlobalDOFs)
    ALLOCATE( A % Gorder(n), Owner(n) )
    CALL ContinuousNumbering( A % ParallelInfo, &
        A % Perm, A % Gorder, Owner )

    CALL MPI_ALLREDUCE( SUM(Owner), A % MumpsID % n, &
       1, MPI_INTEGER, MPI_SUM, A % MumpsID % Comm, ierr )
    DEALLOCATE(Owner)

    A % MumpsID % nz_loc = A % Rows(A % NumberOfRows+1)-1
    ALLOCATE( A % MumpsID % irn_loc(A % MumpsID % nz_loc) )
    DO i=1,A % NumberOfRows
      ip = A % Gorder(A % InvPerm(i))
      DO j=A % Rows(i),A % Rows(i+1)-1
        A % MumpsID % irn_loc(j) = ip
      END DO
    END DO

    ALLOCATE( A % MumpsID % jcn_loc(A % MumpsId % nz_loc) )
    DO i=1,A % MumpsID % nz_loc
      A % MumpsID % jcn_loc(i) = A % Gorder(A % Invperm(A % Cols(i)))
    END DO
    A % MumpsID % a_loc   => A % values

    ALLOCATE(A % MumpsID % rhs(A % MumpsId % n))

    IF ( ListGetLogical(Solver % Values, &
                     'Linear System Symmetric', stat) ) THEN
      A % MumpsID % sym = 2
    ELSE
      A % MumpsID % sym = 0
    END IF

    A % MumpsID % icntl(2)  = 0 ! supress printing of diagnostics and warnings
    A % MumpsID % icntl(3)  = 0 ! supress statistics
    A % MumpsID % icntl(4)  = 1 ! the same as the two above, but doesn't seem to work.
    A % MumpsID % icntl(5)  = 0 ! matrix format 'assembled'
    A % MumpsID % icntl(18) = 3 ! 'distributed' matrix 
    A % MumpsID % icntl(21) = 1 ! 'distributed' solution phase

    A % MumpsID % job = 4
    CALL DMumps(A % MumpsID)

    A % MumpsID % lsol_loc = A % mumpsid % info(23)
    ALLOCATE(A % MumpsID % sol_loc(A % MumpsId % lsol_loc))
    ALLOCATE(A % MumpsID % isol_loc(A % MumpsId % lsol_loc))
  END IF

 ! sum the rhs from all procs. Could be done
 ! for neighbours only (i guess):
 ! ------------------------------------------
  A % MumpsID % RHS = 0
  DO i=1,A % NumberOfRows
    ip = A % Gorder(A % InvPerm(i))
    A % MumpsId % RHS(ip) = b(i)
  END DO
  CALL MPI_ALLREDUCE( A % MumpsID % RHS, A % MumpsID % RHS, &
    A % MumpsID % n, MPI_DOUBLE_PRECISION, MPI_SUM, A % MumpsID % Comm, ierr )

 ! Solution:
 ! ---------
  A % MumpsID % job = 3
  CALL DMumps(A % MumpsID)

 ! Distribute the solution to all:
 ! -------------------------------
  A % MumpsId % Rhs = 0
  DO i=1,A % MumpsID % lsol_loc
    A % MumpsID % RHS(A % MumpsID % isol_loc(i)) = &
            A % MumpsID % sol_loc(i)
  END DO
  CALL MPI_ALLREDUCE( A % MumpsID % RHS, A % MumpsID % RHS, &
    A % MumpsID % N, MPI_DOUBLE_PRECISION, MPI_SUM,A %  MumpsID % Comm, ierr )

 ! Select the values which belong to us:
 ! -------------------------------------
  DO i=1,A % NumberOfRows
    ip = A % Gorder(A % Invperm(i))
    x(i) = A % MumpsId % RHS(ip)
  END DO

  FreeFactorize = ListGetLogical( Solver % Values, &
      'Linear System Free Factorization', stat )
  IF ( .NOT. stat ) FreeFactorize = .TRUE.

  IF ( Factorize .AND. FreeFactorize ) THEN
    DEALLOCATE( A % MumpsID % irn_loc, &
       A % MumpsID % jcn_loc, A % MumpsID % Rhs,  &
         A % MumpsID % isol_loc, A % MumpsID % sol_loc, A % Gorder)

    A % MumpsID % job = -2
    CALL DMumps(A % MumpsID)
    DEALLOCATE(A % MumpsID)
    A % MumpsId => NULL()
  END IF

#else
   CALL Fatal( 'Mumps_SolveSystem', 'MUMPS Solver has not been installed.' )
#endif
!------------------------------------------------------------------------------
  END SUBROUTINE Mumps_SolveSystem
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
  SUBROUTINE SuperLU_SolveSystem( Solver,A,x,b )
!------------------------------------------------------------------------------
  TYPE(Matrix_t), POINTER :: A
  TYPE(Solver_t) :: Solver
  REAL(KIND=dp), TARGET :: x(*), b(*)

#ifdef HAVE_SUPERLU
      LOGICAL :: stat, Factorize, FreeFactorize
      integer :: n, nnz, nrhs, iinfo, iopt, nprocs

      interface
        subroutine solve_superlu( iopt, nprocs, n, nnz, nrhs, values, cols, &
                     rows, b, ldb, factors, iinfo )
            use types
            integer :: iopt, nprocs, n, nnz, nrhs, cols(*), rows(*), ldb, iinfo
            real(kind=dp) :: values(*), b(*)
            integer(kind=addrint) :: factors
        end subroutine solve_superlu
      end interface

      n = A % NumberOfRows
      nrhs = 1
!     x(1:n) = b(1:n)
      nnz = A % Rows(n+1)-1

      nprocs = ListGetInteger( Solver % Values, & 
              'Linear System Number of Threads', stat )
      IF ( .NOT. stat ) nprocs = 1
!
      Factorize = ListGetLogical( Solver % Values, &
         'Linear System Refactorize', stat )
      IF ( .NOT. stat ) Factorize = .TRUE.

      IF ( Factorize .OR. A % Umfpack_numeric==0 ) THEN

        IF ( A % UmfPack_numeric/= 0 ) THEN
          iopt = 3
          call Solve_SuperLU( iopt, nprocs, n, nnz, nrhs, A % Values, A % Cols, &
                     A % Rows, b, n, A % Umfpack_numeric, iinfo )
          A % UmfPack_numeric = 0
        END IF

        ! First, factorize the matrix. The factors are stored in *factors* handle.
        iopt = 1
        call Solve_SuperLU( iopt, nprocs, n, nnz, nrhs, A % Values, A % Cols, &
              A % Rows, b, n, A % Umfpack_numeric, iinfo )
 
        if (iinfo .eq. 0) then
           write (*,*) 'Factorization succeeded'
        else
           write(*,*) 'INFO from factorization = ', iinfo
        endif
      END IF

      !
      ! Second, solve the system using the existing factors.
      iopt = 2
      call Solve_SuperLU( iopt, nprocs, n, nnz, nrhs, A % Values, A % Cols, &
           A % Rows,  b, n, A % Umfpack_numeric, iinfo )
      x(1:n) = b(1:n)
!
      if (iinfo .eq. 0) then
         write (*,*) 'Solve succeeded'
      else
         write(*,*) 'INFO from triangular solve = ', iinfo
      endif

! Last, free the storage allocated inside SuperLU
      FreeFactorize = ListGetLogical( Solver % Values, &
          'Linear System Free Factorization', stat )
      IF ( .NOT. stat ) FreeFactorize = .TRUE.

      IF ( Factorize .AND. FreeFactorize ) THEN
        iopt = 3
        call Solve_SuperLU( iopt, nprocs, n, nnz, nrhs, A % Values, A % Cols, &
                    A % Rows, b, n, A % Umfpack_numeric, iinfo )
        A % UmfPack_numeric = 0
      END IF
#endif      
!------------------------------------------------------------------------------
  END SUBROUTINE SuperLU_SolveSystem
!------------------------------------------------------------------------------




!------------------------------------------------------------------------------
  SUBROUTINE DirectSolver( A,x,b,Solver )
!------------------------------------------------------------------------------

    TYPE(Solver_t) :: Solver

    REAL(KIND=dp) :: x(*),b(*)
    TYPE(Matrix_t), POINTER :: A
!------------------------------------------------------------------------------

    LOGICAL :: GotIt
    CHARACTER(LEN=MAX_NAME_LEN) :: Method

!------------------------------------------------------------------------------

    Method = ListGetString( Solver % Values, 'Linear System Direct Method',GotIt )
    IF ( .NOT. GotIt ) Method = 'banded'

    SELECT CASE( Method )
      CASE( 'banded', 'symmetric banded' )
        IF ( .NOT. A % Complex ) THEN
           CALL BandSolver( A, x, b )
        ELSE
           CALL ComplexBandSolver( A, x, b )
        END IF

      CASE( 'umfpack', 'big umfpack' )
        CALL Umfpack_SolveSystem( Solver, A, x, b )

      CASE( 'mumps' )
        CALL Mumps_SolveSystem( Solver, A, x, b )

      CASE( 'superlu' )
        CALL SuperLU_SolveSystem( Solver, A, x, b )

      CASE DEFAULT
        CALL Fatal( 'DirectSolver', 'Unknown direct solver method.' )
    END SELECT

!------------------------------------------------------------------------------
  END SUBROUTINE DirectSolver
!------------------------------------------------------------------------------

END MODULE DirectSolve
