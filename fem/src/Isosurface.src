!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module for computing avarage normals for nodes
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback, Juha Ruokolainen
! *  Email:   Peter.Raback@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 20.06.2007
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
  SUBROUTINE IsosurfaceSolver_Init( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------
    USE DefUtils

    TYPE(Model_t)  :: Model
    TYPE(Solver_t) :: Solver
    REAL(KIND=dp) :: DT
    LOGICAL :: Transient
!------------------------------------------------------------------------------
    INTEGER :: dim
    TYPE(ValueList_t), POINTER :: SolverParams
!------------------------------------------------------------------------------
    SolverParams => GetSolverParams()
    IF ( .NOT. ListCheckPresent( SolverParams,'Variable') ) THEN
      dim = CoordinateSystemDimension()
      CALL ListAddString( SolverParams,  'Variable', '-nooutput Nrm_tmp' )
      CALL ListAddString( SolverParams,  'Exported Variable 1', 'Normals' )
      CALL ListAddInteger( SolverParams, 'Exported Variable 1 DOFs', dim )
      CALL ListAddString( SolverParams,  'Normals Result Variable', 'Normals')
    END IF
    CALL ListAddInteger( SolverParams, 'Time derivative order', 2 )
!------------------------------------------------------------------------------
  END SUBROUTINE IsosurfaceSolver_Init
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
SUBROUTINE IsosurfaceSolver( Model,Solver,dt,Transient )
!------------------------------------------------------------------------------

  USE CoordinateSystems
  USE DefUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Search isosurfaces
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh,materials,BCs,etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations (NOTE: Not used
!            currently)
!
!******************************************************************************

  TYPE(Model_t)  :: Model
  TYPE(Solver_t), TARGET :: Solver
  LOGICAL ::  Transient
  REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
  CHARACTER(LEN=MAX_NAME_LEN) :: LevelVariableName
  TYPE(Mesh_t), POINTER :: Mesh, IsoMesh
  INTEGER :: i,j,k,l,n
  REAL(KIND=dp) :: LevelValue

  INTEGER :: total, bricks, BrickToTetraMap(5,4), SaveNOFactive, SaveNOFBulk
  TYPE(Variable_t), POINTER :: LevelVariable
  LOGICAL :: Found
  INTEGER, ALLOCATABLE :: eperm(:)
  INTEGER, POINTER :: SaveActive(:)
  REAL(KIND=dp), ALLOCATABLE :: x(:),y(:),z(:)
  TYPE(Element_t), POINTER  :: SaveElements(:), NewElements(:), Element
 
  CALL Info( 'IsosurfaceSolver', '-------------------------------------',Level=4 )
  CALL Info( 'IsosurfaceSolver','Computing the isosurface',Level=4 )
  CALL Info( 'IsosurfaceSolver', '-------------------------------------',Level=4 )

  Mesh => GetMesh()

  BrickToTetraMap(1,:) = [1,2,4,5]
  BrickToTetraMap(2,:) = [6,7,2,5]
  BrickToTetraMap(3,:) = [3,4,2,7]
  BrickToTetraMap(4,:) = [8,7,5,4]
  BrickToTetraMap(5,:) = [2,4,5,7]
  bricks = 0
  DO i=1,Solver % NumberOfActiveElements
    Element => GetActiveElement(i)
    IF ( GetElementFamily()==8 ) bricks=bricks+1
  END DO
  total = 4*bricks + Solver % NumberOfActiveElements

  IF ( bricks>0  ) THEN
    SaveNOFBulk = Mesh % NumberOfBulkElements
    SaveActive => Solver % ACtiveElements
    SaveElements => Mesh % Elements
    SaveNOFActive = Solver % NumberOFActiveElements

    ALLOCATE(NewElements(total))

    j = 0
    DO i=1,Solver % NumberOfActiveElements
      Element => GetActiveElement(i)

      SELECT CASE(GetElementFamily())
      CASE(5)
         j = j + 1
         NewElements(j)=Element
      CASE(8)
          DO k=1,5
           j = j + 1
           NewElements(j)=Element
           NewElements(j) % Type => GetElementType(504)
           ALLOCATE(NewElements(j) % NodeIndexes(4))
           DO l=1,4
              NewElements(j) % NodeIndexes(l) = &
                 Element % NodeIndexes(BrickToTetraMap(k,l))
           END DO
         END DO
      END SELECT
    END DO
    Mesh % NumberOfBulkElements = total
    Mesh % Elements => NewElements
    ALLOCATE( Solver % ActiveElements(total) )
    DO i=1,total
      Solver % ActiveElements(i) = i
    END DO
    Solver % NumberOfActiveElements=total
  END IF

  IF ( .NOT. ASSOCIATED(Mesh % Edges) ) CALL FindMeshEdges3D(Mesh)

  LevelVariableName = GetString(GetSolverParams(), 'Isosurface Variable')
  LevelVariable => VariableGet( Mesh % Variables,LevelVariableName)

  n = Mesh % NumberOfEdges

  Isomesh => AllocateMesh()
  IsoMesh % Name = GetString( GetSolverParams(), & 
      'Isosurface output directory', Found )
  IF (.NOT. Found ) IsoMesh % Name = "isosurf"
  CALL MakeDirectory( TRIM(Isomesh % name) // CHAR(0) )

  Isomesh % Changed = .TRUE.
  Isomesh % OutputActive  = .TRUE.
  

  LevelValue = GetCReal( GetSolverParams(), &
     'Isosurface threshold', Found )

  CALL CreateNodes()
  CALL CreateSurfaces()

  IF ( Bricks>0 ) THEN
    DEALLOCATE(NewElements, Solver % ActiveElements)
    Mesh % NumberOfBulkElements = SaveNOFBulk
    Mesh % Elements => SaveElements
    Solver % ActiveElements => SaveActive
    Solver % NumberOfActiveElements = SaveNOFActive
  END IF

  Mesh => Model % Meshes
  DO WHILE( ASSOCIATED(Mesh % Next) )
    Mesh => Mesh % Next
  END DO
  Mesh % Next => Isomesh 

CONTAINS


  SUBROUTINE CreateNodes

    TYPE(Element_t), POINTER :: Edge
    INTEGER :: i,j,k,l,n1,n2,ints,comps
    REAL(KIND=dp) :: t,t1,t2,x1,x2,y1,y2,z1,z2

    CHARACTER(LEN=MAX_NAME_LEN) :: Vname(32)
    LOGICAL :: Found
    TYPE(Variable_t), POINTER :: V
    INTEGER, POINTER :: Vperm(:)
    REAL(KIND=dp), POINTER :: Vals(:), dummy(:)

    TYPE Varr_t
       REAL(KIND=dp), POINTER :: Vals(:)
    END TYPE Varr_t
    TYPE(Varr_t), POINTER :: Varr(:)


    ALLOCATE(x(n), y(n), z(n), eperm(n) )
    x = 0; y = 0; z = 0; eperm = 0;

    ints = 0
    DO WHILE(.TRUE.)
      ints = ints+1
      Vname(ints) = GetString( GetSolverParams(), &
          ComponentName('Isosurface interpolant',ints), Found )
      IF ( .NOT. Found ) THEN
        ints = ints-1
        EXIT
      END IF
    END DO

    IF ( ints>0 ) THEN
      ALLOCATE(Varr(ints))
      DO i=1,ints
        V => VariableGet( Mesh % Variables, Vname(i) )
        IF ( ASSOCIATED(V) ) THEN
          ALLOCATE(Varr(i) % vals(n*V%DOFs))
        END IF
      END DO
    END IF

    j = 0
    DO i=1,n
      Edge => Mesh % Edges(i)

      n1 = Edge % NodeIndexes(1)
      n2 = Edge % NodeIndexes(2)

      IF ( LevelVariable % Perm(n1)<=0 .OR. &
           LevelVariable % Perm(n2)<=0 ) CYCLE

      t1 = LevelVariable % Values(LevelVariable % Perm(n1))
      t2 = LevelVariable % Values(LevelVariable % Perm(n2))

      IF ( t1>LevelValue .AND. t2>LevelValue.OR. &
           t1<LevelValue .AND. t2<LevelValue) CYCLE 

      x1 = Mesh % Nodes % x(n1)
      x2 = Mesh % Nodes % x(n2)

      y1 = Mesh % Nodes % y(n1)
      y2 = Mesh % Nodes % y(n2)

      z1 = Mesh % Nodes % z(n1)
      z2 = Mesh % Nodes % z(n2)

      t = (LevelValue-t1)/(t2-t1)
      j = j+1
      eperm(i)=j
      x(j) = (1-t)*x1 + t*x2
      y(j) = (1-t)*y1 + t*y2
      z(j) = (1-t)*z1 + t*z2

      DO k=1,ints
        V => VariableGet(Mesh % Variables, Vname(ints))
        IF (ASSOCIATED(V)) THEN
          DO l=1,V % DOFs
            x1 = 0; x2 = 0;
            IF ( V % Perm(n1)>0 ) &
              x1  = V % Values(V % DOFs*(V % Perm(n1)-1)+l)
            IF ( V % Perm(n2)>0 ) &
              x2  = V % Values(V % DOFs*(V % Perm(n2)-1)+l)
            Varr(k) % Vals(V % DOFs*(j-1)+l) = (1-t)*x1 + t*x2
          END DO
        END IF
      END DO

      write(1,*) x(j),y(j),z(j)
    END DO

    
    ALLOCATE( IsoMesh % Nodes )
    Isomesh % NumberOfNodes = j
    Isomesh % Nodes % NumberOfNodes = j

    ALLOCATE( IsoMesh % Nodes % x(j) )
    ALLOCATE( IsoMesh % Nodes % y(j) )
    ALLOCATE( IsoMesh % Nodes % z(j) )

    IsoMesh % Nodes % x = x(1:j)
    IsoMesh % Nodes % y = y(1:j)
    IsoMesh % Nodes % z = z(1:j)
    DEALLOCATE(x,y,z)

    CALL VariableAdd( IsoMesh % Variables, IsoMesh,Solver, &
       'Coordinate 1',1,IsoMesh % Nodes % x )

    CALL VariableAdd( IsoMesh % Variables,IsoMesh,Solver, &
       'Coordinate 2',1,IsoMesh % Nodes % y )

    CALL VariableAdd( IsoMesh % Variables,IsoMesh,Solver, &
       'Coordinate 3',1,IsoMesh % Nodes % z )

    ALLOCATE( dummy(1) )
    CALL VariableAdd( Isomesh % Variables, Isomesh, Solver, 'Time', 1, dummy )

    IF ( ints>0 ) THEN
      DO i=1,ints
        ALLOCATE( Vperm(j),Vals(V % DOFs*j) )
        Vperm = [(i,i=1,j)]
        Vals = Varr(i) % Vals(1:V % DOFs*j)
        DEALLOCATE( Varr(i) % Vals )
        CALL VariableAddVector( Isomesh % Variables, Isomesh, Solver, &
             TRIM(Vname(i)), V % DOFs, Vals, Vperm )
      END DO
      DEALLOCATE(Varr)
    END IF
  END SUBROUTINE CreateNodes


  SUBROUTINE CreateSurfaces()
     TYPE(Element_t), POINTER :: Element, DefElement
     REAL(KIND=dp) :: F(4)
     INTEGER :: i,j,k,n,Triangles(2,3)
     INTEGER, ALLOCATABLE :: TriangleStore(:,:)

     ALLOCATE(TriangleStore(2*Solver % NumberOfActiveElements,3))
     k = 0
     DO i=1,Solver % NumberOfActiveElements
       Element => GetActiveElement(i)
       F(1:4) = LevelVariable % Values( &
           LevelVariable % Perm(Element % NodeIndexes) )
       n=CreateSurfaceFromTetra(Element,F,LevelValue,Triangles)
       IF ( ANY(Triangles(1:n,:)<=0) ) CYCLE

       Triangles = Triangles-1
       DO j=1,n
         k = k + 1
         TriangleStore(k,:) = Triangles(j,:)+1
         WRITE(2,*) 's 303 ', Triangles(j,1),Triangles(j,2),Triangles(j,3)
       END DO
     END DO
     ALLOCATE( Isomesh % Elements(k) )
     DefElement => AllocateElement()

     Isomesh % NumberOfBulkElements = k
     Isomesh % NumberOfFaces = 0
     Isomesh % NumberOfEdges = 0
     Isomesh % NumberOfBoundaryElements = 0
     DO i=1,k
       Isomesh % Elements(i) = DefElement
       Isomesh % Elements(i) % Type => GetElementType(303)
       Isomesh % Elements(i) % Bodyid = 1
       Isomesh % Elements(i) % EdgeIndexes => Null()
       ALLOCATE(Isomesh % Elements(i) % NodeIndexes(3))
       Isomesh % Elements(i) % NodeIndexes = TriangleStore(i,:)
     END DO
     DEALLOCATE(DefElement)
  END SUBROUTINE CreateSurfaces


  FUNCTION CreateSurfaceFromTetra(Tetra,F,K,Surf) RESULT(scount)
    TYPE(Element_t) :: Tetra
    REAL(KIND=dp) :: F(0:3), K
    INTEGER :: scount, Surf(2,3)

    LOGICAL :: S0,S1,S2,S3
    integer :: S,H,i,j,l
    INTEGER :: TetraEdgeMap(6,2), Indexes(6)

    scount = 0
    Indexes = eperm(Tetra % EdgeIndexes)

    S0 = F(0) > K;
    S1 = F(1) > K;
    S2 = F(2) > K;
    S3 = F(3) > K;

    S = 0
    IF ( s0 ) S=S+1
    IF ( s1 ) S=S+1
    IF ( s2 ) S=S+1
    IF ( s3 ) S=S+1

    IF ( S==0 .OR. S==4 ) RETURN

    IF ( S==1 .OR. S==3 ) THEN
      IF ( (S==1 .AND. S0) .OR. (S==3 .AND. .NOT.S0) ) THEN
        H = 1;
      ELSE IF ( (S==1 .AND. S1) .OR. (S==3 .AND. .NOT.S1) ) THEN
        H = 2;
      ELSE IF ( (S==1 .AND. S2) .OR. (S==3 .AND. .NOT.S2) ) THEN
        H = 3;
      ELSE IF ( (S==1 .AND. S3) .OR. (S==3 .AND. .NOT.S3) ) THEN
        H = 4;
      ELSE
        scount = 0
        RETURN
      END IF

      TetraEdgeMap(1,:) = (/ 1,2 /)
      TetraEdgeMap(2,:) = (/ 2,3 /)
      TetraEdgeMap(3,:) = (/ 3,1 /)
      TetraEdgeMap(4,:) = (/ 1,4 /)
      TetraEdgeMap(5,:) = (/ 2,4 /)
      TetraEdgeMap(6,:) = (/ 3,4 /)

      l = 0
      DO i=1,6
        DO j=1,2
          IF ( TetraEdgeMap(i,j)==H ) THEN
            l = l + 1
            Surf(1,l)=Indexes(i)
            EXIT
          END IF
        END DO
      END DO
      scount = 1
      RETURN
    ELSE
      IF ( (S0 .AND. S1) .OR. (.NOT.S0 .AND. .NOT.S1) ) THEN
        Surf(1,1) = Indexes(3)
        Surf(1,2) = Indexes(2)
        Surf(1,3) = Indexes(5)

        Surf(2,1) = Indexes(3)
        Surf(2,2) = Indexes(5)
        Surf(2,3) = Indexes(4)
      ELSE IF ( (S0 .AND. S2) .OR. (.NOT.S0 .AND. .NOT.S2) ) THEN
        Surf(1,1) = Indexes(1)
        Surf(1,2) = Indexes(2)
        Surf(1,3) = Indexes(6)

        Surf(2,1) = Indexes(1)
        Surf(2,2) = Indexes(6)
        Surf(2,3) = Indexes(4)
      ELSE IF ( (S0 .AND. S3) .OR. (.NOT.S0 .AND. .NOT.S3) ) THEN
        Surf(1,1) = Indexes(1)
        Surf(1,2) = Indexes(5)
        Surf(1,3) = Indexes(6)

        Surf(2,1) = Indexes(1)
        Surf(2,2) = Indexes(6)
        Surf(2,3) = Indexes(3)
      END IF
      scount=2
      RETURN
    END IF
  END FUNCTION CreateSurfaceFromTetra

!------------------------------------------------------------------------------
END SUBROUTINE IsosurfaceSolver
!------------------------------------------------------------------------------
