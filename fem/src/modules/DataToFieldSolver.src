!/******************************************************************************
! * Solvers by Galerkin method the problem where a continuous field is 
! * fitted to the data. The data may be created in advance or it may be 
! * given as a property of discrete particles. The data has a contribution
! * on the r.h.s. of the equation only. 
! * 
! * There are two different variations
! * 1) without normalization it is assumed that the r.h.s is already physically
! *    relevant sum of the data.
! * 2) with normalization it is assumed that the r.h.s. scales with the weight
! *    and division by weight is needed to obtain a statistical average.
! *    In both cases regularization by a diffusion coefficient may be used but 
! *    it is essenitial only in the latter.
! ******************************************************************************
! *
! *  Authors: Peter Råback & Juha Ruokolainen
! *  Email:   Peter.Raback@csc.fi & Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 16.6.2011
! *
! *****************************************************************************/


!------------------------------------------------------------------------------
!> Solvers by Galerkin method the problem where a continuous field is 
!> fitted to data. The data may be created in advance or it may be 
!> given as a property of discrete particles. The data has a contribution
!> on the r.h.s. of the equation only. Regularization (i.e. diffusion) may be
!> added to reduce noise from the fitting of the data.
!> \ingroup Solvers
!------------------------------------------------------------------------------
SUBROUTINE DataToFieldSolver( Model,Solver,dt,TransientSimulation )
  
  USE DefUtils
  USE Interpolation
  USE MeshUtils
  USE ElementUtils
  USE ParticleUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
  
! local variables
!------------------------------------------------------------------------------  
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Variable_t), POINTER :: Var 
  REAL(KIND=dp), POINTER :: WeightVector(:),ForceVector(:),MaskVector(:)
  INTEGER, POINTER :: WeightPerm(:),ForcePerm(:),MaskPerm(:)
  REAL(KIND=dp) :: Norm, MinMaskVal, MaxMaskVal
  LOGICAL :: GivenNormalize, NodalNormalize, Found, Found2, Mask, MaskDiffusion, &
      ConstantWeightSum
  CHARACTER(LEN=MAX_NAME_LEN) :: VarName, FileName


  CALL Info('DataToFieldSolver','-----------------------------------------', Level=4 )
  CALL Info('DataToFieldSolver','Resolving field from given data',Level=4) 

  
  ! The variable containing the field contributions
  !------------------------------------------------------------------------
  Params => GetSolverParams()
  VarName = GetString( Params,'Data Field Name',Found)
  IF(.NOT. Found ) VarName = GetString( Params,'Target Variable',Found)
  IF(.NOT. Found ) THEN
    CALL Fatal('DataToFieldSolver','> Target Variable < must exist for the solver!')
  END IF

  Var => VariableGet(Solver % Mesh % Variables, VarName )
  IF( ASSOCIATED( Var ) ) THEN    
    ForceVector => Var % Values
    ForcePerm => Var % Perm
  ELSE
    CALL Fatal('DataToFieldSolver','Variable not present:'//TRIM(VarName))      
  END IF

  ! If normalization is requested then need the vector of weights as well
  !------------------------------------------------------------------------
  GivenNormalize = GetLogical( Params,'Normalize by Given Weight',Found)
  IF(.NOT. GivenNormalize ) THEN
    GivenNormalize = GetLogical( Params,'Normalize Data by Weight',Found)
  END IF
  IF( GivenNormalize ) THEN
    VarName = GetString( Params,'Weight Field Name',Found)
    IF(.NOT. Found) VarName = GetString( Params,'Weight Variable',Found)
    IF(.NOT. Found ) THEN
      CALL Fatal('DataToFieldSolver','> Weight Variable < must exist for the solver!')
    END IF    
    Var => VariableGet(Solver % Mesh % Variables, VarName )
    IF( ASSOCIATED( Var ) ) THEN    
      WeightVector => Var % Values
      WeightPerm => Var % Perm
    ELSE
      CALL Fatal('DataToFieldSolver','Variable not present: '//TRIM(VarName))      
    END IF
    CALL Info('DataToFieldSolver','Normalizing source using: '//TRIM(VarName),Level=6) 

    ConstantWeightSum = GetLogical( Params,'Set Constant Weight Sum',Found)
  END IF
  
  NodalNormalize = GetLogical( Params,'Normalize by Nodal Weight',Found)    
  CALL Info('DataToFieldSolver','Normalizing source using nodal weight',Level=6) 

  IF( GivenNormalize .AND. NodalNormalize ) THEN
    CALL Fatal('DataToFieldSolver','Normalization cannot be both given and nodal!')
  END IF


  ! The variable containing the field contributions
  !------------------------------------------------------------------------
  MaskDiffusion = .FALSE.
  VarName = ListGetString( Params,'Mask Field Name', Mask )
  IF(.NOT. Mask) VarName = ListGetString( Params,'Mask Variable',Mask )
  IF( Mask ) THEN
    Var => VariableGet(Solver % Mesh % Variables, VarName )
    IF( ASSOCIATED( Var ) ) THEN    
      MaskVector => Var % Values
      MaskPerm => Var % Perm
    ELSE
      CALL Fatal('DataToFieldSolver','Variable not present: '//TRIM(VarName))      
    END IF
    CALL Info('DataToFieldSolver','Masking source using: '//TRIM(VarName),Level=6) 

    MaxMaskVal = ListGetCReal( Params,'Max Mask Value',Found ) 
    IF(.NOT. Found) MaxMaskVal = HUGE( MaxMaskVal )
    MinMaskVal = ListGetCReal( Params,'Min Mask Value',Found2 )
    IF(.NOT. Found2 ) THEN
      IF(.NOT. Found ) THEN
        MinMaskVal = 0.0_dp
      ELSE
        MinMaskVal = -HUGE(MinMaskVal) 
      END IF
    END IF      
    MaskDiffusion = GetLogical( Params,'Mask Diffusion',Found )
    IF( MaskDiffusion ) THEN
      CALL Info('DataToFieldSolver','Masking diffusion terms',Level=6) 
    END IF
  END IF


  ! If the data is retrieved from ascii table then map that into mesh
  ! Only the r.h.s. is assemblied here. 
  !------------------------------------------------------------------------
  Filename = GetString( Params,'Point Data Filename',Found)
  IF( Found ) THEN
    CALL AsciiPointsToMesh()
  END IF


  ! Create the matrix equation with r.h.s. data and regularization
  !------------------------------------------------------------------------
  CALL DefaultInitialize()  

  CALL BulkAssembly()
  CALL DefaultFinishBulkAssembly()

  CALL BoundaryAssembly()

  CALL DefaultFinishAssembly()

  CALL DefaultDirichletBCs()

  ! Solver the matrix 
  !------------------------------------------------------------------------
  Norm = DefaultSolve()

  CALL Info('DataToFieldSolver','All done', Level=4 )
  CALL Info('DataToFieldSolver','-----------------------------------------', Level=4 )
  
  
CONTAINS 
  

  !------------------------------------------------------------------------
  !> Go through list of given points and add their contribution to FE mesh.
  !-------------------------------------------------------------------------
  SUBROUTINE AsciiPointsToMesh()
    
    INTEGER :: i,j,n,dim,No,NoPoints,ElementIndex=0
    INTEGER, POINTER :: NodeIndexes(:),FieldPerm(:)
    REAL(KIND=dp) :: SqrtElementMetric, Weight,u,v,w,LocalCoords(3),val,InputData(4)
    REAL(KIND=dp), POINTER :: Basis(:), dBasisdx(:,:)
    LOGICAL :: AllocationsDone = .FALSE., Stat
    TYPE(Nodes_t) :: ElementNodes
    REAL(KIND=dp) :: GlobalCoords(3)
    TYPE(Mesh_t), POINTER :: Mesh
    TYPE(Element_t), POINTER :: CurrentElement
    

    SAVE :: AllocationsDone, ElementIndex, Basis, dBasisdx, ElementNodes
    
    Mesh => Solver % Mesh
    FieldPerm => Solver % Variable % Perm

    n = Mesh % MaxElementNodes
    ALLOCATE(ElementNodes % x(n), ElementNodes % y(n), ElementNodes % z(n), &
        Basis(n), dBasisdx(n,3) )

    
    NoPoints = ListGetInteger( Params,'Number Of Points' ) 
    GlobalCoords(3) = 0.0_dp
    dim = Mesh % MeshDim

    OPEN(10,FILE = Filename)
     
    DO No=1, NoPoints     
      READ(10,*) InputData(1:dim+1)

      val = InputData(3)
      GlobalCoords(1:dim) = InputData(1:dim)
      val = InputData(dim+1)

      CALL LocateParticleInMeshOctree( ElementIndex, GlobalCoords, LocalCoords )
      IF( ElementIndex == 0 ) CYCLE
    
      CurrentElement => Mesh % Elements( ElementIndex )
      n = CurrentElement % TYPE % NumberOfNodes
      NodeIndexes => CurrentElement % NodeIndexes
      CALL GetElementNodes(ElementNodes,CurrentElement)
      
      u = LocalCoords(1)
      v = LocalCoords(2)
      w = LocalCoords(3)
      
      stat = ElementInfo( CurrentElement, ElementNodes, U, V, W, SqrtElementMetric, &
          Basis, dBasisdx )
      
      DO i = 1,n
        j = FieldPerm( NodeIndexes(i) )
        IF( j == 0 ) CYCLE
        
        ! As the weight should be proporpotional to the particle amount rather than
        ! element volume the weight is not multiplied with local element size!
        ! Note that the weight could be also ~1/r^2 from the nodes etc. 
        !-------------------------------------------------------------------------
        weight = Basis(i)
        
        WeightVector( j ) = WeightVector( j ) + weight 
 
        ForceVector( j ) = ForceVector( j ) + weight * val
      END DO      
    END DO

    CLOSE(10) 

  END SUBROUTINE AsciiPointsToMesh
   


  !------------------------------------------------------------------------
  ! Assemble the matrix equation 
  !-------------------------------------------------------------------------
  SUBROUTINE BulkAssembly()
    
    INTEGER, POINTER :: BoundaryPerm(:), Indexes(:)
    INTEGER :: i,j,k,t,n,istat,active,BoundaryNodes,dim,MaskActive
    TYPE(Element_t), POINTER :: Element
    TYPE(GaussIntegrationPoints_t) :: IP
    CHARACTER(LEN=MAX_NAME_LEN) :: BoundaryName
    TYPE(Nodes_t) :: Nodes
    REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:), FORCE(:), NodalWeight(:)
    REAL(KIND=dp), POINTER :: Basis(:), dBasisdx(:,:)
    REAL(KIND=dp) :: Coeff, detJ, RealWeightSum, IdealWeightSum, WeightCorr, val
    TYPE(Matrix_t), POINTER :: StiffMatrix 
    LOGICAL :: stat, Visited = .FALSE.
    
    
    SAVE Visited, BoundaryPerm, Nodes, STIFF, FORCE, Basis, dBasisdx
    

    IF(.NOT. Visited) THEN
      Visited = .TRUE.
      N = Solver % Mesh % MaxElementNodes 
      ALLOCATE( Basis(n), dBasisdx(n, 3), FORCE(N), STIFF(N,N), STAT=istat )
      
!      N = Solver % Mesh % NumberOfNodes
!      ALLOCATE( BoundaryPerm(n) )
!      BoundaryPerm = 0
!      BoundaryNodes = 0
!      BoundaryName = 'Data To Field Boundary'
!      CALL MakePermUsingMask( CurrentModel,Solver,Solver % Mesh,BoundaryName, &
!          .FALSE., BoundaryPerm, BoundaryNodes )
!      IF( BoundaryNodes > 0 ) THEN
!        WRITE( Message,'(A,I0)') 'Nodes at > Data To Field Boundary < : ',BoundaryNodes
!        CALL Info('DataToFieldSolver',Message,Level=6)
!      END IF

    END IF
    
    ! Assembly the diffusion part used for regularization
    !----------------------------------------------------------
    Coeff = GetCReal( Solver % Values,'Diffusion Coefficient')
    active = GetNOFActive()
    StiffMatrix => Solver % Matrix
    IF(.NOT. ASSOCIATED( StiffMatrix ) ) THEN
      CALL Fatal('DataToFieldSolver','StiffMatrix not associated!')
    END IF

    dim = Solver % Mesh % MeshDim
    n = StiffMatrix % NumberOfRows
    ALLOCATE( NodalWeight( n ) )
    NodalWeight = 0.0_dp
    IdealWeightSum = 0.0_dp

    DO t=1,active

      Element => GetActiveElement(t)
      n = GetElementNOFNodes(Element)
      Indexes => Element % NodeIndexes
      
      CALL GetElementNodes( Nodes, Element )
      STIFF = 0.0d0
      FORCE = 0.0d0
      
      ! Numerical integration:
      !----------------------
      IP = GaussPoints( Element )
      DO k=1,IP % n
        ! Basis function values & derivatives at the integration point:
        !--------------------------------------------------------------
        stat = ElementInfo( Element, Nodes, IP % U(k), IP % V(k), &
            IP % W(k),  detJ, Basis, dBasisdx )
        
        ! Finally, the elemental matrix & vector:
        !----------------------------------------
        DO i=1,n

          ! Compute the rowsum that is used in the normalization
          !-----------------------------------------------------
          val = IP % s(k) * DetJ * Basis(i)        
          j = Indexes(i)
          NodalWeight( j ) = NodalWeight( j ) + val

          ! This condition should remove the diffusion for proper data, and 
          ! use it only for outlier data.
          !----------------------------------------------------------------
          IF( MaskDiffusion ) THEN
            val = MaskVector( MaskPerm( Indexes(i) ) )
            IF( .NOT. (val < MinMaskVal .OR. val > MaxMaskVal ) ) CYCLE
          END IF
          
          ! This condition removes the natural boundary condition that would 
          ! try to fix the normal gradient of the field to zero.
          ! Does not seem to work though...
          !--------------------------------------------------------------------
          ! IF( BoundaryPerm( Indexes(i) ) > 0 ) CYCLE

          DO j=1,n
            STIFF(i,j) = STIFF(i,j) + IP % s(k) * Coeff * DetJ * &
                SUM( dBasisdx(i,1:dim) * dBasisdx(j,1:dim) ) 
          END DO
        END DO
      END DO
      
      CALL DefaultUpdateEquations( STIFF, FORCE )
    END DO
    IdealWeightSum = SUM( NodalWeight ) 

    MaskActive = 0
    IF( GivenNormalize ) THEN
      !-----------------------------------------------------------------------
      ! Set the weight to the diagonal i.e. make the mass matrix contribution  
      ! The data is normalized so that if it would be constant it would yield the 
      ! same equation as the normal one and the weights would also be constant.
      ! This way diffusion will not depend on the amount of data, whether
      ! that is desirable, or not, I don't know. 
      !-----------------------------------------------------------------------
      RealWeightSum = SUM( WeightVector ) 
      IF( ConstantWeightSum ) THEN
        WeightCorr = IdealWeightSum / RealWeightSum 
      ELSE
        WeightCorr = 1.0_dp
      END IF
      StiffMatrix % Values( StiffMatrix % Diag ) = &
          StiffMatrix % Values( StiffMatrix % Diag) + &
          WeightCorr * WeightVector
      StiffMatrix % rhs = WeightCorr * ForceVector        
    ELSE IF( NodalNormalize ) THEN
      IF( Mask ) THEN
        DO i=1,SIZE(MaskVector) 
          val = MaskVector(i)
          IF( val < MinMaskVal .OR. val > MaxMaskVal ) CYCLE

          MaskActive = MaskActive + 1
          StiffMatrix % rhs(i) = Forcevector(i) 
          StiffMatrix % Values( StiffMatrix % Diag(i) ) = NodalWeight(i)
        END DO
      ELSE
        StiffMatrix % rhs = ForceVector
        StiffMatrix % Values( StiffMatrix % Diag ) = &
            StiffMatrix % Values( StiffMatrix % Diag) + NodalWeight
      END IF
    ELSE
      IF( Mask ) THEN
        DO i=1,SIZE(MaskVector) 
          val = MaskVector(i)
          IF( val < MinMaskVal .OR. val > MaxMaskVal ) CYCLE

          MaskActive = MaskActive + 1
          StiffMatrix % rhs(i) = NodalWeight(i) * Forcevector(i) 
          StiffMatrix % Values( StiffMatrix % Diag(i) ) = NodalWeight(i)
        END DO
      ELSE
        StiffMatrix % rhs = NodalWeight * ForceVector
        StiffMatrix % Values( StiffMatrix % Diag ) = &
            StiffMatrix % Values( StiffMatrix % Diag) + NodalWeight
      END IF
    END IF

    IF( Mask ) THEN
      WRITE( Message,'(A,I0,A,I0,A)') 'Mask is active for ',MaskActive,&
          ' nodes (out of ',SIZE(MaskVector),')'
      CALL Info('DataToFieldSolver',Message,Level=4)
    END IF
    
  END SUBROUTINE BulkAssembly
  
!------------------------------------------------------------------------------
  SUBROUTINE BoundaryAssembly()
!------------------------------------------------------------------------------
    INTEGER :: t,n,np
    TYPE(Element_t), POINTER :: Element,ParentElement
    TYPE(ValueList_t), POINTER :: BC
    LOGICAL :: Found
    CHARACTER(LEN=MAX_NAME_LEN) :: CondName

    CondName = ComponentName( Solver % Variable )
    CondName = TRIM( CondName ) //' continue'

    DO t=1,GetNOFBoundaryElements()
      
      Element => GetBoundaryElement(t)
      IF(.NOT. ActiveBoundaryElement(Element)) CYCLE
      
      BC => GetBC( Element ) 
      IF(.NOT. GetLogical( BC, CondName ,Found)) CYCLE

      n  = GetElementNOFNodes(Element)
      
      ParentElement => Element % BoundaryInfo % Left
      IF( .NOT. ASSOCIATED( ParentElement ) ) THEN
        CALL Fatal('DataToFieldSolver','Could not find parent element!')
      ELSE IF( ASSOCIATED( Element % BoundaryInfo % Right ) ) THEN
        CALL Fatal('DataToFieldSolver','This does not make sense for internal BC!')
      END IF

      np  = GetElementNOFNodes(ParentElement)

      CALL BoundaryLocalMatrix( Element, ParentElement, n, np )
    END DO
!------------------------------------------------------------------------------
  END SUBROUTINE BoundaryAssembly
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE BoundaryLocalMatrix( Element, ParentElement, n, np )
!------------------------------------------------------------------------------
    INTEGER :: n, np
    TYPE(Element_t), POINTER :: Element, ParentElement
!------------------------------------------------------------------------------
    REAL(KIND=dp), TARGET :: STIFF(np,np), FORCE(np)
    REAL(KIND=dp), POINTER :: A(:,:),M(:,:)    
    REAL(KIND=dp) :: Basis(n),dBasisdx(n,3), s, DetJ,u,v,w
    REAL(KIND=dp) :: ParentBasis(np),ParentdBasisdx(np,3)
    REAL(KIND=dp) :: Nrm(3),Coeff
    LOGICAL :: Stat,Found
    INTEGER :: i,j,p,q,t,dim
    TYPE(GaussIntegrationPoints_t) :: IP
    TYPE(Nodes_t), SAVE :: Nodes, ParentNodes
!------------------------------------------------------------------------------
    dim = Solver % Mesh % MeshDim
    
    Coeff = GetCReal( Solver % Values,'Diffusion Coefficient')

    CALL GetElementNodes( Nodes,Element )
    CALL GetElementNodes( ParentNodes,ParentElement )

    STIFF = 0.0_dp
    FORCE = 0.0_dp

    !Numerical integration:
    !----------------------
    IP = GaussPoints( Element )
    DO t=1,IP % n
      u =  IP % U(t)
      v =  IP % V(t)
      w =  IP % W(t)

      stat = ElementInfo( Element, Nodes, u, v, w, detJ, Basis, dBasisdx )
      
      s = IP % s(t) * DetJ
      Nrm = NormalVector(Element,Nodes,u,v, .TRUE.)

      CALL GetParentUVW(Element, n, ParentElement, np, U, V, W, Basis)

      stat = ElementInfo(ParentElement, ParentNodes, U, V, W, detJ, &
          ParentBasis, ParentdBasisdx)

      DO p=1,np
        DO q=1,np
          STIFF(p,q) = STIFF(p,q) - s * Coeff * ParentBasis(p)* &
              SUM( ParentdBasisDx(q,1:dim) * Nrm(1:dim) )
        END DO
      END DO
    END DO

    CALL DefaultUpdateEquations( STIFF, FORCE, UElement=ParentElement )

!------------------------------------------------------------------------------
  END SUBROUTINE BoundaryLocalMatrix
!------------------------------------------------------------------------------

END SUBROUTINE DataToFieldSolver

!-------------------------------------------------------------------
!> Default initialization for the primary solver.
!-------------------------------------------------------------------
SUBROUTINE DataToFieldSolver_init( Model,Solver,dt,TransientSimulation )

  USE DefUtils
  USE Lists

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t) :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
  
! local variables
!------------------------------------------------------------------------------
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: GivenNormalize, NodalNormalize, Found, HaveFile
  CHARACTER(LEN=MAX_NAME_LEN) :: VarName
  

  Params => GetSolverParams()

  HaveFile = ListCheckPresent( Params,'Point Data Filename')

  GivenNormalize = GetLogical( Params,'Normalize by Given Weight',Found)
  IF(.NOT. GivenNormalize) GivenNormalize = GetLogical( Params,'Normalize Data by Weight',Found)

  ! If the file is given then the two following fields will be created internally
  ! and one can allocate them here, if not given otherwise. 
  !-----------------------------------------------------------------------------
  VarName = GetString( Params,'Target Variable',Found)
  IF(.NOT. Found .AND. HaveFile ) THEN
    CALL ListAddString( Params,&
        NextFreeKeyword('Exported Variable',Params),'Point Data')
    CALL ListAddString( Params,'Target Variable','Point Data')
    CALL Info('DataToFieldSolver_init','Creating > Point Data < as exported variable')
  END IF

  IF( GivenNormalize .AND. HaveFile ) THEN
    VarName = GetString( Params,'Weight Variable',Found)
    IF(.NOT. Found ) THEN
      CALL ListAddString( Params,&
          NextFreeKeyword('Exported Variable',Params),'Point Weight')
      CALL ListAddString( Params,'Weight Variable','Point Weight')
      CALL Info('DataToFieldSolver_init','Creating > Point Weight < as exported variable')
    END IF
  END IF

  ! If the field is not given, create it
  ! A different default name if point data set is used.
  !-----------------------------------------------------
  VarName = GetString( Params,'Variable',Found)
  IF(.NOT. Found ) THEN
    IF( HaveFile ) THEN
      CALL ListAddString( Params,'Variable','Point Fit')     
    ELSE
      CALL ListAddString( Params,'Variable','Fit')
    END IF
  END IF


  CALL ListAddInteger( Params, 'Time derivative order', 0 )
  
  ! Add some cheap linear system defaults: bicgstab + none (diagonal when scaled)
  !------------------------------------------------------------------------
  IF(.NOT. ListCheckPresent(Params,'Linear System Solver')) &
      CALL ListAddString(Params,'Linear System Solver','Iterative')
  IF(.NOT. ListCheckPresent(Params,'Linear System Iterative Method')) &
      CALL ListAddString(Params,'Linear System Iterative Method','bicgstab')
  IF(.NOT. ListCheckPresent(Params,'Linear System Preconditioning')) &
      CALL ListAddString(Params,'Linear System Preconditioning','none')
  IF(.NOT. ListCheckPresent(Params,'Linear System Max Iterations')) &
      CALL ListAddInteger(Params,'Linear System Max Iterations',1000)
  IF(.NOT. ListCheckPresent(Params,'Linear System Residual Output')) &
      CALL ListAddInteger(Params,'Linear System Residual Output',20)
  IF(.NOT. ListCheckPresent(Params,'Linear System Convergence Tolerance')) &
      CALL ListAddConstReal(Params,'Linear System Convergence Tolerance',1.0e-10_dp)
  
END SUBROUTINE DataToFieldSolver_init
