 
MODULE ParticleUtils

   USE DefUtils

CONTAINS


SUBROUTINE AllocateParticles(Particles,NoParticles,dim,TimeOrder)

  TYPE(Particle_t) :: Particles
  INTEGER :: NoParticles
  INTEGER, OPTIONAL :: dim
  INTEGER, OPTIONAL :: TimeOrder

  REAL(KIND=dp), POINTER :: Velocity(:,:), Coordinate(:,:), Distance(:)
  INTEGER, POINTER :: Status(:), ElementIndex(:), PartIndex(:)
  INTEGER :: PrevNoParticles, dofs
  
  IF( NoParticles <= Particles % MaxNumberOfParticles ) THEN
    CALL Info('AllocateParticles','There are already enough particles')
    RETURN
  ELSE
    WRITE(Message,*) 'Allocating number of particles:',NoParticles
    CALL Info('AllocateParticles',Message)    
  END IF
  IF(PRESENT(TimeOrder)) THEN
    Particles % TimeOrder = TimeOrder
  ELSE
    Particles % TimeOrder = 1
  END IF

  IF( .NOT. PRESENT( dim ) ) THEN
    dofs = 3 
  ELSE
    IF( dim == 2 .OR. dim == 3 ) THEN
      dofs = dim
    ELSE
      CALL Warn('AllocateParticles','Invalid dimension')
      RETURN
    END IF
  END IF
  Particles % dim = dofs

  IF( Particles % MaxNumberOfParticles == 0 ) THEN
    ALLOCATE( Particles % Coordinate(NoParticles,dofs))
    ALLOCATE( Particles % Distance(NoParticles))
    ALLOCATE( Particles % Dt(NoParticles))
    ALLOCATE( Particles % Status(NoParticles))
    ALLOCATE( Particles % ElementIndex(NoParticles))

    Particles % Coordinate = 0.0_dp
    Particles % Distance = 0.0_dp
    Particles % Dt = 0.0_dp
    Particles % Status = PARTICLE_ALLOCATED
    Particles % ElementIndex = 0
    Particles % MaxNumberOfParticles = NoParticles

    IF( Particles % TimeOrder >= 1 ) THEN
      ALLOCATE( Particles % Velocity(NoParticles,dofs))
      Particles % Velocity = 0.0_dp
    END IF

    IF( Particles % TimeOrder >= 2 ) THEN
      ALLOCATE( Particles % Acceleration(NoParticles,dofs) )
      Particles % Acceleration = 0.0_dp
    END IF

    IF(  ParEnv % PEs > 1 ) THEN
      ALLOCATE( Particles % PartIndex(NoParticles))
      Particles % PartIndex = ParEnv % myPE 
    END IF

  ELSE 
    PrevNoParticles = Particles % MaxNumberOfParticles 

    CALL Warn('AllocateParticles','Check some of the components!')

    Coordinate => Particles % Coordinate
    Velocity => Particles % Velocity
    Distance => Particles % Distance
    Status => Particles % Status
    ElementIndex => Particles % ElementIndex

    ALLOCATE( Particles % Velocity(NoParticles,dofs) )
    ALLOCATE( Particles % Coordinate(NoParticles,dofs) )
    ALLOCATE( Particles % Distance(NoParticles) )
    ALLOCATE( Particles % Status(NoParticles) )
    ALLOCATE( Particles % ElementIndex(NoParticles) )

    Particles % Coordinate(1:PrevNoParticles,:) = Coordinate
    Particles % Velocity(1:PrevNoParticles,:) = Velocity 
    Particles % Distance(1:PrevNoParticles) = Distance
    Particles % Status(1:PrevNoParticles) = Status
    Particles % ElementIndex(1:PrevNoParticles) = ElementIndex
    DEALLOCATE(Velocity, Coordinate, Distance, Status, ElementIndex ) 

    Particles % Velocity(PrevNoParticles+1:NoParticles,:) = 0.0_dp
    Particles % Coordinate(PrevNoParticles+1:NoParticles,:) = 0.0_dp
    Particles % Distance(PrevNoParticles+1:NoParticles) = 0.0_dp
    Particles % Status(PrevNoParticles+1:NoParticles) = PARTICLE_ALLOCATED
    Particles % ElementIndex(PrevNoParticles+1:NoParticles) = 0

    IF(  ParEnv % PEs > 1 ) THEN
      PartIndex => Particles % PartIndex 
      ALLOCATE( Particles % PartIndex(NoParticles))
      Particles % PartIndex(1:PrevNoParticles) = PartIndex
      DEALLOCATE( PartIndex )
      Particles % PartIndex(PrevNoParticles+1:NoParticles) = ParEnv % myPE
    END IF

    Particles % MaxNumberOfParticles = NoParticles
  END IF
END SUBROUTINE AllocateParticles



SUBROUTINE DestroyParticles(Particles) 
  TYPE(Particle_t) :: Particles

  DEALLOCATE( Particles % Velocity ) 
  DEALLOCATE( Particles % Coordinate ) 
  DEALLOCATE( Particles % Distance ) 
  DEALLOCATE( Particles % Dt ) 
  DEALLOCATE( Particles % Status ) 
  DEALLOCATE( Particles % ElementIndex ) 
  IF(  ParEnv % PEs > 1 ) THEN
    DEALLOCATE( Particles % PartIndex )
  END IF
  Particles % MaxNumberOfParticles = 0
  Particles % NumberOfParticles = 0
  
END SUBROUTINE DestroyParticles


SUBROUTINE ChangeParticlePartition(Particles) 
  TYPE(Particle_t) :: Particles
  INTEGER i,j

  IF( ParEnv% PEs == 1 ) RETURN

  j = 0
  DO i=1,Particles % NumberOfParticles
    IF( Particles % Status(i) == PARTICLE_LOST ) CYCLE
    IF( Particles % PartIndex(i) /= ParEnv % myPE ) THEN

      ! As partitioning is not implemented the particle is practically lost
      Particles % Status(i) = PARTICLE_LOST 
      j = j + 1
    END IF
  END DO

  PRINT *,'Implement change in partition!'
  PRINT *,'Partition lost particles:',ParEnv % myPE, j


END SUBROUTINE ChangeParticlePartition



SUBROUTINE GetParticleLocation(Particles,No,Coord,Velo,Dist,Status,ElementIndex)
  TYPE(Particle_t) :: Particles
  INTEGER :: No
  REAL(KIND=dp) :: Coord(:),Velo(:)
  REAL(KIND=dp), OPTIONAL :: Dist
  INTEGER, OPTIONAL :: Status
  INTEGER, OPTIONAL :: ElementIndex

  IF( Particles % dim == 3 ) THEN
    Coord = Particles % Coordinate(no,:)
    Velo = Particles % Velocity(no,:)
  ELSE
    Velo(1:2) = Particles % Velocity(no,:)
    Coord(1:2) = Particles % Coordinate(no,:)
  END IF
  IF( PRESENT(Dist) )   Dist = Particles % Distance(No)
  IF( PRESENT(Status) ) Status = Particles % Status(No)
  IF( PRESENT(ElementIndex) ) Status = Particles % ElementIndex(No)

END SUBROUTINE GetParticleLocation


SUBROUTINE SetParticleLocation(Particles,No,Coord,Velo,Dist,Status,ElementIndex)
  TYPE(Particle_t) :: Particles
  INTEGER :: No
  REAL(KIND=dp) :: Coord(:),Velo(:)
  REAL(KIND=dp), OPTIONAL :: Dist
  INTEGER, OPTIONAL :: Status
  INTEGER, OPTIONAL :: ElementIndex

  IF( Particles % dim == 3 ) THEN
    Particles % Coordinate(No,:) = Coord
    Particles % Velocity(No,:) = Velo
  ELSE
    Particles % Velocity(No,1:2) = Velo(1:2)
    Particles % Coordinate(No,1:2) = Coord(1:2)
  END IF
  IF( PRESENT(Dist) )   Particles % Distance(No) = Dist
  IF( PRESENT(Status) ) Particles % Status(No) = Status
  IF( PRESENT(ElementIndex) ) Particles % ElementIndex(No) = ElementIndex

END SUBROUTINE SetParticleLocation



!------------------------------------------------------------------------
! Initialize particle positions and velocities.
!-------------------------------------------------------------------------
SUBROUTINE InitializeParticles( Particles, InitParticles, AppendParticles ) 

  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: InitParticles
  LOGICAL, OPTIONAL :: AppendParticles

  TYPE(ValueList_t), POINTER :: Params 
  TYPE(Variable_t), POINTER :: Var
  TYPE(Element_t), POINTER :: CurrentElement
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: Offset, NewParticles,LastParticle
  INTEGER :: dim
  REAL(KIND=dp), POINTER :: Coords(:,:), Velo(:,:)
  CHARACTER(LEN=MAX_NAME_LEN) :: InitMethod, MaskVariable    
  INTEGER :: i,j,k,nonodes
  INTEGER, POINTER :: MaskPerm(:), InvPerm(:), NodeIndexes(:)
  LOGICAL :: GotIt, GotMask
  REAL(KIND=dp), POINTER :: InitialValues(:,:)
  REAL(KIND=dp) :: mass,boltz,temp,coeff 
  REAL(KIND=dp) :: MinCoord(3), MaxCoord(3)
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
  

  IF( PRESENT( AppendParticles ) ) THEN
    Offset = Particles % NumberOfParticles
  ELSE
    Offset = 0
  END IF
  IF( PRESENT( InitParticles ) ) THEN
    NewParticles = InitParticles
  ELSE
    NewParticles = Particles % MaxNumberOfParticles
  END IF

  LastParticle = Offset + NewParticles
  Particles % NumberOfParticles = LastParticle


  Mesh => GetMesh()
  dim = Mesh % MeshDim

  CALL AllocateParticles( Particles, LastParticle, dim ) 
  Velo => Particles % Velocity
  Coords => Particles % Coordinate
  

  Params => GetSolverParams()
  
  !------------------------------------------------------------------------
  ! The user may use a mask to initialize the particles only at a part of the 
  ! domain, or to utilize the ordeing of the permutation vector.
  !-------------------------------------------------------------------------
  
  GotMask = .FALSE.
  nonodes = Mesh % NumberOfNodes
  
  MaskVariable = ListGetString( Params,'Mask Variable Name',GotIt )
  IF(GotIt) THEN
    Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
    IF( ASSOCIATED( Var ) ) THEN
      MaskPerm => Var % Perm
      IF( ASSOCIATED(MaskPerm) ) THEN
        GotMask = .TRUE.
        nonodes = MAXVAL( MaskPerm ) 
        ALLOCATE( InvPerm(nonodes) )
        DO i=1,SIZE(MaskPerm)
          j = MaskPerm(i)
          IF( j > 0 ) InvPerm(j) = i
        END DO
      END IF
    END IF
  END IF
  
  !------------------------------------------------------------------------
  ! Position may be initialized using a given list, or using the nodal
  ! coordinates to initalize positions.
  !-------------------------------------------------------------------------
  
  InitMethod = ListGetString( Params,'Coordinate Initialization Method',gotIt ) 
  
  SELECT CASE ( InitMethod ) 
    
  CASE ('nodal ordered')
    DO i=1,NewParticles
      k = Offset + i
      j = (nonodes-1)*(i-1)/(NewParticles-1)+1
      j = MODULO( i * NewParticles -1 , nonodes ) + 1
      IF( GotMask ) j = InvPerm(j)
      Coords(k,1) = Mesh % Nodes % x(j)
      Coords(k,2) = Mesh % Nodes % y(j)
      IF( dim == 3 ) Coords(k,3) = Mesh % Nodes % z(j)
    END DO

  CASE ('element ordered')

    NoElements = Mesh % NumberOfBulkElements
    DO i=1,NewParticles
      k = Offset + i
      j = (NoElements-1)*(i-1)/(NewParticles-1)+1
      CurrentElement => Mesh % Elements(j)
      NodeIndexes =>  CurrentElement % NodeIndexes
      n = CurrentElement % TYPE % NumberOfNodes
      Coords(k,1) = SUM( Mesh % Nodes % x(NodeIndexes ) ) / n
      Coords(k,2) = SUM( Mesh % Nodes % y(NodeIndexes ) ) / n
      IF( dim == 3 ) Coords(k,3) = SUM( Mesh % Nodes % z(NodeIndexes ) ) / n
      Particles % ElementIndex(i) = j
    END DO

  CASE ('box random')
    MinCoord(1) = MINVAL( Mesh % Nodes % x )
    MaxCoord(1) = MAXVAL( Mesh % Nodes % x )

    MinCoord(2) = MINVAL( Mesh % Nodes % y )
    MaxCoord(2) = MAXVAL( Mesh % Nodes % y )

    IF( dim == 3 ) THEN
      MinCoord(3) = MINVAL( Mesh % Nodes % z )
      MaxCoord(3) = MAXVAL( Mesh % Nodes % z )    
    END IF

    DO i=1,NewParticles
      k = Offset + i
      
      Coords(k,1) = MinCoord(1) + (MaxCoord(1)-MinCoord(1)) * EvenRandom()
      Coords(k,2) = MinCoord(1) + (MaxCoord(1)-MinCoord(1)) * EvenRandom()
      IF( dim == 3 ) THEN
        Coords(k,3) = MinCoord(1) + (MaxCoord(1)-MinCoord(1)) * EvenRandom()
      END IF
    END DO

    
  CASE DEFAULT 
    
    InitialValues => ListGetConstRealArray(Params,'Initial Coordinates',gotIt)    
      IF(gotIt) THEN
        IF( SIZE(InitialValues,2) /= dim ) THEN
          CALL Fatal('ParticleTracker','Wrong dimension in Initial Coordinates')
        ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
          DO i=1,NewParticles
            k = offset + i
            Coords(k,1:dim) = InitialValues(1,1:dim)
          END DO
        ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
          CALL Fatal('ParticleTracker','Wrong number of particles in Initial Coordinates')
        ELSE
          DO i=1,NewParticles
            k = Offset + i
            Coords(k,1:dim) = InitialValues(i,1:DIM)
          END DO
        END IF
      ELSE
        CALL Fatal('ParticleTracker','Initial Coordinates not given')
      END IF
    END SELECT


    !------------------------------------------------------------------------
    ! Velocities may be initialized using a given list, or obtaining them
    ! from a thermal maxwell boltzmann distribution. These are additive to 
    ! allow bulk velocities with the thermal one.
    !-------------------------------------------------------------------------

    InitialValues => ListGetConstRealArray(Params,'Initial Velocities',gotIt)
    IF(gotIt) THEN
      IF( SIZE(InitialValues,2) /= DIM ) THEN
        CALL Fatal('ParticleTracker','Wrong dimension in Initial Velocities')
      ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
        DO i=1,NewParticles
          k = Offset + i
          Velo(k,1:dim) = InitialValues(1,1:DIM)
        END DO
      ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
        CALL Fatal('ParticleTracker','Wrong number of particles in Initial Velocities')
      ELSE
        DO i=1,NewParticles
          k = Offset + i
          Velo(k,1:dim) = InitialValues(i,1:DIM)
        END DO
      END IF
    END IF



    InitMethod = ListGetString( Params,'Velocity Initialization Method',gotIt ) 

    SELECT CASE ( InitMethod ) 
      
    CASE ('thermal random')  
      
      mass = ListGetConstReal( Params,'Particle Mass')
      temp = ListGetConstReal( Params,'Particle Temperature')
      boltz = ListGetConstReal( CurrentModel % Constants,'Boltzmann constant')
      coeff = SQRT(boltz * temp / mass )

      DO i=1,NewParticles
        k = Offset + i
        Velo(k,1) = Velo(k,1) + coeff * NormalRandom()
        Velo(k,2) = Velo(k,2) + coeff * NormalRandom()
        IF( dim == 3 ) Velo(k,3) = Velo(k,3) + coeff * NormalRandom()
      END DO

    CASE ('even random')  

      coeff = ListGetConstReal( Params,'Random Velocity Amplitude')

      DO i=1,NewParticles
        k = Offset + i
        Velo(k,1) = Velo(k,1) + coeff * (2*EvenRandom()-1)
        Velo(k,2) = Velo(k,2) + coeff * (2*EvenRandom()-1)
        IF( dim == 3 ) Velo(k,3) = Velo(k,3) + coeff * (2*EvenRandom()-1)
      END DO

    CASE DEFAULT

    END SELECT


    IF( GotMask ) DEALLOCATE( InvPerm ) 


    DO i=1,NewParticles
      k = Offset + i
      Particles % Status(k) = PARTICLE_INITIATED
    END DO


  END SUBROUTINE InitializeParticles

 

!---------------------------------------------------------------------------
  SUBROUTINE SegmentElementIntersection(Mesh,BulkElement,&
      Rinit,Rfin,MinLambda,FaceElement)
!---------------------------------------------------------------------------
! This subroutine finds the possible intersection between elementfaces 
! and a line segment.
!---------------------------------------------------------------------------

  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER   :: BulkElement
  REAL(KIND=dp) :: Rinit(3), Rfin(3), MinLambda
  TYPE(Element_t), POINTER :: FaceElement

  TYPE(Element_t), POINTER   :: BoundaryElement
  TYPE(Nodes_t), SAVE :: BoundaryNodes
  REAL(KIND=dp) :: Lambda, Epsilon
  INTEGER :: i,j,n
  INTEGER, POINTER :: NodeIndexes(:)
  LOGICAL :: AtBoundary, Visited = .FALSE.


  SAVE  Visited

  
  MinLambda = HUGE( MinLambda ) 
  Epsilon = TINY( Lambda ) 
  FaceElement => Null()

  IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
    DO i=1, BulkElement % TYPE % NumberOfFaces  
      j = BulkElement % FaceIndexes(i)
      BoundaryElement => Mesh % Faces( j )
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)

      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 
      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  ELSE
    DO i=1, BulkElement % TYPE % NumberOfEdges  
      j = BulkElement % EdgeIndexes(i)
      BoundaryElement => Mesh % Edges( j )
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)
     
      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 

      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  END IF

END SUBROUTINE SegmentElementIntersection






!------------------------------------------------------------------------
! Compute field values at the given points in the FE mesh. 
! Differs from the PointInMesh category in that the particle may
! have initial information about its location making marching 
! routines more feasible. These are also more attractive for 
! parallel implementation point of view.
!-------------------------------------------------------------------------
SUBROUTINE LocateParticleInMesh( ElementIndex, Rinit, Rfin, Init, &
    LocalCoords, ParticleStatus, StopFaceElement, Lambda )
  
  INTEGER :: ElementIndex
  REAL(KIND=dp) :: Rinit(3), Rfin(3),LocalCoords(3)
  LOGICAL :: Init
  INTEGER :: ParticleStatus
  TYPE(Element_t), POINTER, OPTIONAL :: StopFaceElement
  REAL(KIND=dp), OPTIONAL :: Lambda

  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp) :: Rtmp(3), MinLambda 
  LOGICAL :: Hit, DoInit, Stat, CheckFirst, StopAtFace, AtWall, Visited = .FALSE.,&
      Debug,UseCenter,Rough
  INTEGER :: i,j,k,n,FaceIndex,SearchMethod,MaxTrials
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element, FaceElement, LeftElement, RightElement, &
      NextElement
  TYPE(Quadrant_t), POINTER, SAVE :: RootQuadrant =>Null(), LeafQuadrant
  REAL(kind=dp) :: BoundingBox(6), eps2, eps1
  

  SAVE :: Mesh, CheckFirst, StopAtFace, SearchMethod, Debug, Rough, MaxTrials

  Mesh => GetMesh()

  IF( .NOT. Visited ) THEN
    Params => GetSolverParams()
    CheckFirst = ListGetLogical( Params,'Particle Element Search Check',Stat)
    StopAtFace = ListGetLogical( Params,'Particle Stop At Face',Stat)
    SearchMethod = ListGetInteger( Params,'Particle Search Method',Stat)
    Rough = ListGetLogical( Params,'Particle Search Rough',Stat)
    MaxTrials = ListGetInteger( Params,'Particle Search Max Trials',Stat)
    IF(.NOT. Stat) MaxTrials = Mesh % NumberOfBulkElements
    Debug = .FALSE.
    Visited = .TRUE.
  END IF


  ParticleStatus = PARTILCE_LOST
  IF( PRESENT (StopFaceElement) ) NULLIFY( StopFaceElement ) 

  IF( PRESENT( Lambda ) ) Lambda = 1.0_dp
  
  ! Check that the previous hit is not hit even now
  !-------------------------------------------------
  IF( ElementIndex > 0 .AND. CheckFirst) THEN
    Element => Mesh % Elements( ElementIndex ) 
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)
    
    IF ( PointInElement( Element, ElementNodes, &
        Rfin, LocalCoords ) ) THEN
      ParticleStatus = PARTICLE_HIT
      RETURN
    END IF
  END IF

  ! Different search method, only the default one treats face jumps in a proper way
  !--------------------------------------------------------------------------------

  SELECT CASE ( SearchMethod )
    
  CASE( 1 ) 
    !----------------------------------------------------------
    ! Go through all bulk elements in a dummy search.
    ! This algorithm is mainly here for debugging purposes.
    !----------------------------------------------------------
    DO i = 1, Mesh % NumberOfBulkElements
      Element => Mesh % Elements(i)
      n = GetElementNOFNodes(Element)
      CALL GetElementNodes(ElementNodes,Element)
      IF ( PointInElement( Element, ElementNodes, &
          Rfin, LocalCoords ) ) THEN
        ElementIndex = i
        ParticleStatus = PARTICLE_HIT
        RETURN
      END IF
    END DO
    RETURN
    
  CASE( 2 )        
    !-----------------------------------------------------------
    ! Find the right element using an octree search
    ! This is optimal when the particles are searched only once.
    !-----------------------------------------------------------
    IF ( .NOT.ASSOCIATED(Mesh % RootQuadrant) ) THEN
      BoundingBox(1) = MINVAL( Mesh % Nodes % x )
      BoundingBox(2) = MINVAL( Mesh % Nodes % y )
      BoundingBox(3) = MINVAL( Mesh % Nodes % z )
      BoundingBox(4) = MAXVAL( Mesh % Nodes % x )
      BoundingBox(5) = MAXVAL( Mesh % Nodes % y )
      BoundingBox(6) = MAXVAL( Mesh % Nodes % z )
      
      eps1 = 1.0e-3
      eps2 = eps1 * MAXVAL( BoundingBox(4:6) - BoundingBox(1:3) )
      BoundingBox(1:3) = BoundingBox(1:3) - eps2
      BoundingBox(4:6) = BoundingBox(4:6) + eps2
      
      CALL BuildQuadrantTree( Mesh,BoundingBox,Mesh % RootQuadrant)
    END IF
    RootQuadrant => Mesh % RootQuadrant
      
    Element => Null()
    CALL FindLeafElements(Rfin, Mesh % MeshDim, RootQuadrant, LeafQuadrant)
    IF ( ASSOCIATED(LeafQuadrant) ) THEN
      DO i = 1, LeafQuadrant % NElemsInQuadrant
        j = LeafQuadrant % Elements(i)
        Element => Mesh % Elements(j)
        
        n = GetElementNOFNodes( Element )
        CALL GetElementNodes( ElementNodes, Element)

        IF ( PointInElement( Element, ElementNodes, Rfin, LocalCoords ) ) THEN
          ElementIndex = j
          ParticleStatus = PARTICLE_HIT
          RETURN
        END IF
      END DO
    END IF
    RETURN

    
  CASE DEFAULT
    !--------------------------------------------------------------------
    ! This is a recursive algorithm that checks the intersections 
    ! of line segments and points until correct element is found.
    ! This is optimal when the stepsize is small and there are many steps.
    !--------------------------------------------------------------------
    CALL FindMeshEdges( Mesh, .FALSE.)

    DoInit = Init
    IF( ElementIndex == 0 ) THEN
      DoInit = .TRUE.
      ElementIndex = 1
      UseCenter = .TRUE.
    ELSE	
      UseCenter = .NOT. StopAtFace
    END IF

    Element => Mesh % Elements( ElementIndex ) 
    eps1 = 1.0d-10

    DO i=1,MaxTrials
      n = GetElementNOFNOdes(Element)
      CALL GetElementNodes(ElementNodes,Element)

      ! Use the previous element center if the true path is of no importance
      !---------------------------------------------------------------------	
      IF( UseCenter ) THEN
        Rtmp(1) = SUM( ElementNodes % x(1:n) ) / n
        Rtmp(2) = SUM( ElementNodes % y(1:n) ) / n
        Rtmp(3) = SUM( ElementNodes % z(1:n) ) / n
      ELSE
        Rtmp = Rinit
      END IF
      
      CALL SegmentElementIntersection(Mesh,Element,&
          Rtmp,Rfin,MinLambda,FaceElement )
      
      IF( .NOT. ASSOCIATED( FaceElement ) ) THEN
        CALL Warn('LocateParticleInMesh','No intersection found?')
        EXIT
      ELSE IF( MinLambda > 1.0 - eps1 ) THEN
        ParticleStatus = PARTICLE_HIT
        Rtmp = Rfin
        EXIT
      ELSE 
        LeftElement => FaceElement % BoundaryInfo % Left
        RightElement => FaceElement % BoundaryInfo % Right

        IF( ASSOCIATED( LeftElement) .AND. ASSOCIATED(RightElement)) THEN
          IF( ASSOCIATED(Element, LeftElement)) THEN
            NextElement => RightElement
          ELSE
            NextElement => LeftElement
          END IF

          IF( StopAtFace .AND. .NOT. DoInit ) ParticleStatus = PARTICLE_FACEBOUNDARY

	  IF( ParEnv % PEs > 1 ) THEN
            IF( Element % PartIndex /= NextElement % PartIndex ) THEN
              ParticleStatus = PARTICLE_PARTBOUNDARY 
            END IF
          END IF
        ELSE
          ParticleStatus = PARTICLE_WALLBOUNDARY
        END IF

        ! There are different reasons why the particle is only integrated until the face
        IF( ParticleStatus == PARTICLE_WALLBOUNDARY .OR. &
            ParticleStatus == PARTICLE_PARTBOUNDARY .OR. &
            ParticleStatus == PARTICLE_FACEBOUNDARY ) THEN
          
          IF( PRESENT( Lambda ) ) Lambda = MinLambda
          Rtmp = Rinit + MinLambda * (Rfin - Rinit) 
          StopFaceElement => FaceElement
          EXIT                      
        END IF
      END IF

      ! continue the search to new elements
      Element => NextElement
    END DO
    
    IF( .NOT. Rough ) THEN 
      Hit = PointInElement( Element, ElementNodes, Rtmp, LocalCoords ) 
      IF( Hit ) THEN
        IF( Debug ) THEN
          CALL Info('LocateParticleInMesh','Point found!')
          PRINT *,'Dist',i,SQRT( SUM((Rtmp - Rfin)**2) )
        END IF
      ELSE
        CALL Warn('LocateParticleInMesh','Should have found the point in element!')
      END IF
    END IF

    ElementIndex = Element % ElementIndex

    
  END SELECT
  
END SUBROUTINE LocateParticleInMesh





!-------------------------------------------------------------
! This routine cretates the nearest neighbours for all nodes
! The particle-particle connections may then be found by going
! through all the nodes of elements
!-------------------------------------------------------------
SUBROUTINE CreateNeighbourList( Particles ) 

  TYPE(Particle_t) :: Particles
  
  INTEGER :: ElementIndex, dim
  REAL(KIND=dp) :: Coord(3), dist, mindist
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: i,j,k,n
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element
  INTEGER :: NoNodes, NoParticles, MaxClosest  

  Mesh => GetMesh()
  NoNodes = Mesh % NumberOfNodes

  NoParticles = Particles % NumberOfParticles

  IF( .NOT. Particles % NeighbourTable ) THEN
    ALLOCATE( Particles % ClosestNode( NoParticles ) )
    ALLOCATE( Particles % ClosestParticle( NoParticles ) )
    ALLOCATE( Particles % NoClosestParticle( NoNodes ) ) 
    ALLOCATE( Particles % CumClosestParticle( NoNodes+1 ) ) 
    Particles % NeighbourTable = .TRUE.
  END IF
  
  dim = Particles % dim 

  ! First find the closest node to each particle
  !-----------------------------------------------
  Particles % ClosestNode = 0
  Particles % NoClosestParticle = 0
  DO i=1,NoParticles 
    IF( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    ElementIndex = Particles % ElementIndex(i)
    Element => Mesh % Elements( ElementIndex )
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)    
    Coord(1:dim) = Particles % Coordinate(i,1:dim)

    ! Find the minimum distance node (using squares is faster)
    mindist = HUGE( mindist ) 
    DO j=1,n
      dist = ( ElementNodes % x(j) - Coord(1) )**2
      dist = dist +  ( ElementNodes % y(j) - Coord(2) )**2
      IF( dim == 3 ) THEN
        dist = dist +  ( ElementNodes % z(j) - Coord(3) )**2
      END IF
      IF( dist < mindist ) THEN
        mindist = dist 
        k = j
      END IF
    END DO    
    node = Element % NodeIndexes(k)
    Particles % ClosestNode(i) = node
    Particles % NoClosestParticle(node) = Particles % NoClosestParticle(node) + 1
  END DO

  ! Count the cumulative number of closest particles for given node
  !-----------------------------------------------------------------
  Particles % CumClosestParticle(1) = 1
  MaxClosest = 0
  DO i=1,NoNodes
    j = Particles % NoClosestParticle(i)
    MaxClosest = MAX( MaxClosest, j )
    Particles % CumClosestParticle(i+1) = Particles % CumClosestParticle(i) + j
  END DO
  Particles % MaxClosestParticles = MaxClosest

  ! And finally, add the closest neigbours to the table 
  !----------------------------------------------------------------
  Particles % NoClosestParticle = 0
  Particles % ClosestParticle = 0
  DO i=1,NoParticles     
    node = Particles % ClosestNode(i) 
    j = Particles % NoClosestParticle(node) 
    k = Particles % CumClosestParticle(node)
    Particles % ClosestParticle(k+j) = i
    Particles % NoClosestParticle(node) = j + 1
  END DO

END SUBROUTINE CreateNeighbourList




!------------------------------------------------------------
! For the first call of given node do the list, thereafter 
! Return the index until the list is finished
!------------------------------------------------------------
FUNCTION GetNextNeighbour( Particles, No ) RESULT ( No2 )
   IMPLICIT NONE

  TYPE(Particle_t) :: Particles
  INTEGER :: No, No2

  INTEGER :: PrevNo = 0
  INTEGER, POINTER :: NodeIndexes(:), NeighbourList(:) => NULL(), TmpList(:) => NULL()
  INTEGER :: i,j,k,n,ListSize,NoNeighbours,ElementIndex,Cnt
  LOGICAL :: Visited = .FALSE.
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER :: Element
  
  SAVE Visited,PrevNo,NeighbourList,ListSize,NoNeighbours,Cnt

  IF( PrevNo /= No ) THEN
    PrevNo = No
    IF( .NOT. Visited ) THEN
      Visited = .TRUE.
      Mesh => GetMesh()
      n = Mesh % MaxElementNodes 
      ListSize = n * Particles % MaxClosestParticles + 10
      ALLOCATE( NeighbourList( ListSize ) )
      NeighbourList = 0 
      Mesh => GetMesh()
    END IF

    Mesh => GetMesh()
    ElementIndex = Particles % ElementIndex(No)
    Element => Mesh % Elements( ElementIndex )
    n = GetElementNOFNodes(Element)
    NodeIndexes => Element % NodeIndexes

    NoNeighbours = 0
    DO i=1,n
      j = NodeIndexes(i)

      DO k=Particles % CumClosestParticle(j),Particles % CumClosestParticle(j+1)-1 
        No2 = Particles % ClosestParticle(k)

        ! No self coupling in this list	
        IF( No2 == No ) CYCLE

        ! Set symmetric forces Fij=-Fij so no need to go through twice
        IF ( No2 < No ) CYCLE

        NoNeighbours = NoNeighbours + 1

        IF( NoNeighbours > ListSize ) THEN
          ALLOCATE( TmpList( ListSize + 20 ) )
          TmpList(1:ListSize) = NeighbourList
          DEALLOCATE( NeighbourList ) 
          NeighbourList => TmpList
          ListSize = ListSize + 20
          NULLIFY( TmpList ) 
          CALL Info('GetNextNeighbour','Allocating more space')
        END IF

        NeighbourList(NoNeighbours) = No2
      END DO
    END DO
    Cnt = 0
  END IF 

  Cnt = Cnt + 1
  IF( Cnt > NoNeighbours ) THEN
    No2 = 0
  ELSE
    No2 = NeighbourList( Cnt ) 
  END IF

END FUNCTION GetNextNeighbour



 !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutput( Particles ) 
    
    TYPE(Particle_t) :: Particles
    LOGICAL :: Visited = .FALSE.
    TYPE(ValueList_t), POINTER :: Params     
    CHARACTER(LEN=MAX_NAME_LEN) :: FileFormat
    LOGICAL :: VtuFormat, TableFormat, Found

    SAVE :: TableFormat, VtuFormat, VisitedTimes 
    
    IF( .NOT. Visited ) THEN
      Params => GetSolverParams()
      VisitedTimes = VisitedTimes + 1
      TableFormat = GetLogical( Params,'Table Format',Found)
      VtuFormat = GetLogical( Params,'Vtu Format',Found)
      FileFormat = GetString( Params,'Output Format',Found) 
      IF( Found ) THEN
        IF( FileFormat == 'vtu') VtuFormat = .TRUE.
        IF( FileFormat == 'table') TableFormat = .TRUE.
      END IF
      Visited = .TRUE.
    END IF

    IF( TableFormat ) CALL ParticleOutputTable( Particles )
    IF( VtuFormat ) CALL ParticleOutputVtu( Particles ) 

  END SUBROUTINE ParticleOutput


  !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutputTable( Particles ) 
    
    TYPE(Particle_t) :: Particles

    TYPE(Variable_t), POINTER :: TimeVar
    TYPE(ValueList_t), POINTER :: Params 
    CHARACTER(LEN=MAX_NAME_LEN) :: FilePrefix, FileName
    LOGICAL :: Found, NumberFilesByParticles, NumberFilesBySteps
    REAL(KIND=dp), POINTER :: Coord(:,:), Velo(:,:), Dist(:)
    REAL(KIND=dp) :: time
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: Status(:)
    INTEGER :: i,j,dim, NoParticles, MinSaveStatus
    INTEGER :: VisitedTimes = 0

    SAVE :: VisitedTimes, Params, FilePrefix, NumberFilesByParticles, NumberFilesBySteps, &
        MinSaveStatus, TimeVar

    VisitedTimes = VisitedTimes + 1

    Mesh => GetMesh()
    dim = Particles % dim

    Coord => Particles % Coordinate
    Velo => Particles % Velocity 
    Dist => Particles % Distance
    Status => Particles % Status

    IF( VisitedTimes == 1 ) THEN
      Params => GetSolverParams()
      FilePrefix = ListGetString(Params,'Filename Prefix',Found )
      IF(.NOT. Found) FilePrefix = 'track'
      CALL WriteParticleFileNames(FilePrefix, dim)

      NumberFilesByParticles = ListGetLogical( Params,'File Numbering By Particles',Found) 
      NumberFilesBySteps = ListGetLogical( Params,'File Numbering By Steps',Found) 
      IF( NumberFilesByParticles .AND. NumberFilesBySteps ) THEN
        CALL Fatal('ParticleTracker','Files may be numbered either by steps or particles')
      END IF
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      
      TimeVar => VariableGet( Mesh % Variables,'time')
    END IF

    time = TimeVar % Values(1)
    NoParticles = Particles % NumberOfParticles

    IF(.NOT. NumberFilesByParticles ) THEN
      IF( NumberFilesBySteps ) THEN
        CALL OpenParticleFile(FilePrefix, VisitedTimes )
      ELSE
        CALL OpenParticleFile(FilePrefix, 0 )        
      END IF
      DO i = 1, NoParticles
        IF( Particles % Status(i) < MinSaveStatus ) CYCLE
        CALL WriteParticleLine( dim, i )        
      END DO
      CALL CloseParticleFile()
    ELSE
      DO i = 1, NoParticles
        IF( Particles % Status(i) < MinSaveStatus ) CYCLE
        CALL OpenParticleFile(FilePrefix, i)
        CALL WriteParticleLine( dim, i ) 
        CALL CloseParticleFile()
      END DO
    END IF


  CONTAINS

    !------------------------------------------------------------------------
    ! Write the names file for user information. Remember to update this if 
    ! SaveParticleStep is modified.
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleFileNames( Prefix, Dim ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: dim

      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      INTEGER :: i,j
      
      WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat.names'
      
      OPEN (10, FILE=FileName )
      
      WRITE( 10, '(A)' ) 'Variables in file: '//TRIM(FilePrefix)//'*.dat'
      WRITE( 10, '(A,I2)' ) 'Dimension of particle set is',dim
      i = 1
      WRITE( 10, '(I2,A)' )  i,': time'
      WRITE( 10, '(I2,A)' )  i+1,': Coordinate_1'
      WRITE( 10, '(I2,A)' )  i+2,': Coordinate_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Coordinate_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Velocity_1'
      WRITE( 10, '(I2,A)' )  i+2,': Velocity_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Velocity_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Distance'
      i = i + 1
      
      CLOSE( 10 )
      
    END SUBROUTINE WriteParticleFileNames



    !------------------------------------------------------------------------
    ! Open a numbered file for each particle. These must be separate since the 
    ! number of steps for each particle may vary greatly
    !-------------------------------------------------------------------------
    SUBROUTINE OpenParticleFile( Prefix, FileNo ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: FileNo
      LOGICAL, SAVE :: Visited = .FALSE.


      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      
      IF( FileNo == 0 ) THEN
        WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat'
        IF( .NOT. Visited ) THEN
          CALL Info( 'ParticleTracker', 'Saving particle paths to file: '//TRIM(FileName), Level=4 )
        END IF
      ELSE IF( FileNo < 10 ) THEN
        IF( FileNo == 1 .AND. .NOT. Visited ) THEN
          WRITE( Message, * ) 'Saving particle paths to files: ', TRIM(FilePrefix)//'_*.dat'
          CALL Info( 'ParticleTracker', Message, Level=4 )
        END IF
        WRITE( FileName,'(A,A,I1,A)') TRIM(FilePrefix),'_',fileno,'.dat'
      ELSE IF( FileNo < 100 ) THEN
        WRITE( FileName,'(A,A,I2,A)') TRIM(FilePrefix),'_',fileno,'.dat'
      ELSE IF( FileNo < 1000 ) THEN
        WRITE( FileName,'(A,A,I3,A)') TRIM(FilePrefix),'_',fileno,'.dat'
      END IF
      
      IF( VisitedTimes == 1 .OR. NumberFilesBySteps ) THEN
        OPEN (10, FILE=FileName )
      ELSE
        OPEN (10, FILE=FileName,POSITION='APPEND' )
      END IF

      Visited = .TRUE.

    END SUBROUTINE OpenParticleFile
    
    
    !------------------------------------------------------------------------
    ! Save one line in the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleLine( Dim, No )
      INTEGER :: Dim, No
      
      IF( NumberFilesBySteps ) THEN
        WRITE( 10, * ) time, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      ELSE IF( NumberFilesByParticles ) THEN
        WRITE( 10, * ) time, VisitedTimes, Coord(No,1:Dim), Velo(No,1:dim), Dist(No) 
      ELSE       
        WRITE( 10, * ) time, VisitedTimes, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      END IF

    END SUBROUTINE WriteParticleLine
    
    
    !------------------------------------------------------------------------
    ! Close the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE CloseParticleFile( )
      
      CLOSE( 10 )
      
    END SUBROUTINE CloseParticleFile
           
  END SUBROUTINE ParticleOutputTable




SUBROUTINE ParticleOutputVtu( Particles )
!------------------------------------------------------------------------------

  USE DefUtils 
  USE MeshUtils
  USE ElementDescription
  
  IMPLICIT NONE
  TYPE(Particle_t) :: Particles  
  
  TYPE(ValueList_t),POINTER :: Params
  INTEGER, SAVE :: nTime = 0
  LOGICAL :: GotIt, Parallel, FixedMesh
  CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
  CHARACTER(MAX_NAME_LEN) :: VtuFile, PvtuFile 
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Variable_t), POINTER :: Var
  INTEGER :: i, j, k, Partitions, Part, ExtCount, FileindexOffSet
  CHARACTER(MAX_NAME_LEN) :: Dir
  LOGICAL :: Visited = .FALSE.

  CHARACTER(MAX_NAME_LEN) :: Str
  INTEGER :: NumberOfNodes, ParallelNodes, Dim

  Params => GetSolverParams()
  Mesh => GetMesh()

  ExtCount = ListGetInteger( Params,'Output Count',GotIt)
  IF( GotIt ) THEN
    nTime = ExtCount
  ELSE
    nTime = nTime + 1
  END IF
  FileIndexOffset = ListGetInteger( Params,'Fileindex offset',GotIt)

  IF ( nTime == 1 ) THEN
    CALL Info('ParticleOutputVtu','Saving results in VTK XML format')
    FilePrefix = GetString( Params,'Filename Prefix',GotIt )
    IF ( .NOT.GotIt ) FilePrefix = "Particles"
  END IF
  
  Partitions = ParEnv % PEs
  Part = ParEnv % MyPE
  Parallel = (Partitions > 1) .OR. ListGetLogical(Params,'Enforce Parallel format',GotIt)

  Dim = Particles % dim
  NumberOfNodes = Particles % NumberOfParticles

  IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
    Dir = TRIM(Mesh % Name) // "/"
  ELSE
    Dir = "./"
  END IF
  
  IF(Parallel .AND. Part == 0) THEN
    WRITE( PvtuFile,'(A,A,I4.4,".pvtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
    CALL WritePvtuFile( PvtuFile )
  END IF
  
  IF ( Parallel ) THEN
    WRITE( VtuFile,'(A,A,I4.4,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),Part+1,"par",nTime
  ELSE
    WRITE( VtuFile,'(A,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
  END IF
  CALL WriteVtuFile( VtuFile )


CONTAINS

  
  SUBROUTINE WriteVtuFile( VtuFile )
    CHARACTER(LEN=*), INTENT(IN) :: VtuFile
    INTEGER, PARAMETER :: VtuUnit = 58
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=512) :: str
    INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
    CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
    LOGICAL :: ScalarsExist, VectorsExist, Found
    INTEGER, POINTER :: Perm(:)
    REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)
    REAL(KIND=dp) :: x,y,z

    
    OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
    
    WRITE( VtuUnit,'(A)') '<VTKFile type="UnstructuredGrid" version="0.1" byte_order="LittleEndian">'
    WRITE( VtuUnit,'(A)') '  <UnstructuredGrid>'
    WRITE( VtuUnit,'(A,I0,A)') '    <Piece NumberOfPoints="',NumberOfNodes,&
        '" NumberOfCells="0">'


    
    ! nodewise information
    !-------------------------------------
    ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
    VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
    IF( ScalarsExist .AND. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)&
          //'" Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE IF( ScalarsExist ) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)//'">'
    ELSE IF( VectorsExist ) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE
      CALL Warn('WriteVtkXMLFile','Are there really no scalars or vectors?')
    END IF
    
    DO Rank = 0,1
      DO Vari = 1, 99
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        END IF
        
        FieldName = GetString( Params, TRIM(Txt), Found )
        IF(.NOT. Found) EXIT
        
        !---------------------------------------------------------------------
        ! Find the variable with the given name in the normal manner 
        !---------------------------------------------------------------------
        IF( FieldName == 'velocity' ) THEN
          VectorValues => Particles % Velocity
        ELSE IF( FieldName == 'acceleration') THEN
          VectorValues => Particles % Acceleration 
        ELSE IF( FieldName == 'distance') THEN
          ScalarValues => Particles % Distance
        ELSE IF( FieldName == 'dt') THEN
          ScalarValues => Particles % dt
        ELSE
          WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
          CALL Warn('WriteVtuXMLFile', Txt)
          CYCLE
        END IF

        !---------------------------------------------------------------------
        ! Finally save the field values 
        !---------------------------------------------------------------------
        IF( Rank == 0) THEN
          WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="1" format="ascii">'    
          DO i = 1, NumberOfNodes
            j = i
            IF(j > 0) THEN
              WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') ScalarValues(j)              
            ELSE
              WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0'  
            END IF
          END DO
          WRITE( VtuUnit,'(A)') ' '
          WRITE( VtuUnit,'(A)') '        </DataArray>'
        ELSE
          sdofs = 3
          WRITE( VtuUnit,'(A,I1,A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="',sdofs,'" format="ascii">'    
          
          DO i = 1, NumberOfNodes
            j = i
            IF( dim == 2 ) THEN
              IF( j > 0 ) THEN
                WRITE( VtuUnit,'(2ES16.7E3,A)', ADVANCE='no') VectorValues(j,1:dim),' 0.0'
              ELSE
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
              END IF
            ELSE
              IF( j > 0 ) THEN
                WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') VectorValues(j,1:dim)
              ELSE
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
              END IF              
            END IF
          END DO
          WRITE( VtuUnit,'(A)') ' '
          WRITE( VtuUnit,'(A)') '        </DataArray>'
        END IF
      END DO
    END DO
    
    IF( ScalarsExist .OR. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '      </PointData>'
    END IF
    
    
    ! Coordinates of each point
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <Points>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii">'    


    DO i = 1, NumberOfNodes
      DO j=1,dim
        WRITE(VtuUnit,'(ES16.7E3)', ADVANCE='no') Particles % Coordinate(i,j)
      END DO
      IF( dim == 3 ) THEN
        WRITE(VtuUnit,'(A)') ' '
      ELSE
        WRITE(VtuUnit,'(A)') ' 0.0'
      END IF
    END DO

    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '      </Points>'


    WRITE( VtuUnit,'(A)') '      <Cells>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="connectivity" format="ascii">'
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="offsets" format="ascii">'
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="types" format="ascii">'
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '      </Cells>'

    WRITE( VtuUnit,'(A)') '    </Piece>'
    WRITE( VtuUnit,'(A)') '  </UnstructuredGrid>'
    WRITE( VtuUnit,'(A)') '</VTKFile>'

    CLOSE( VtuUnit )
  
  END SUBROUTINE WriteVtuFile
    


  SUBROUTINE WritePvtuFile( VtuFile )
    CHARACTER(LEN=*), INTENT(IN) :: VtuFile
    INTEGER, PARAMETER :: VtuUnit = 58
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=512) :: str
    INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
    CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
    LOGICAL :: ScalarsExist, VectorsExist, Found
    REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)

    
    OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
    
    WRITE( VtuUnit,'(A)') '<VTKFile type="PUnstructuredGrid" version="0.1" byte_order="LittleEndian">'
    WRITE( VtuUnit,'(A)') '  <PUnstructuredGrid>'
    
    ! nodewise information
    !-------------------------------------
    ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
    VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
    IF( ScalarsExist .AND. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)&
          //'" Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE IF( ScalarsExist ) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)//'">'
    ELSE IF( VectorsExist ) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE
      CALL Warn('WriteVtkXMLFile','Are there really no scalars or vectors?')
    END IF

    
    DO Rank = 0,1
      DO Vari = 1, 99
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        END IF
        
        FieldName = GetString( Params, TRIM(Txt), Found )
        IF(.NOT. Found) EXIT
      
        IF( FieldName /= 'velocity' .AND. FieldName /= 'acceleration' .AND. &
            FieldName /= 'distance' .AND. FieldName /= 'dt' ) THEN
          WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
          CALL Warn('WriteVtuXMLFile', Txt)
          CYCLE
        END IF

        IF( Rank == 0) THEN
          WRITE( VtuUnit,'(A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="1" format="ascii"/>'    
        ELSE
          sdofs = 3
          WRITE( VtuUnit,'(A,I1,A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="',sdofs,'" format="ascii"/>'    
        END IF
      END DO
    END DO
    WRITE( VtuUnit,'(A)') '    </PPointData>'

    ! Coordinates of each point
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <PPoints>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii"/>'    
    WRITE( VtuUnit,'(A)') '      </PPoints>' 

    DO i=1,Partitions
      WRITE( VtuUnit,'(A,I4.4,A,I4.4,A)' ) '    <Piece Source="'//&
          TRIM(FilePrefix),i,"par",nTime,'.vtu"/>'
    END DO

    WRITE( VtuUnit,'(A)') '  </PUnstructuredGrid>'
    WRITE( VtuUnit,'(A)') '</VTKFile>'

    CLOSE( VtuUnit )
  
  END SUBROUTINE WritePvtuFile



!------------------------------------------------------------------------------
END SUBROUTINE ParticleOutputVtu
!------------------------------------------------------------------------------
  


!------------------------------------------------------------------------------
END MODULE ParticleUtils
!------------------------------------------------------------------------------
