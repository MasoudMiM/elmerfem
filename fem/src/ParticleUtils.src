
MODULE ParticleUtils

   USE DefUtils

CONTAINS


SUBROUTINE AllocateParticles(Particles,NoParticles,dim)

  TYPE(Particle_t) :: Particles
  INTEGER :: NoParticles
  INTEGER, OPTIONAL :: dim

  REAL(KIND=dp), POINTER :: Velocity(:,:), Coordinate(:,:), Distance(:)
  INTEGER, POINTER :: Status(:), ElementIndex(:)
  INTEGER :: PrevNoParticles, dofs

  IF( NoParticles <= Particles % MaxNumberOfParticles ) THEN
    CALL Info('AllocateParticles','There are already enough particles')
    RETURN
  END IF
  IF( .NOT. PRESENT( dim ) ) THEN
    dofs = 3 
  ELSE
    IF( dim == 2 .OR. dim == 3 ) THEN
      dofs = dim
    ELSE
      CALL Warn('AllocateParticles','Invalid dimension')
      RETURN
    END IF
  END IF

  IF( Particles % MaxNumberOfParticles == 0 ) THEN
    ALLOCATE( Particles % Velocity(NoParticles,dim))
    ALLOCATE( Particles % Coordinate(NoParticles,dim))
    ALLOCATE( Particles % Distance(NoParticles))
    ALLOCATE( Particles % Status(NoParticles))
    ALLOCATE( Particles % ElementIndex(NoParticles))

    Particles % Velocity = 0.0_dp
    Particles % Coordinate = 0.0_dp
    Particles % Distance = 0.0_dp
    Particles % Status = PARTICLE_ALLOCATED
    Particles % ElementIndex = 0
    Particles % MaxNumberOfParticles = NoParticles
  ELSE 
    PrevNoParticles = Particles % MaxNumberOfParticles 

    Coordinate => Particles % Coordinate
    Velocity => Particles % Velocity
    Distance => Particles % Distance
    Status => Particles % Status
    ElementIndex => Particles % ElementIndex

    ALLOCATE( Particles % Velocity(NoParticles,dim) )
    ALLOCATE( Particles % Coordinate(NoParticles,dim) )
    ALLOCATE( Particles % Distance(NoParticles) )
    ALLOCATE( Particles % Status(NoParticles) )
    ALLOCATE( Particles % ElementIndex(NoParticles) )

    Particles % Coordinate(1:PrevNoParticles,:) = Coordinate
    Particles % Velocity(1:PrevNoParticles,:) = Velocity 
    Particles % Distance(1:PrevNoParticles) = Distance
    Particles % Status(1:PrevNoParticles) = Status
    Particles % ElementIndex(1:PrevNoParticles) = ElementIndex
    DEALLOCATE(Velocity, Coordinate, Distance, Status, ElementIndex ) 

    Particles % Velocity(PrevNoParticles+1:NoParticles,:) = 0.0_dp
    Particles % Coordinate(PrevNoParticles+1:NoParticles,:) = 0.0_dp
    Particles % Distance(PrevNoParticles+1:NoParticles) = 0.0_dp
    Particles % Status(PrevNoParticles+1:NoParticles) = PARTICLE_ALLOCATED
    Particles % ElementIndex(PrevNoParticles+1:NoParticles) = 0

    Particles % MaxNumberOfParticles = NoParticles
  END IF
END SUBROUTINE AllocateParticles



SUBROUTINE DestroyParticles(Particles) 
  TYPE(Particle_t) :: Particles

  DEALLOCATE( Particles % Velocity ) 
  DEALLOCATE( Particles % Coordinate ) 
  DEALLOCATE( Particles % Distance ) 
  DEALLOCATE( Particles % Status ) 
  DEALLOCATE( Particles % ElementIndex ) 
  Particles % MaxNumberOfParticles = 0
  Particles % NumberOfParticles = 0
  
END SUBROUTINE DestroyParticles



SUBROUTINE GetParticleLocation(Particles,No,Coord,Velo,Dist,Status,ElementIndex)
  TYPE(Particle_t) :: Particles
  INTEGER :: No
  REAL(KIND=dp) :: Coord(:),Velo(:)
  REAL(KIND=dp), OPTIONAL :: Dist
  INTEGER, OPTIONAL :: Status
  INTEGER, OPTIONAL :: ElementIndex

  IF( Particles % dim == 3 ) THEN
    Coord = Particles % Coordinate(no,:)
    Velo = Particles % Velocity(no,:)
  ELSE
    Velo(1:2) = Particles % Velocity(no,:)
    Coord(1:2) = Particles % Coordinate(no,:)
  END IF
  IF( PRESENT(Dist) )   Dist = Particles % Distance(No)
  IF( PRESENT(Status) ) Status = Particles % Status(No)
  IF( PRESENT(ElementIndex) ) Status = Particles % ElementIndex(No)

END SUBROUTINE GetParticleLocation


SUBROUTINE SetParticleLocation(Particles,No,Coord,Velo,Dist,Status,ElementIndex)
  TYPE(Particle_t) :: Particles
  INTEGER :: No
  REAL(KIND=dp) :: Coord(:),Velo(:)
  REAL(KIND=dp), OPTIONAL :: Dist
  INTEGER, OPTIONAL :: Status
  INTEGER, OPTIONAL :: ElementIndex

  IF( Particles % dim == 3 ) THEN
    Particles % Coordinate(No,:) = Coord
    Particles % Velocity(No,:) = Velo
  ELSE
    Particles % Velocity(No,1:2) = Velo(1:2)
    Particles % Coordinate(No,1:2) = Coord(1:2)
  END IF
  IF( PRESENT(Dist) )   Particles % Distance(No) = Dist
  IF( PRESENT(Status) ) Particles % Status(No) = Status
  IF( PRESENT(ElementIndex) ) Particles % ElementIndex(No) = ElementIndex

END SUBROUTINE SetParticleLocation



!------------------------------------------------------------------------
! Initialize particle positions and velocities.
!-------------------------------------------------------------------------
SUBROUTINE InitializeParticles( Particles, InitParticles, AppendParticles ) 

  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: InitParticles
  LOGICAL, OPTIONAL :: AppendParticles

  TYPE(ValueList_t), POINTER :: Params 
  TYPE(Variable_t), POINTER :: Var
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: Offset, NewParticles,LastParticle
  INTEGER :: dim
  REAL(KIND=dp), POINTER :: Coords(:,:), Velo(:,:)
  CHARACTER(LEN=MAX_NAME_LEN) :: InitMethod, MaskVariable    
  INTEGER :: i,j,k,nonodes
  INTEGER, POINTER :: MaskPerm(:), InvPerm(:)
  LOGICAL :: GotIt, GotMask
  REAL(KIND=dp), POINTER :: InitialValues(:,:)
  REAL(KIND=dp) :: mass,boltz,temp,coeff 
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
  

  IF( PRESENT( AppendParticles ) ) THEN
    Offset = Particles % NumberOfParticles
  ELSE
    Offset = 0
  END IF
  IF( PRESENT( InitParticles ) ) THEN
    NewParticles = InitParticles
  ELSE
    NewParticles = Particles % MaxNumberOfParticles
  END IF

  LastParticle = Offset + NewParticles

  Mesh => GetMesh()
  dim = Mesh % MeshDim
  CALL AllocateParticles( Particles, LastParticle, dim ) 

  Velo => Particles % Velocity
  Coords => Particles % Coordinate
  

  Params => GetSolverParams()
  
  !------------------------------------------------------------------------
  ! The user may use a mask to initialize the particles only at a part of the 
  ! domain, or to utilize the ordeing of the permutation vector.
  !-------------------------------------------------------------------------
  
  GotMask = .FALSE.
  nonodes = Mesh % NumberOfNodes
  
  MaskVariable = ListGetString( Params,'Mask Variable Name',GotIt )
  IF(GotIt) THEN
    Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
    IF( ASSOCIATED( Var ) ) THEN
      MaskPerm => Var % Perm
      IF( ASSOCIATED(MaskPerm) ) THEN
        GotMask = .TRUE.
        nonodes = MAXVAL( MaskPerm ) 
        ALLOCATE( InvPerm(nonodes) )
        DO i=1,SIZE(MaskPerm)
          j = MaskPerm(i)
          IF( j > 0 ) InvPerm(j) = i
        END DO
      END IF
    END IF
  END IF
  
  !------------------------------------------------------------------------
  ! Position may be initialized using a given list, or using the nodal
  ! coordinates to initalize positions.
  !-------------------------------------------------------------------------
  
  InitMethod = ListGetString( Params,'Position Initialization Method',gotIt ) 
  
  SELECT CASE ( InitMethod ) 
    
  CASE ('nodal ordered')
    DO i=1,NewParticles
      k = Offset + i
      j = MODULO( i * NewParticles -1 , nonodes ) + 1
      IF( GotMask ) j = InvPerm(j)
      Coords(k,1) = Mesh % Nodes % x(j)
      Coords(k,2) = Mesh % Nodes % y(j)
      IF( dim == 3 ) Coords(k,3) = Mesh % Nodes % z(j)
    END DO
    
  CASE DEFAULT 
    
    InitialValues => ListGetConstRealArray(Params,'Initial Coordinates',gotIt)    
      IF(gotIt) THEN
        IF( SIZE(InitialValues,2) /= dim ) THEN
          CALL Fatal('ParticleTracker','Wrong dimension in Initial Coordinates')
        ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
          DO i=1,NewParticles
            k = offset + i
            Coords(k,1:dim) = InitialValues(1,1:dim)
          END DO
        ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
          CALL Fatal('ParticleTracker','Wrong number of particles in Initial Coordinates')
        ELSE
          DO i=1,NewParticles
            k = Offset + i
            Coords(k,1:dim) = InitialValues(i,1:DIM)
          END DO
        END IF
      ELSE
        CALL Fatal('ParticleTracker','Initial Coordinates not given')
      END IF
    END SELECT


    !------------------------------------------------------------------------
    ! Velocities may be initialized using a given list, or obtaining them
    ! from a thermal maxwell boltzmann distribution. These are additive to 
    ! allow bulk velocities with the thermal one.
    !-------------------------------------------------------------------------

    InitialValues => ListGetConstRealArray(Params,'Initial Velocities',gotIt)
    IF(gotIt) THEN
      IF( SIZE(InitialValues,2) /= DIM ) THEN
        CALL Fatal('ParticleTracker','Wrong dimension in Initial Velocities')
      ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
        DO i=1,NewParticles
          k = Offset + i
          Velo(k,1:dim) = InitialValues(1,1:DIM)
        END DO
      ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
        CALL Fatal('ParticleTracker','Wrong number of particles in Initial Velocities')
      ELSE
        DO i=1,NewParticles
          k = Offset + i
          Velo(k,1:dim) = InitialValues(i,1:DIM)
        END DO
      END IF
    END IF



    InitMethod = ListGetString( Params,'Velocity Initialization Method',gotIt ) 

    SELECT CASE ( InitMethod ) 
      
    CASE ('thermal')  
      
      mass = ListGetConstReal( Params,'Particle Mass')
      temp = ListGetConstReal( Params,'Particle Temperature')
      boltz = ListGetConstReal( CurrentModel % Constants,'Boltzmann constant')
      coeff = SQRT(boltz * temp / mass )

      DO i=1,NewParticles
        k = Offset + i
        Velo(k,1) = Velo(k,1) + coeff * NormalRandom()
        Velo(k,2) = Velo(k,2) + coeff * NormalRandom()
        IF( dim == 3 ) Velo(k,3) = Velo(k,3) + coeff * NormalRandom()
      END DO

    CASE DEFAULT

    END SELECT


    IF( GotMask ) DEALLOCATE( InvPerm ) 


  END SUBROUTINE InitializeParticles



  !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutput( Particles ) 
    
    TYPE(Particle_t) :: Particles

    TYPE(Variable_t), POINTER :: TimeVar
    TYPE(ValueList_t), POINTER :: Params 
    CHARACTER(LEN=MAX_NAME_LEN) :: FilePrefix, FileName
    LOGICAL :: Found, NumberFilesByParticles, NumberFilesBySteps
    REAL(KIND=dp), POINTER :: Coord(:,:), Velo(:,:), Dist(:)
    REAL(KIND=dp) :: time
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: Status(:)
    INTEGER :: i,j,dim, MinSaveStatus
    INTEGER :: VisitedTimes = 0

    SAVE :: VisitedTimes, Params, FilePrefix, NumberFilesByParticles, NumberFilesBySteps, &
        MinSaveStatus, TimeVar

    Mesh => GetMesh()

    IF( VisitedTimes == 0 ) THEN
      Params => GetSolverParams()
      FilePrefix = ListGetString(Params,'Filename Prefix',Found )
      IF(.NOT. Found) FilePrefix = 'track'
      CALL WriteParticleFileNames(FilePrefix)

      NumberFilesByParticles = ListGetLogical( Params,'File Numbering By Particles',Found) 
      NumberFilesBySteps = ListGetLogical( Params,'File Numbering By Steps',Found) 
      IF( NumberFilesByParticles .AND. NumberFilesBySteps ) THEN
        CALL Fatal('ParticleTracker','Files may be numbered either by steps or particles')
      END IF
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      
      TimeVar => VariableGet( Mesh % Variables,'time')
    END IF

    VisitedTimes = VisitedTimes + 1 
    time = TimeVar % Values(1)


    dim = Particles % dim
    Coord => Particles % Coordinate
    Velo => Particles % Velocity 
    Dist => Particles % Distance
    Status => Particles % Status


    IF(.NOT. NumberFilesByParticles ) THEN
      IF( NumberFilesBySteps ) THEN
        CALL OpenParticleFile(FilePrefix, VisitedTimes )
      ELSE
        CALL OpenParticleFile(FilePrefix, 0 )        
      END IF
      DO i = 1, Particles % NumberOfParticles
        IF( Particles % Status(i) < MinSaveStatus ) CYCLE
        CALL WriteParticleLine( dim, i )        
      END DO
      CALL CloseParticleFile()
    ELSE
      DO i = 1, Particles % NumberOfParticles
        IF( Particles % Status(i) < MinSaveStatus ) CYCLE
        CALL OpenParticleFile(FilePrefix, i)
        CALL WriteParticleLine( dim, i ) 
        CALL CloseParticleFile()
      END DO
    END IF


  CONTAINS

    !------------------------------------------------------------------------
    ! Write the names file for user information. Remember to update this if 
    ! SaveParticleStep is modified.
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleFileNames( Prefix ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix, FileName
      INTEGER :: i,j
      
      WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat.names'
      
      OPEN (10, FILE=FileName )
      
      WRITE( 10, '(A)' ) 'Variables in file: '//TRIM(FilePrefix)//'*.dat'
      i = 1
      WRITE( 10, '(I2,A)' )  i,': time'
      WRITE( 10, '(I2,A)' )  i+1,': Coordinate_1'
      WRITE( 10, '(I2,A)' )  i+2,': Coordinate_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Coordinate_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Velocity_1'
      WRITE( 10, '(I2,A)' )  i+2,': Velocity_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Velocity_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Distance'
      i = i + 1
      
      CLOSE( 10 )
      
    END SUBROUTINE WriteParticleFileNames



    !------------------------------------------------------------------------
    ! Open a numbered file for each particle. These must be separate since the 
    ! number of steps for each particle may vary greatly
    !-------------------------------------------------------------------------
    SUBROUTINE OpenParticleFile( Prefix, FileNo ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: FileNo

      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      
      IF( FileNo == 0 ) THEN
        WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat'
        CALL Info( 'ParticleTracker', 'Saving particle paths to file: '//TRIM(FileName), Level=4 )
      ELSE IF( FileNo < 10 ) THEN
        IF( FileNo == 1 ) THEN
          WRITE( Message, * ) 'Saving particle paths to files: ', TRIM(FilePrefix)//'_*.dat'
          CALL Info( 'ParticleTracker', Message, Level=4 )
        END IF
        WRITE( FileName,'(A,A,I1,A)') TRIM(FilePrefix),'_',fileno,'.dat'
      ELSE IF( FileNo < 100 ) THEN
        WRITE( FileName,'(A,A,I2,A)') TRIM(FilePrefix),'_',fileno,'.dat'
      ELSE IF( FileNo < 1000 ) THEN
        WRITE( FileName,'(A,A,I3,A)') TRIM(FilePrefix),'_',fileno,'.dat'
      END IF
      
      IF( VisitedTimes == 0 .OR. NumberFilesBySteps ) THEN
        OPEN (10, FILE=FileName )
      ELSE
        OPEN (10, FILE=FileName,POSITION='APPEND' )
      END IF

    END SUBROUTINE OpenParticleFile
    
    
    !------------------------------------------------------------------------
    ! Save one line in the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleLine( Dim, No )
      INTEGER :: Dim, No
      
      IF( dim == 2 ) THEN
        WRITE( 10, * ) time, Coord(No,1:2), Velo(No,1:2), Dist(No) 
      ELSE
        WRITE( 10, * ) time, Coord(No,1:3), Velo(No,1:3), Dist(No) 
      END IF
      
    END SUBROUTINE WriteParticleLine
    
    
    !------------------------------------------------------------------------
    ! Close the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE CloseParticleFile( )
      
      CLOSE( 10 )
      
    END SUBROUTINE CloseParticleFile
    
       
  END SUBROUTINE ParticleOutput


!---------------------------------------------------------------------------
  SUBROUTINE SegmentElementIntersection(Mesh,BulkElement,&
      Rinit,Rfin,MinLambda,FaceElement)
!---------------------------------------------------------------------------
! This subroutine finds the possible intersection between elementfaces 
! and a line segment.
!---------------------------------------------------------------------------

  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER   :: BulkElement
  REAL(KIND=dp) :: Rinit(3), Rfin(3), MinLambda
  TYPE(Element_t), POINTER :: FaceElement

  TYPE(Element_t), POINTER   :: BoundaryElement
  TYPE(Nodes_t), SAVE :: BoundaryNodes
  REAL(KIND=dp) :: Lambda, Epsilon
  INTEGER :: i,j,n
  INTEGER, POINTER :: NodeIndexes(:)
  LOGICAL :: AtBoundary, Visited = .FALSE.


  SAVE  Visited

  
  MinLambda = HUGE( MinLambda ) 
  Epsilon = TINY( Lambda ) 
  FaceElement => Null()

  IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
    DO i=1, BulkElement % TYPE % NumberOfFaces  
      j = BulkElement % FaceIndexes(i)
      BoundaryElement => Mesh % Faces( j )
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)

      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 
      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  ELSE
    DO i=1, BulkElement % TYPE % NumberOfEdges  
      j = BulkElement % EdgeIndexes(i)
      BoundaryElement => Mesh % Edges( j )
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)
     
      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 

      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  END IF

END SUBROUTINE SegmentElementIntersection






!------------------------------------------------------------------------
! Compute field values at the given points in the FE mesh. 
! Differs from the PointInMesh category in that the particle may
! have initial information about its location making marching 
! routines more feasible. These are also more attractive for 
! parallel implementation point of view.
!-------------------------------------------------------------------------
SUBROUTINE LocateParticleInMesh( ElementIndex, Rinit, Rfin, &
    Init, LocalCoords, Hit, Lambda )
  
  INTEGER :: ElementIndex
  REAL(KIND=dp) :: Rinit(3), Rfin(3),LocalCoords(3)
  LOGICAL :: Init, Hit
  REAL(KIND=dp), OPTIONAL :: Lambda

  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp) :: Rtmp(3), MinLambda 
  LOGICAL :: Stat, CheckFirst, StopAtFace, AtWall, Visited = .FALSE.,Debug,DoInit
  INTEGER :: i,j,k,n,FaceIndex,SearchMethod,Cnt,MaxTrials
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element, FaceElement, LeftElement, RightElement, &
      NextElement
  TYPE(Quadrant_t), POINTER, SAVE :: RootQuadrant =>Null(), LeafQuadrant
  REAL(kind=dp) :: BoundingBox(6), eps2, eps1
  

  SAVE :: Mesh, CheckFirst, StopAtFace, SearchMethod, Debug, MaxTrials, Cnt

  Mesh => GetMesh()

  IF( .NOT. Visited ) THEN
    Params => GetSolverParams()
    CheckFirst = ListGetLogical( Params,'Particle Element Search Check',Stat)
    StopAtFace = ListGetLogical( Params,'Particle Stop At Face',Stat)
    SearchMethod = ListGetInteger( Params,'Particle Element Search Method',Stat)
    MaxTrials = ListGetInteger( Params,'Particle Search Max Trials',Stat)
    IF(.NOT. Stat) MaxTrials = Mesh % NumberOfBulkElements
    Debug = .FALSE.
    Visited = .TRUE.
  END IF


  Hit = .FALSE.
  DoInit = Init
  IF( PRESENT( Lambda ) ) Lambda = 1.0_dp
  
  ! Check that the previous hit is not hit even now
  !-------------------------------------------------
  IF( ElementIndex > 0 .AND. CheckFirst) THEN
    PRINT *,'Checking element',ElementIndex

    Element => Mesh % Elements( ElementIndex ) 
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)
    
    IF ( PointInElement( Element, ElementNodes, &
        Rfin, LocalCoords ) ) THEN
      Hit = .TRUE.
    END IF
  END IF

  IF( Hit ) RETURN
  
  Cnt = 0

  SELECT CASE ( SearchMethod )
    
  CASE( 1 ) 
    !----------------------------------------------------------
    ! Go through all bulk elements in a dummy search.
    ! This algorithm is mainly here for debugging purposes.
    !----------------------------------------------------------
    DO k=1, Mesh % NumberOfBulkElements
      Element => Mesh % Elements(k)
      n = GetElementNOFNodes(Element)
      CALL GetElementNodes(ElementNodes,Element)
      
      Cnt = Cnt + 1

      IF ( PointInElement( Element, ElementNodes, &
          Rfin, LocalCoords ) ) THEN
        Hit = .TRUE.
        EXIT
      END IF
    END DO
    
  CASE( 2 )        
    !-----------------------------------------------------------
    ! Find the right element using an octree search
    ! This is optimal when the particles are searched only once.
    !-----------------------------------------------------------

    IF ( .NOT.ASSOCIATED(Mesh % RootQuadrant) ) THEN
      BoundingBox(1) = MINVAL( Mesh % Nodes % x )
      BoundingBox(2) = MINVAL( Mesh % Nodes % y )
      BoundingBox(3) = MINVAL( Mesh % Nodes % z )
      BoundingBox(4) = MAXVAL( Mesh % Nodes % x )
      BoundingBox(5) = MAXVAL( Mesh % Nodes % y )
      BoundingBox(6) = MAXVAL( Mesh % Nodes % z )
      
      eps1 = 1.0e-3
      eps2 = eps1 * MAXVAL( BoundingBox(4:6) - BoundingBox(1:3) )
      BoundingBox(1:3) = BoundingBox(1:3) - eps2
      BoundingBox(4:6) = BoundingBox(4:6) + eps2
      
      CALL BuildQuadrantTree( Mesh,BoundingBox,Mesh % RootQuadrant)
    END IF
    RootQuadrant => Mesh % RootQuadrant
      
    Element => Null()
    CALL FindLeafElements(Rfin, Mesh % MeshDim, RootQuadrant, LeafQuadrant)
    IF ( ASSOCIATED(LeafQuadrant) ) THEN
      DO k=1, LeafQuadrant % NElemsInQuadrant
        Element => Mesh % Elements(LeafQuadrant % Elements(k))
        
        n = GetElementNOFNodes()
        CALL GetElementNodes( ElementNodes, Element)
        
	Cnt = Cnt + 1

        IF ( PointInElement( Element, ElementNodes, Rfin, LocalCoords ) ) THEN
          Hit = .TRUE.
          EXIT
        END IF
      END DO
    ELSE
      CALL Info('LocateParticleInMesh','No leaf quadrant associated!')
    END IF
    
    
  CASE DEFAULT
    !--------------------------------------------------------------------
    ! This is a recursive algorithm that checks the intersections 
    ! of line segments and points until correct element is found.
    ! This is optimal when the stepsize is small and there are many steps.
    !--------------------------------------------------------------------
    CALL FindMeshEdges( Mesh, .FALSE.)
    IF( ElementIndex == 0 ) THEN
      ElementIndex = 1
      DoInit = .TRUE.
    END IF
    DoInit = .TRUE.
    Hit = .FALSE.

    Element => Mesh % Elements( ElementIndex ) 
    eps1 = 1.0d-10

    DO i=1,MaxTrials
      n = GetElementNOFNOdes(Element)
      CALL GetElementNodes(ElementNodes,Element)

      IF( DoInit ) THEN
        Rtmp(1) = SUM( ElementNodes % x(1:n) ) / n
        Rtmp(2) = SUM( ElementNodes % y(1:n) ) / n
        Rtmp(3) = SUM( ElementNodes % z(1:n) ) / n
!	PRINT *,'Rinit',n,Rtmp
      ELSE
        Rtmp = Rinit
      END IF

      IF( i == 1 .AND. Debug ) THEN
        PRINT *,'initial dist',SQRT( SUM((Rtmp - Rfin)**2) )
      END IF

      Cnt = Cnt + 1

      CALL SegmentElementIntersection(Mesh,Element,&
          Rtmp,Rfin,MinLambda,FaceElement )

      !PRINT *,'MinLambda: ',MinLambda
      IF( .NOT. ASSOCIATED( FaceElement ) ) THEN
        CALL Warn('LocateParticleInMesh','No intersection found?')
      ELSE IF( MinLambda > 1.0 - eps1 ) THEN
        Hit = .TRUE.
        Rtmp = Rfin
        EXIT
      ELSE 
        AtWall = .FALSE.
        LeftElement => FaceElement % BoundaryInfo % Left
        RightElement => FaceElement % BoundaryInfo % Right

        IF( ASSOCIATED( LeftElement) .AND. ASSOCIATED(RightElement)) THEN
          IF( ASSOCIATED(Element, LeftElement)) THEN
            NextElement => RightElement
          ELSE
            NextElement => LeftElement
          END IF
        ELSE IF( ASSOCIATED( Element, LeftElement ) ) THEN
           AtWall = .TRUE.
        ELSE IF( ASSOCIATED( Element, RightElement ) ) THEN
          AtWall = .TRUE.
        ELSE
          CALL Warn('LocateParticleInMesh','Element is neither left or right!')
          EXIT
        END IF

        IF( AtWall .OR. StopAtFace ) THEN
          Hit = .TRUE.
          IF( PRESENT( Lambda ) ) Lambda = MinLambda
          Rtmp = Rinit + MinLambda * (Rfin - Rinit) 
          EXIT
        ELSE
          Element => NextElement
        END IF
      END IF
    END DO
    
    Hit = PointInElement( Element, ElementNodes, Rtmp, LocalCoords ) 
    IF( Hit ) THEN
      IF( Debug ) THEN
        CALL Info('LocateParticleInMesh','Point found!')
        PRINT *,'Dist',i,SQRT( SUM((Rtmp - Rfin)**2) )
      END IF
    ELSE
      CALL Warn('LocateParticleInMesh','Should have found the point in element!')
    END IF
    ElementIndex = Element % ElementIndex

    
  END SELECT

  IF( Debug ) PRINT *,'Test count: ',Cnt
  
END SUBROUTINE LocateParticleInMesh





!------------------------------------------------------------------------------
END MODULE ParticleUtils
!------------------------------------------------------------------------------
