 
MODULE ParticleUtils

   USE DefUtils

   IMPLICIT NONE

   INTEGER, PARAMETER :: PARTICLE_ALLOCATED = 1, &
	                 PARTICLE_WAITING = 2, &
                         PARTICLE_INITIATED = 3, &
                         PARTICLE_LOCATED = 4, &
                         PARTICLE_FACEBOUNDARY = 5, &
                         PARTICLE_WALLBOUNDARY = 6, &
                         PARTICLE_PARTBOUNDARY = 7, &
                         PARTICLE_HIT = 8, & 
                         PARTICLE_READY = 9, &
	                 PARTICLE_LOST = 10, &
	                 PARTICLE_GHOST = 11

CONTAINS



!---------------------------------------------------------
! The following subroutines make the data structure 
! transparent in the user subrouines and thereby make
! them more recilient to time.
!---------------------------------------------------------
FUNCTION GetParticleCoord(Particles,No,DerOrder) RESULT ( Coord )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  REAL(KIND=dp) :: Coord(3) 

  INTEGER :: dim

  Coord(3) = 0.0_dp
  dim = Particles % dim

  IF( DerOrder == 0 ) THEN
    Coord(1:dim) = Particles % Coordinate(no,:)
  ELSE IF( DerOrder == 1 ) THEN
    Coord(1:dim) = Particles % Velocity(no,:)
  ELSE IF( DerOrder == 2 ) THEN
    Coord(1:dim) = Particles % Acceleration(no,:)
  END IF
END FUNCTION GetParticleCoord


SUBROUTINE SetParticleCoord(Particles,No,DerOrder,Coord)
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  REAL(KIND=dp) :: Coord(3) 

  INTEGER :: dim

  dim = Particles % dim

  IF( DerOrder == 0 ) THEN
    Particles % Coordinate(no,:) = Coord(1:dim)
  ELSE IF( DerOrder == 1 ) THEN
    Particles % Velocity(no,:) = Coord(1:dim)
  ELSE IF( DerOrder == 2 ) THEN
    Particles % Acceleration(no,:) = Coord(1:dim)
  END IF
END SUBROUTINE SetParticleCoord


SUBROUTINE AddParticleCoord(Particles,No,DerOrder,Coord)
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  REAL(KIND=dp) :: Coord(3) 

  INTEGER :: dim

  dim = Particles % dim

  IF( DerOrder == 0 ) THEN
    Particles % Coordinate(no,:) = &
        Particles % Coordinate(no,:) + Coord(1:dim)
  ELSE IF( DerOrder == 1 ) THEN
    Particles % Velocity(no,:) = &
        Particles % Velocity(no,:) + Coord(1:dim)
  ELSE IF( DerOrder == 2 ) THEN
    Particles % Acceleration(no,:) = &
        Particles % Acceleration(no,:) + Coord(1:dim)
  END IF
END SUBROUTINE AddParticleCoord



FUNCTION GetParticleStatus(Particles,No) RESULT ( Status )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Status

  Status = Particles % Status(No)
END FUNCTION GetParticleStatus


SUBROUTINE SetParticleStatus(Particles,No,Status )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Status

  Particles % Status(No) = Status
END SUBROUTINE SetParticleStatus


FUNCTION GetParticleElement(Particles,No) RESULT ( Index ) 
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Index

  Index = Particles % ElementIndex(No)
END FUNCTION GetParticleElement


SUBROUTINE SetParticleElement(Particles,No,Index )
  TYPE(Particle_t) :: Particles
  INTEGER :: No, DerOrder
  INTEGER :: Index

  Particles % ElementIndex(No) = Index
END SUBROUTINE SetParticleElement


!---------------------------------------------------------
! Allocate particles before launching them
!---------------------------------------------------------
SUBROUTINE AllocateParticles(Particles,NoParticles,dim,TimeOrder)

  TYPE(Particle_t) :: Particles
  INTEGER :: NoParticles
  INTEGER, OPTIONAL :: dim
  INTEGER, OPTIONAL :: TimeOrder

  REAL(KIND=dp), POINTER :: Velocity(:,:), Acceleration(:,:), &
       Coordinate(:,:), Distance(:),Dt(:)
  INTEGER, POINTER :: Status(:), ElementIndex(:), FaceIndex(:), Closest(:)
  INTEGER :: PrevNoParticles, dofs, No, n
  
  IF( NoParticles <= Particles % MaxNumberOfParticles ) THEN
    CALL Info('AllocateParticles','There are already enough particles')
    RETURN
  ELSE
    WRITE(Message,*) 'Allocating number of particles:',NoParticles
    CALL Info('AllocateParticles',Message)    
  END IF

  IF(PRESENT(TimeOrder)) THEN
    Particles % TimeOrder = TimeOrder
  ELSE
    Particles % TimeOrder = 1
  END IF

  IF( .NOT. PRESENT( dim ) ) THEN
    dofs = 3 
  ELSE
    IF( dim == 2 .OR. dim == 3 ) THEN
      dofs = dim
    ELSE
      CALL Warn('AllocateParticles','Invalid dimension')
      RETURN
    END IF
  END IF
  Particles % dim = dofs

  IF( Particles % MaxNumberOfParticles == 0 ) THEN
    ALLOCATE( Particles % Coordinate(NoParticles,dofs))
    ALLOCATE( Particles % Distance(NoParticles))
    ALLOCATE( Particles % Dt(NoParticles))
    ALLOCATE( Particles % Status(NoParticles))
    ALLOCATE( Particles % ElementIndex(NoParticles))

    Particles % Coordinate = 0.0_dp
    Particles % Distance = 0.0_dp
    Particles % Dt = 0.0_dp
    Particles % Status = PARTICLE_ALLOCATED
    Particles % ElementIndex = 0
    Particles % MaxNumberOfParticles = NoParticles

    IF( Particles % TimeOrder >= 1 ) THEN
      ALLOCATE( Particles % Velocity(NoParticles,dofs))
      Particles % Velocity = 0.0_dp
    END IF

    IF( Particles % TimeOrder >= 2 ) THEN
      ALLOCATE( Particles % Acceleration(NoParticles,dofs) )
      Particles % Acceleration = 0.0_dp
    END IF

    ALLOCATE( Particles % FaceIndex(NoParticles))
    Particles % FaceIndex = 0

  ELSE 
    PrevNoParticles = Particles % NumberOfParticles 
    
    Coordinate => Particles % Coordinate
    Velocity => Particles % Velocity
    Acceleration => Particles % Acceleration
    Distance => Particles % Distance
    Status => Particles % Status
    Dt => Particles % Dt
    Closest => Particles % ClosestNode
    FaceIndex => Particles % FaceIndex
    ElementIndex => Particles % ElementIndex

    ALLOCATE( Particles % Coordinate(NoParticles,dofs) )
    IF ( ASSOCIATED(Velocity) ) &
      ALLOCATE( Particles % Velocity(NoParticles,dofs) )

    IF ( ASSOCIATED(Acceleration) ) &
      ALLOCATE( Particles % Acceleration(NoParticles,dofs) )

    IF ( ASSOCIATED(Closest) ) &
      ALLOCATE( Particles % ClosestNode(NoParticles) )

    ALLOCATE( Particles % Distance(NoParticles) )
    ALLOCATE( Particles % Status(NoParticles) )
    ALLOCATE( Particles % Dt(NoParticles) )
    ALLOCATE( Particles % FaceIndex(NoParticles))
    ALLOCATE( Particles % ElementIndex(NoParticles) )

    ! Delete lost particles...
    ! ------------------------
    n = 0
    DO No=1,PrevNoParticles
      IF ( Status(No) == PARTICLE_LOST ) CYCLE
      n=n+1
      Particles % Coordinate(n,:) = Coordinate(No,:)
      IF ( ASSOCIATED(Velocity) ) Particles % Velocity(n,:)=Velocity(No,:)
      IF ( ASSOCIATED(Acceleration) ) Particles % Acceleration(n,:)=Acceleration(No,:)
      IF ( ASSOCIATED(Closest) ) Particles % ClosestNode(n)=Closest(No)
      Particles % Distance(n) = Distance(No)
      Particles % Status(n) = Status(No)
      Particles % Dt(n) = Dt(No)
      Particles % FaceIndex(n) = FaceIndex(No)
      Particles % ElementIndex(n) = ElementIndex(No)
    END DO
    PrevNoParticles = n
    Particles % NumberOfParticles = n

    IF ( ASSOCIATED(Acceleration) ) DEALLOCATE(Acceleration)
    IF ( ASSOCIATED(Velocity) ) DEALLOCATE(Velocity)
    IF ( ASSOCIATED(Closest) ) DEALLOCATE(Closest)
    DEALLOCATE(Coordinate, Distance, Status, ElementIndex, Dt, FaceIndex )

    IF ( ASSOCIATED(Particles % Velocity) ) & 
       Particles % Velocity(PrevNoParticles+1:NoParticles,:) = 0.0_dp

    IF ( ASSOCIATED(Particles % Acceleration) ) &
       Particles % Acceleration(PrevNoParticles+1:NoParticles,:) = 0.0_dp

    IF ( ASSOCIATED(Particles % ClosestNode) ) &
       Particles % ClosestNode(PrevNoParticles+1:NoParticles) = 0

    Particles % Coordinate(PrevNoParticles+1:NoParticles,:) = 0.0_dp
    Particles % Dt(PrevNoParticles+1:NoParticles) = 0.0_dp
    Particles % Distance(PrevNoParticles+1:NoParticles) = 0.0_dp
    Particles % ElementIndex(PrevNoParticles+1:NoParticles) = 0
    Particles % Status(PrevNoParticles+1:NoParticles) = PARTICLE_ALLOCATED

    Particles % MaxNumberOfParticles = NoParticles
  END IF
END SUBROUTINE AllocateParticles


!----------------------------------------------------
! Delete lost particles:
!----------------------------------------------------
SUBROUTINE DeleteLostParticles(Particles)
  TYPE(Particle_t) :: Particles

  INTEGER :: No, n, PrevNoParticles

  PrevNoParticles = Particles % NumberOfParticles

  n = 0
  DO No=1,PrevNoParticles
    IF ( Particles % Status(No) == PARTICLE_LOST ) CYCLE
    n=n+1
    IF ( n==No ) CYCLE

    Particles % Coordinate(n,:) = Particles % Coordinate(No,:)
    IF ( ASSOCIATED(Particles % Velocity) ) &
      Particles % Velocity(n,:)=Particles % Velocity(No,:)
    IF ( ASSOCIATED(Particles % Acceleration) ) &
      Particles % Acceleration(n,:)=Particles % Acceleration(No,:)
    IF ( ASSOCIATED(Particles % ClosestNode) ) &
      Particles % ClosestNode(n)=Particles % ClosestNode(No)
    Particles % Distance(n) = Particles % Distance(No)
    Particles % Status(n) = Particles % Status(No)
    Particles % Dt(n) = Particles % Dt(No)
    Particles % FaceIndex(n) = Particles % FaceIndex(No)
    Particles % ElementIndex(n) = Particles % ElementIndex(No)
  END DO
  Particles % NumberOfParticles = n

  IF ( n<PrevNoParticles ) THEN
    IF ( ASSOCIATED(Particles % Velocity) ) & 
       Particles % Velocity(n+1:PrevNoParticles,:) = 0.0_dp

    IF ( ASSOCIATED(Particles % Acceleration) ) &
       Particles % Acceleration(n+1:PrevNoParticles,:) = 0._dp

    IF ( ASSOCIATED(Particles % ClosestNode) ) &
       Particles % ClosestNode(n+1:PrevNoParticles) = 0

    Particles % Coordinate(n+1:PrevNoParticles,:) = 0._dp
    Particles % Dt(n+1:PrevNoParticles) = 0._dp
    Particles % Distance(n+1:PrevNoParticles) = 0._dp
    Particles % ElementIndex(n+1:PrevNoParticles) = 0
    Particles % Status(n+1:PrevNoParticles) = PARTICLE_ALLOCATED
  END IF
END SUBROUTINE DeleteLostParticles


!----------------------------------------------------
! Increase particle array size by given amount:
!----------------------------------------------------
SUBROUTINE IncreaseParticles(Particles,NoParticles)

  TYPE(Particle_t) :: Particles
  INTEGER :: NoParticles

  INTEGER :: Maxn

  ! Garbage collection:
  ! -------------------
  CALL DeleteLostParticles(Particles)
  
  ! Check if really need to allocate more space:
  ! --------------------------------------------
  Maxn = Particles % NumberOfParticles+NoParticles
  IF ( Maxn > Particles % MaxNumberOfParticles ) &
    CALL AllocateParticles( Particles,Maxn, &
          Particles % Dim, Particles % TimeOrder )

END SUBROUTINE IncreaseParticles



SUBROUTINE DestroyParticles(Particles) 
  TYPE(Particle_t) :: Particles

  IF ( ASSOCIATED(Particles % Velocity) ) &
       DEALLOCATE( Particles % Velocity ) 

  IF ( ASSOCIATED(Particles % Acceleration) ) &
       DEALLOCATE( Particles % Acceleration )

  DEALLOCATE( Particles % Coordinate ) 
  DEALLOCATE( Particles % Distance ) 
  DEALLOCATE( Particles % Dt ) 
  DEALLOCATE( Particles % Status ) 
  DEALLOCATE( Particles % FaceIndex )
  DEALLOCATE( Particles % ElementIndex ) 

  Particles % NumberOfParticles = 0
  Particles % MaxNumberOfParticles = 0
  
END SUBROUTINE DestroyParticles



!---------------------------------------------------------
! Subroutine for releaseing initiated but waiting particles.
!---------------------------------------------------------
SUBROUTINE ReleaseWaitingParticles(Particles) 
  TYPE(Particle_t) :: Particles

  TYPE(ValueList_t), POINTER :: Params
  INTEGER, POINTER :: Status(:)
  INTEGER :: i,j,NoParticles,ReleaseCount=0,ReleaseSet
  REAL(KIND=dp) :: ReleaseFraction
  LOGICAL :: Found,Visited = .FALSE.
  
  SAVE Visited, ReleaseCount
  
  ! Check whether all particles have already been released
  !-------------------------------------------------------
  NoParticles = Particles % NumberOfParticles
  IF( ReleaseCount >= NoParticles ) RETURN

  ! Get the size of the current release set
  !-------------------------------------------------------
  Params => GetSolverParams()
  ReleaseSet = GetInteger( Params,'Particle Release Set',Found)
  IF( .NOT. Found ) THEN
    ReleaseFraction = GetCReal( Params,'Particle Release Fraction',Found )
    IF(.NOT. Found ) THEN
      RETURN
    ELSE
      ReleaseSet = NINT( ReleaseFraction * NoParticles ) 
    END IF
  END IF
  IF( ReleaseSet <= 0 ) RETURN

  ! Release some waiting particles
  !-------------------------------------------------------
  Status => Particles % Status
  j = 0
  DO i=1,NoParticles
    IF( Status(i) == PARTICLE_WAITING ) THEN      
      Status(i) = PARTICLE_INITIATED 
      j = j + 1
      IF( j == ReleaseSet ) EXIT
    END IF
  END DO
  ReleaseCount = ReleaseCount + j

END SUBROUTINE ReleaseWaitingParticles


!---------------------------------------------------------
! Subroutine for chanching the partition of particles that
! cross the partition boundary.
!---------------------------------------------------------
FUNCTION ChangeParticlePartition(Particles) RESULT(nReceived)
!---------------------------------------------------------
  TYPE(Particle_t) :: Particles
!---------------------------------------------------------
  TYPE(Element_t), POINTER :: Face, Parent, Faces(:)

  INTEGER i,j,k,l,m,n,dim,NoPartitions, nextPart, nFaces, &
      Proc, ierr, status(MPI_STATUS_SIZE), n_part, nReceived

  INTEGER, ALLOCATABLE :: Perm(:), Indexes(:), Neigh(:), &
           Recv_parts(:), Requests(:)
  TYPE(Mesh_t), POINTER :: Mesh

  INTEGER, POINTER :: Neighbours(:)
  LOGICAL, POINTER :: FaceInterface(:)

  TYPE ExchgInfo_t
    INTEGER :: n=0
    INTEGER, POINTER :: Gindex(:), Particles(:)
  END TYPE ExchgInfo_t

  REAL(KIND=dp), ALLOCATABLE :: Buf(:)
  TYPE(ExchgInfo_t), ALLOCATABLE :: Info(:)
!---------------------------------------------------------

  nReceived = 0
  IF( ParEnv% PEs == 1 ) RETURN

  Mesh => GetMesh()
  dim = Particles % dim

  ! Count & Identify neighbouring partitions:
  ! -----------------------------------------
  NoPartitions = COUNT(ParEnv % IsNeighbour)
  ALLOCATE(Perm(ParEnv % PEs), Neigh(NoPartitions) )
  Perm = 0

  NoPartitions=0
  DO i=1,ParEnv % PEs
    IF ( i-1==ParEnv % Mype ) CYCLE
    IF ( ParEnv % IsNeighbour(i) ) THEN
      NoPartitions=NoPartitions+1
      Perm(i) = NoPartitions
      Neigh(NoPartitions) = i-1
    END IF
  END DO

  !
  ! Count particles to be sent to neighbours:
  ! -----------------------------------------
  ALLOCATE(Info(NoPartitions))
  Info % n = 0

  DO i=1,Particles % NumberOfParticles
    IF( Particles % Status(i)/=PARTICLE_WALLBOUNDARY ) CYCLE

    IF ( dim==2 ) THEN
       Face => Mesh % Edges(Particles % FaceIndex(i))
       FaceInterface  => Mesh % ParallelInfo % EdgeInterface
       Neighbours => Mesh % ParallelInfo %  &
          EdgeNeighbourList(Face % ElementIndex) % Neighbours
    ELSE
      Face => Mesh % Faces(Particles % FaceIndex(i))
      FaceInterface => Mesh % ParallelInfo % FaceInterface
      Neighbours => Mesh % ParallelInfo %  &
         FaceNeighbourList(Face % ElementIndex) % Neighbours
    END IF

    IF ( FaceInterface(Face % ElementIndex) ) THEN
      IF ( Face % BoundaryInfo % Constraint > 0 ) &
        CALL Warn("ChangeParticlePartition", "is this a BC after all?")

      nextPart = ParEnv % MyPE
      DO j=1,SIZE(Neighbours)
        IF ( ParEnv % Mype /= Neighbours(j) ) THEN
          nextPart = Perm(Neighbours(j)+1);
          IF ( nextPart<=0 ) CYCLE
          Info(nextPart) % n=Info(nextPart) % n+1
          Particles % Status(i) = PARTICLE_PARTBOUNDARY
          EXIT
        END IF
      END DO
      IF ( nextPart == ParEnv % mype ) Particles % Status(i)=PARTICLE_LOST
    END IF
  END DO

  !
  ! Receive interface sizes:
  !--------------------------
  ALLOCATE( Recv_Parts(NoPartitions), Requests(NoPartitions) )
  DO i=1,NoPartitions
    CALL MPI_iRECV( Recv_Parts(i),1, MPI_INTEGER, Neigh(i), &
         1000, MPI_COMM_WORLD, requests(i), ierr )
  END DO


! n = SUM(Recv_Parts)
! CALL MPI_ALLREDUCE( n, nReceived, 1, MPI_INTEGER, &
!         MPI_SUM, MPI_COMM_WORLD, ierr )

! IF ( nReceived==0 ) THEN
!   DEALLOCATE(Recv_Parts, Requests, Info, Perm, Neigh)
!   RETURN
! END IF

  !
  ! Collect particles to be sent to neighbours:
  ! -------------------------------------------
  DO i=1,NoPartitions
    ALLOCATE( Info(i) % Gindex(Info(i) % n), Info(i) % Particles(Info(i) % n) )
    Info(i) % n = 0
  END DO

  DO i=1,Particles % NumberOfParticles
    IF( Particles % Status(i) /= PARTICLE_PARTBOUNDARY ) CYCLE

    IF ( dim==2 ) THEN
       Face => Mesh % Edges(Particles % FaceIndex(i))
       FaceInterface  => Mesh % ParallelInfo % EdgeInterface
       Neighbours => Mesh % ParallelInfo %  &
          EdgeNeighbourList(Face % ElementIndex) % Neighbours
    ELSE
      Face => Mesh % Faces(Particles % FaceIndex(i))
      FaceInterface => Mesh % ParallelInfo % FaceInterface
      Neighbours => Mesh % ParallelInfo %  &
         FaceNeighbourList(Face % ElementIndex) % Neighbours
    END IF

    IF ( FaceInterface(Face % ElementIndex) ) THEN
      nextPart = ParEnv % MyPE
      DO j=1,SIZE(Neighbours)
        IF ( ParEnv % Mype /= Neighbours(j) ) THEN
          nextPart = Neighbours(j);
          EXIT
        END IF
      END DO
      Particles % Status(i) = PARTICLE_LOST
      j = Perm(nextPart+1)
      IF ( j==0 ) THEN
        CALL Warn( 'ChangeParticlePartition', 'Neighbouring partition not found?')
        CYCLE
      END IF
      Info(j) % n = Info(j) % n+1
      n = Info(j) % n
      Info(j) % Particles(n) = i
      Info(j) % Gindex(n) = Face % GElementIndex
    END IF
  END DO


  n = 0
  DO i=1,NoPartitions
    n = n + Info(i) % n
  END DO
  n = 2*(n + 2*(2*n*dim+n) + MPI_BSEND_OVERHEAD*2*NoPartitions)
  CALL CheckBuffer(n)

  ! Send particles:
  ! ---------------
  DO j=1,NoPartitions
    n = Info(j) % n
    IF ( n<=0 ) CYCLE

    CALL MPI_BSEND( Info(j) % Gindex, n, MPI_INTEGER, Neigh(j), &
               1001, MPI_COMM_WORLD, ierr )

    ALLOCATE(Buf(2*n*dim+n))
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Buf(m) = Particles % Coordinate(Info(j) % Particles(l),k)
      END DO
    END DO
    DO l=1,n
      m = m + 1
      Buf(m) = Particles % Dt(Info(j) % Particles(l))
    END DO

    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Buf(m) = Particles % Velocity(Info(j) % Particles(l),k)
        END DO
      END DO
    END IF

    CALL MPI_BSEND( Buf, m, MPI_DOUBLE_PRECISION, &
        Neigh(j), 1002, MPI_COMM_WORLD, ierr )

    DEALLOCATE(Buf)
  END DO

  DO i=1,NoPartitions
    CALL MPI_BSEND( Info(i) % n, 1, MPI_INTEGER, Neigh(i), &
             1000, MPI_COMM_WORLD, ierr )
  END DO
  CALL MPI_WaitAll( NoPartitions, Requests, MPI_STATUSES_IGNORE, ierr )

  DEALLOCATE(Perm)
  DO i=1,NoPartitions
    DEALLOCATE( Info(i) % Gindex, Info(i) % Particles )
  END DO
  DEALLOCATE(Info)


  ! Recv particles:
  ! ---------------

  n = SUM(Recv_Parts)
  IF ( Particles % NumberOfParticles+n > Particles % MaxNumberOfParticles ) THEN
    CALL IncreaseParticles( Particles, Particles % NumberOfParticles+2*n - &
               Particles % MaxNumberOfParticles )
  END IF

  IF(Particles % dim==2 ) THEN
    nFaces = Mesh % NumberOfEdges
    Faces => Mesh % Edges
  ELSE
    Faces => Mesh % Faces
    nFaces = Mesh % NumberOfFaces
  END IF


  DO i=1,NoPartitions
    n = Recv_Parts(i)
    IF ( n<=0 ) CYCLE

    proc = Neigh(i)
    ALLOCATE(Indexes(n))

    CALL MPI_RECV( Indexes, n, MPI_INTEGER, proc, &
          1001, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    DO j=1,n
      k=SearchIAItem( nFaces, Faces, Indexes(j) )
      IF ( k<=0 ) THEN
         PRINT*,ParEnv % myPE, 'failed'
         CYCLE
      END IF

      Face => Faces(k) 
      Parent => Face % BoundaryInfo % Left
      IF ( .NOT.ASSOCIATED(Parent) ) &
        Parent => Face % BoundaryInfo % Right

      n_part = n_part+1
      Particles % Status(n_part) = PARTICLE_PARTBOUNDARY
      Particles % ElementIndex(n_part) = Parent % ElementIndex
    END DO

    ALLOCATE(Buf(2*n*dim+n))

    m = n*dim+n
    IF ( ASSOCIATED(Particles % Velocity) ) m=m+n*dim
    CALL MPI_RECV( Buf, m, MPI_DOUBLE_PRECISION, proc, &
           1002, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Particles % Coordinate(n_part+l,k)=Buf(m)
      END DO
    END DO

    DO l=1,n
      m = m + 1
      Particles % Dt(n_part+l) = Buf(m)
    END DO

    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Particles % Velocity(n_part+l,k)=Buf(m)
        END DO
      END DO
    END IF
    DEALLOCATE(Buf)

    Particles % NumberOfParticles = Particles % NumberOfParticles+n
    DEALLOCATE(Indexes)
  END DO

  DEALLOCATE(Recv_Parts,Neigh,Requests)
! CALL MPI_BARRIER( MPI_COMM_WORLD, ierr )

CONTAINS
  
  !
  ! Search an element Item from an ordered Element_t array(N) and return
  ! Index to that array element. Return value -1 means Item was not found.
  !
  FUNCTION SearchIAItem( N, IArray, Item ) RESULT(Indx)
    IMPLICIT NONE
  
    INTEGER :: Item, Indx, i
    INTEGER :: N
    TYPE(Element_t) :: Iarray(:)

    ! Local variables

    INTEGER :: Lower, Upper, lou

    !*********************************************************************

    Indx  = -1
    Upper =  N
    Lower =  1

    ! Handle the special case

    IF ( Upper < Lower ) RETURN
  
    DO WHILE( .TRUE. )
      IF ( IArray(Lower) % GelementIndex == Item ) THEN
        Indx = Lower
        EXIT
      ELSE IF ( IArray(Upper) % GelementIndex == Item ) THEN
        Indx = Upper
        EXIT
      END IF

      IF ( (Upper - Lower) > 1 ) THEN
        Lou = ISHFT((Upper + Lower), -1)
        IF ( IArray(lou) % GelementIndex < Item ) THEN
          Lower = Lou
        ELSE
          Upper = Lou
        END IF
      ELSE
        EXIT
      END IF
    END DO
  END FUNCTION SearchIAItem
END FUNCTION ChangeParticlePartition
  

!---------------------------------------------------------
! Computes the means of coordinates / velocities / acceleration. 
! The statistics could be made more detailed...
!---------------------------------------------------------
SUBROUTINE ParticleStatistics( Particles, DerOrder ) 
  TYPE(Particle_t) :: Particles
  INTEGER :: DerOrder

  REAL(KIND=dp) :: Coord(3),MeanCoord(3),AbsCoord(3),VarCoord(3), &
      MinCoord(3), MaxCoord(3)
  
  INTEGER :: i,j,Cnt,NoParticles,TotParticles,dim
  REAL(KIND=dp), POINTER :: TargetVector(:,:)
  INTEGER, POINTER :: Status(:)

  MeanCoord = 0.0_dp
  AbsCoord = 0.0_dp
  VarCoord = 0.0_dp
  MinCoord = HUGE( MinCoord )
  MaxCoord = -HUGE( MaxCoord )

  Cnt = 0
  NoParticles =  Particles % NumberOfParticles
  dim = Particles % dim
  Coord = 0.0_dp

  IF( DerOrder == 0 ) THEN
    TargetVector => Particles % Coordinate
  ELSE IF( DerOrder == 1 ) THEN
    TargetVector => Particles % Velocity
  ELSE IF( DerOrder == 2 ) THEN
    TargetVector => Particles % Acceleration
  ELSE
    CALL Fatal('ParticleStatistics','Unknown value for DerOrder!')
  END IF

  Status => Particles % Status

  DO i=1,NoParticles
    IF( Status(i) >= PARTICLE_LOST ) CYCLE
    IF( Status(i) < PARTICLE_INITIATED ) CYCLE

    Coord(1:dim) = TargetVector(i,1:dim)

    MeanCoord = MeanCoord + Coord
    AbsCoord = AbsCoord + ABS( Coord )
    VarCoord = VarCoord + Coord ** 2
    DO j=1,dim
      MinCoord(j) = MIN( MinCoord(j), Coord(j) )
      MaxCoord(j) = MAX( MaxCoord(j), Coord(j) )
      Cnt = Cnt + 1
    END DO
  END DO
  
  IF( ParEnv % PEs > 1 ) THEN
    TotParticles = NINT( ParallelReduction( 1.0_dp * Cnt ) )
  ELSE
    TotParticles = Cnt
  END IF

  IF( TotParticles > 0 ) THEN
    ! Compute parallel sums?
    IF( ParEnv % PEs > 1 ) THEN
      DO j=1,dim
        MeanCoord = ParallelReduction( MeanCoord(j) )
        AbsCoord = ParallelReduction( AbsCoord(j) ) 
        VarCoord = ParallelReduction( varCoord(j) )
      END DO
    END IF

    MeanCoord = MeanCoord / TotParticles
    AbsCoord = AbsCoord / TotParticles
    VarCoord = SQRT( VarCoord / TotParticles - MeanCoord**2 ) 

    IF( ParEnv % myPE == 0 .OR. ParEnv % PEs == 1 ) THEN
      IF( DerOrder == 0 ) THEN
        PRINT *,'Statistical info on coordinate values:'
      ELSE IF( DerOrder == 1 ) THEN
        PRINT *,'Statistical info on velocity values:'
      ELSE IF( DerOrder == 2 ) THEN
        PRINT *,'Statistical info on acceleration values:'
      END IF
      
      PRINT *,'Mean:',MeanCoord(1:dim)
      PRINT *,'Abs: ',AbsCoord(1:dim)
      PRINT *,'Var: ',VarCoord(1:dim)
      PRINT *,'Min: ',MinCoord(1:dim)
      PRINT *,'Max: ',MaxCoord(1:dim)
    END IF
  ELSE
    CALL Warn('MeanParticleCoordinate','No active particles!')
  END IF

END SUBROUTINE ParticleStatistics
   


!---------------------------------------------------------
! Computes the characterestic speed for time integration
!---------------------------------------------------------
FUNCTION CharacteristicSpeed( Particles, No ) RESULT ( CharSpeed )
  TYPE(Particle_t) :: Particles
  REAL(KIND=dp) :: CharSpeed
  INTEGER, OPTIONAL :: No

  REAL(KIND=dp) :: Velo(3),Speed,SumSpeed,MaxSpeed
  INTEGER :: i,j,Cnt,NoParticles,dim,ParallelParticles
  REAL(KIND=dp), POINTER :: Velocity(:,:)
  INTEGER, POINTER :: Status(:)
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: UseMax, Visited = .FALSE.

  SAVE Visited, UseMax

  IF(.NOT. Visited ) THEN
    Params => GetSolverParams()
    UseMax = GetLogical( Params,'Characteristic Speed Max')
    Visited = .TRUE.
  END IF


  dim = Particles % dim
  Velocity => Particles % Velocity

  IF( PRESENT(No)) THEN
    Velo(1:dim) = Velocity(No,1:dim)
    CharSpeed = SQRT( SUM( Velo(1:dim) ** 2 ) )
    RETURN
  END IF

  NoParticles =  Particles % NumberOfParticles
  Status => Particles % Status
  CharSpeed = 0.0_dp
  Velo = 0.0_dp
  Cnt = 0

  ! Compute characteristic speed for square since it avoids taking the sqrt
  DO i=1,NoParticles
    IF( Status(i) >= PARTICLE_LOST ) CYCLE
    IF( Status(i) < PARTICLE_INITIATED ) CYCLE

    Cnt = Cnt + 1
    Velo(1:dim) = Velocity(i,1:dim)
    Speed = SUM( Velo(1:dim) ** 2 ) 
    SumSpeed = SumSpeed + Speed
    MaxSpeed = MAX( MaxSpeed, Speed ) 
  END DO

  IF( Cnt == 0 ) RETURN
  
  IF( UseMax ) THEN 
    CharSpeed = ParallelReduction( MaxSpeed, 2 )
  ELSE
    ParallelParticles = NINT( ParallelReduction( 1.0_dp * Cnt ) )
    CharSpeed = ParallelReduction( SumSpeed ) / ParallelParticles
  END IF
  CharSpeed = SQRT( CharSpeed ) 

  WRITE( Message,'(A,E12.6)') 'Characteristic Speed',CharSpeed
  CALL Info('CharacteristicSpeed',Message )

END FUNCTION CharacteristicSpeed



!---------------------------------------------------------
! Computes the characterestic time spent in an element
!---------------------------------------------------------
FUNCTION CharacteristicElementTime( Particles, No ) RESULT ( CharTime )
    
  TYPE(Particle_t) :: Particles
  REAL(KIND=dp) :: CharTime
  INTEGER, OPTIONAL :: No

  CALL Fatal('CharacteristicElementTime','Code the computation of time spent in element!')
  
END FUNCTION CharacteristicElementTime


!------------------------------------------------------------------------
! Initialize particle positions and velocities.
!-------------------------------------------------------------------------
SUBROUTINE InitializeParticles( Particles, InitParticles, AppendParticles ) 

  TYPE(Particle_t) :: Particles
  INTEGER, OPTIONAL :: InitParticles
  LOGICAL, OPTIONAL :: AppendParticles

  TYPE(ValueList_t), POINTER :: Params 
  TYPE(Variable_t), POINTER :: Var
  TYPE(Element_t), POINTER :: CurrentElement
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: Offset, NewParticles,LastParticle,NoElements
  INTEGER :: dim
  REAL(KIND=dp), POINTER :: Coords(:,:), Velo(:,:)
  CHARACTER(LEN=MAX_NAME_LEN) :: InitMethod
  INTEGER :: i,j,k,n,nonodes, InitStatus
  INTEGER, POINTER :: MaskPerm(:), InvPerm(:), NodeIndexes(:)
  LOGICAL :: GotIt, GotMask
  REAL(KIND=dp), POINTER :: InitialValues(:,:)
  REAL(KIND=dp) :: mass,boltz,temp,coeff,eps 
  REAL(KIND=dp) :: MinCoord(3), MaxCoord(3), Diam
  INTEGER :: nx,ny,nz,ix,iy,iz,ind
  LOGICAL, POINTER :: DoneParticle(:)
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
  

  IF( PRESENT( AppendParticles ) ) THEN
    Offset = Particles % NumberOfParticles
  ELSE
    Offset = 0
  END IF
  IF( PRESENT( InitParticles ) ) THEN
    NewParticles = InitParticles
  ELSE
    NewParticles = Particles % MaxNumberOfParticles
  END IF

  LastParticle = Offset + NewParticles
  Particles % NumberOfParticles = LastParticle


  Mesh => GetMesh()
  dim = Mesh % MeshDim

  CALL AllocateParticles( Particles, LastParticle, dim ) 
  Velo => Particles % Velocity
  Coords => Particles % Coordinate
  
  Params => GetSolverParams()

  !------------------------------------------------------------------------
  ! Position may be initialized using a given list, or using the nodal
  ! coordinates to initalize positions.
  !-------------------------------------------------------------------------
  
  InitMethod = ListGetString( Params,'Coordinate Initialization Method',gotIt ) 


  !------------------------------------------------------------------------
  ! The user may use a mask to initialize the particles only at a part of the 
  ! domain, or to utilize the ordeing of the permutation vector.
  !-------------------------------------------------------------------------  
  GotMask = .FALSE.
  VariableName = ListGetString( Params,'Initialization Mask Variable',GotIt )
  IF(GotIt) THEN
    Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
    IF( ASSOCIATED( Var ) ) THEN
      MaskPerm => Var % Perm
      IF( ASSOCIATED(MaskPerm) ) THEN
        IF( MAXVAL( MaskPerm ) == 0 ) THEN
          CALL Fatal('InitializeParticles','Size of mask variable is zero!')
        END IF

        GotMask = .TRUE.
        IF( InitMethod(1:5) == 'nodal') THEN
          nonodes = MAXVAL( MaskPerm ) 
          ALLOCATE( InvPerm(nonodes) )
          DO i=1,SIZE(MaskPerm)
            j = MaskPerm(i)
            IF( j > 0 ) InvPerm(j) = i
          END DO
        ELSE IF( InitMethod(1:9) == 'elemental') THEN
          j = 0
          ! first, calculate the number of active elements
          DO i=1,Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements
            CurrentElement => Mesh % Elements(i)
            NodeIndexes =>  CurrentElement % NodeIndexes
            n = CurrentElement % TYPE % NumberOfNodes
            IF( ALL( MaskPerm( NodeIndexes ) > 0 ) ) j = j + 1
            IF( i == Mesh % NumberOfBulkElements ) THEN
              IF( j > 0 ) EXIT
            END IF
          END DO
          noelements = j

          ! then create an inverse table for their indexes
          ALLOCATE( InvPerm(noelements) )
          j = 0
          DO i=1,Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements
            CurrentElement => Mesh % Elements(i)
            NodeIndexes => CurrentElement % NodeIndexes
            n = CurrentElement % TYPE % NumberOfNodes
            IF( ALL( MaskPerm( NodeIndexes ) > 0 ) ) THEN
              j = j + 1
              InvPerm(j) = i
            END IF
            IF( i == Mesh % NumberOfBulkElements ) THEN
              IF( j > 0 ) EXIT
            END IF
          END DO
        END IF
      ELSE
        CALL Fatal('InitializeParticles','Mask variable does not exist: '&
            //TRIM(VariableName) )          
      END IF
    END IF
  ELSE
    nonodes = Mesh % NumberOfNodes
    noelements = Mesh % NumberOfBulkElements
  END IF

  
  IF( InitMethod(1:3) == 'box') THEN
    Eps = GetCReal( Params,'Box Particle Boundary Thickness',GotIt)
    IF(.NOT. GotIt) eps = 1.0d-8
    
    MinCoord(1) = GetCReal( Params,'Min Coordinate 1',GotIt) 
    IF(.NOT. GotIt) MinCoord(1) = MINVAL( Mesh % Nodes % x ) + eps
    
    MaxCoord(1) = GetCReal( Params,'Max Coordinate 1',GotIt) 
    IF(.NOT. GotIt) MaxCoord(1) = MAXVAL( Mesh % Nodes % x ) - eps

    MinCoord(2) = GetCReal( Params,'Min Coordinate 2',GotIt) 
    IF(.NOT. GotIt) MinCoord(2) = MINVAL( Mesh % Nodes % y ) + eps
    
    MaxCoord(2) = GetCReal( Params,'Max Coordinate 2',GotIt) 
    IF(.NOT. GotIt) MaxCoord(2) = MAXVAL( Mesh % Nodes % y ) - eps
    
    IF( dim == 3 ) THEN
      MinCoord(3) = GetCReal( Params,'Min Coordinate 3',GotIt) 
      IF(.NOT. GotIt) MinCoord(3) = MINVAL( Mesh % Nodes % z ) + eps
      
      MaxCoord(3) = GetCReal( Params,'Max Coordinate 3',GotIt) 
      IF(.NOT. GotIt) MaxCoord(3) = MAXVAL( Mesh % Nodes % z ) - eps
    END IF
  END IF


  
  SELECT CASE ( InitMethod ) 
    

  CASE ('nodal ordered')
    PRINT *,'Initializing particles in nodes:',NewParticles,nonodes
    DO i=1,NewParticles
      k = Offset + i
      j = (nonodes-1)*(i-1)/(NewParticles-1)+1
      j = MODULO( i * NewParticles -1 , nonodes ) + 1
      IF( GotMask ) j = InvPerm(j)
      Coords(k,1) = Mesh % Nodes % x(j)
      Coords(k,2) = Mesh % Nodes % y(j)
      IF( dim == 3 ) Coords(k,3) = Mesh % Nodes % z(j)
    END DO

  CASE ('elemental ordered')
    PRINT *,'Initializing particles in elements:',NewParticles,noelements
    DO i=1,NewParticles
      k = Offset + i
      j = (NoElements-1)*(i-1)/(NewParticles-1)+1
      IF( GotMask ) j = InvPerm(j)
      CurrentElement => Mesh % Elements(j)
      NodeIndexes =>  CurrentElement % NodeIndexes
      n = CurrentElement % TYPE % NumberOfNodes
      Coords(k,1) = SUM( Mesh % Nodes % x(NodeIndexes ) ) / n
      Coords(k,2) = SUM( Mesh % Nodes % y(NodeIndexes ) ) / n
      IF( dim == 3 ) Coords(k,3) = SUM( Mesh % Nodes % z(NodeIndexes ) ) / n
      Particles % ElementIndex(i) = j
    END DO
    PRINT *,'done inint'

  CASE ('box random')

    DO i=1,NewParticles
      k = Offset + i      
      Coords(k,1) = MinCoord(1) + (MaxCoord(1)-MinCoord(1)) * EvenRandom()
      Coords(k,2) = MinCoord(2) + (MaxCoord(2)-MinCoord(2)) * EvenRandom()
      IF( dim == 3 ) THEN
        Coords(k,3) = MinCoord(3) + (MaxCoord(3)-MinCoord(3)) * EvenRandom()
      END IF
    END DO

  CASE ('box random cubic')

    Diam = GetCReal( Params,'Box Particle Unit Cell',GotIt)
    IF(.NOT. GotIt ) THEN
      Diam = 2 * GetCReal( Params,'Particle Radius',GotIt)
    END IF
    IF(.NOT. GotIt ) THEN
      CALL Fatal('InitializeParticles','Size of unit cell not given')
    END IF

    nx = ( MaxCoord(1) - MinCoord(1) ) / Diam
    ny = ( MaxCoord(2) - MinCoord(2) ) / Diam
    IF( dim == 3 ) THEN
      nz = ( MaxCoord(3) - MinCoord(3) ) / Diam
    ELSE
      nz = 1
    END IF

    IF( nx * ny * nz < NewParticles ) THEN
      PRINT *,'Max places:',nx*ny*nz
      CALL Fatal('InitializeParticles','More particles than places in unit cell')
    END IF

    ALLOCATE( DoneParticle(nx*ny*nz) )
    DoneParticle = .FALSE.

    i = 0
    DO WHILE (.TRUE.) 
      ix = NINT( nx * EvenRandom() + 0.5 )
      iy = NINT( ny * EvenRandom() + 0.5 )
      IF( dim == 3 ) THEN
        iz = NINT( nz * EvenRandom() + 0.5 )
      ELSE
        iz = 1
      END IF
      ind = nx*ny*(nz-1) + nx*(iy-1) + ix
      IF( DoneParticle(ind) ) CYCLE
      
      i = i + 1
      DoneParticle(ind) = .TRUE.

      k = Offset + i      
      Coords(k,1) = MinCoord(1) + ( 1.0_dp*ix - 0.5) * Diam 
      Coords(k,2) = MinCoord(2) + ( 1.0_dp*iy - 0.5) * Diam 
      IF( dim == 3 ) THEN
        Coords(k,3) = MinCoord(3) + ( 1.0_dp*iz - 0.5) * Diam 
      END IF
    END DO
    DEALLOCATE( DoneParticle ) 

    
  CASE DEFAULT 
    
    InitialValues => ListGetConstRealArray(Params,'Initial Coordinates',gotIt)    
      IF(gotIt) THEN
        IF( SIZE(InitialValues,2) /= dim ) THEN
          CALL Fatal('ParticleTracker','Wrong dimension in Initial Coordinates')
        ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
          DO i=1,NewParticles
            k = offset + i
            Coords(k,1:dim) = InitialValues(1,1:dim)
          END DO
        ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
          CALL Fatal('ParticleTracker','Wrong number of particles in Initial Coordinates')
        ELSE
          DO i=1,NewParticles
            k = Offset + i
            Coords(k,1:dim) = InitialValues(i,1:DIM)
          END DO
        END IF
      ELSE
        CALL Fatal('ParticleTracker','Initial Coordinates not given')
      END IF
    END SELECT

    IF( GotMask ) DEALLOCATE( InvPerm ) 

    !------------------------------------------------------------------------
    ! Velocities may be initialized using a given list, or obtaining them
    ! from random even or maxwell boltzmann distributions. These are additive to 
    ! allow bulk velocities with the random one.
    !-------------------------------------------------------------------------

    InitialValues => ListGetConstRealArray(Params,'Initial Velocities',gotIt)
    IF(gotIt) THEN
      IF( SIZE(InitialValues,2) /= DIM ) THEN
        CALL Fatal('ParticleTracker','Wrong dimension in Initial Velocities')
      ELSE IF( SIZE(InitialValues,1) == 1 ) THEN
        DO i=1,NewParticles
          k = Offset + i
          Velo(k,1:dim) = InitialValues(1,1:DIM)
        END DO
      ELSE IF( SIZE(InitialValues,1) /= NewParticles ) THEN
        CALL Fatal('ParticleTracker','Wrong number of particles in Initial Velocities')
      ELSE
        DO i=1,NewParticles
          k = Offset + i
          Velo(k,1:dim) = InitialValues(i,1:DIM)
        END DO
      END IF
    END IF


    InitMethod = ListGetString( Params,'Velocity Initialization Method',gotIt ) 

    SELECT CASE ( InitMethod ) 
      
    CASE ('thermal random')  
      
      mass = ListGetConstReal( Params,'Particle Mass')
      temp = ListGetConstReal( Params,'Particle Temperature')
      boltz = ListGetConstReal( CurrentModel % Constants,'Boltzmann constant')
      coeff = SQRT(boltz * temp / mass )

      DO i=1,NewParticles
        k = Offset + i
        Velo(k,1) = Velo(k,1) + coeff * NormalRandom()
        Velo(k,2) = Velo(k,2) + coeff * NormalRandom()
        IF( dim == 3 ) Velo(k,3) = Velo(k,3) + coeff * NormalRandom()
      END DO

    CASE ('even random')  

      coeff = ListGetConstReal( Params,'Random Velocity Amplitude')

      DO i=1,NewParticles
        k = Offset + i
        Velo(k,1) = Velo(k,1) + coeff * (2*EvenRandom()-1)
        Velo(k,2) = Velo(k,2) + coeff * (2*EvenRandom()-1)
        IF( dim == 3 ) Velo(k,3) = Velo(k,3) + coeff * (2*EvenRandom()-1)
      END DO

    CASE DEFAULT

    END SELECT



    !------------------------------------------------------
    ! The initial status of particles is different if using 
    ! gradual release strategy. 
    !-------------------------------------------------------
    IF( ListCheckPresent( Params,'Particle Release Set') .OR. &
      ListCheckPresent( Params,'Particle Release Fraction') ) THEN
      InitStatus = PARTICLE_WAITING
    ELSE
      InitStatus = PARTICLE_INITIATED
    END IF
    
    DO i=1,NewParticles
      k = Offset + i
      Particles % Status(k) = InitStatus
    END DO


  END SUBROUTINE InitializeParticles

 

!---------------------------------------------------------------------------
! This subroutine finds the possible intersection between elementfaces 
! and a line segment.
!---------------------------------------------------------------------------
  SUBROUTINE SegmentElementIntersection(Mesh,BulkElement,&
      Rinit,Rfin,MinLambda,FaceElement)
!---------------------------------------------------------------------------
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER   :: BulkElement
  REAL(KIND=dp) :: Rinit(3), Rfin(3), MinLambda
  TYPE(Element_t), POINTER :: FaceElement

  TYPE(Element_t), POINTER   :: BoundaryElement
  TYPE(Nodes_t), SAVE :: BoundaryNodes
  REAL(KIND=dp) :: Lambda, Epsilon
  INTEGER :: i,j,n
  INTEGER, POINTER :: NodeIndexes(:)
  LOGICAL :: AtBoundary, Visited = .FALSE.


  SAVE  Visited

  
  MinLambda = HUGE( MinLambda ) 
  Epsilon = TINY( Lambda ) 
  FaceElement => Null()

  IF( BulkElement % TYPE % DIMENSION == 3 ) THEN
    DO i=1, BulkElement % TYPE % NumberOfFaces  
      j = BulkElement % FaceIndexes(i)
      BoundaryElement => Mesh % Faces( j )
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)

      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 
      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  ELSE
    DO i=1, BulkElement % TYPE % NumberOfEdges  
      j = BulkElement % EdgeIndexes(i)
      BoundaryElement => Mesh % Edges(j)
      CALL GetElementNodes(BoundaryNodes,BoundaryElement)
     
      Lambda = LineFaceIntersection(BoundaryElement,BoundaryNodes,&
          Rinit,Rfin) 

      IF( Lambda > Epsilon ) THEN
        IF( Lambda < MinLambda ) THEN
          MinLambda = Lambda
          FaceElement => BoundaryElement
        END IF
      ELSE IF( Lambda > -Epsilon ) THEN
        AtBoundary = .TRUE.
      END IF
    END DO
  END IF

END SUBROUTINE SegmentElementIntersection






!------------------------------------------------------------------------
! Find the particle in the mesh using actree based search. 
! This could be preferred in the initial finding of the correct elements.
! The major downside of the method is that there is no controlled face
! detection needed for wall interaction, for example.
!------------------------------------------------------------------------
SUBROUTINE LocateParticleInMeshOctree( ElementIndex, GlobalCoords, &
    LocalCoords, ParticleStatus )
  
  INTEGER :: ElementIndex
  REAL(KIND=dp) :: GlobalCoords(3),LocalCoords(3)
  INTEGER :: ParticleStatus

  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  LOGICAL :: Hit, Stat
  INTEGER :: i,j,k,n
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element
  TYPE(Quadrant_t), POINTER, SAVE :: RootQuadrant =>Null(), LeafQuadrant
  REAL(kind=dp) :: BoundingBox(6), eps2, eps1
  

  Mesh => GetMesh()
  ParticleStatus = PARTICLE_LOST

  ! Check that the previous hit is not hit even now
  !-------------------------------------------------
  IF( ElementIndex > 0 ) THEN
    Element => Mesh % Elements( ElementIndex ) 
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)
    
    IF ( PointInElement( Element, ElementNodes, &
        GlobalCoords, LocalCoords ) ) THEN
      ParticleStatus = PARTICLE_HIT
      RETURN
    END IF
  END IF

  !-----------------------------------------------------------
  ! Find the right element using an octree search
  ! This is optimal when the particles are searched only once.
  !-----------------------------------------------------------
  IF ( .NOT.ASSOCIATED(Mesh % RootQuadrant) ) THEN
    BoundingBox(1) = MINVAL( Mesh % Nodes % x )
    BoundingBox(2) = MINVAL( Mesh % Nodes % y )
    BoundingBox(3) = MINVAL( Mesh % Nodes % z )
    BoundingBox(4) = MAXVAL( Mesh % Nodes % x )
    BoundingBox(5) = MAXVAL( Mesh % Nodes % y )
    BoundingBox(6) = MAXVAL( Mesh % Nodes % z )
    
    eps1 = 1.0e-3
    eps2 = eps1 * MAXVAL( BoundingBox(4:6) - BoundingBox(1:3) )
    BoundingBox(1:3) = BoundingBox(1:3) - eps2
    BoundingBox(4:6) = BoundingBox(4:6) + eps2
    
    CALL BuildQuadrantTree( Mesh,BoundingBox,Mesh % RootQuadrant)
  END IF
  RootQuadrant => Mesh % RootQuadrant
  
  Element => Null()
  CALL FindLeafElements(GlobalCoords, Mesh % MeshDim, RootQuadrant, LeafQuadrant)
  IF ( ASSOCIATED(LeafQuadrant) ) THEN
    DO i = 1, LeafQuadrant % NElemsInQuadrant
      j = LeafQuadrant % Elements(i)
      Element => Mesh % Elements(j)
      
      n = GetElementNOFNodes( Element )
      CALL GetElementNodes( ElementNodes, Element)
      
      IF ( PointInElement( Element, ElementNodes, GlobalCoords, LocalCoords ) ) THEN
        ElementIndex = j
        ParticleStatus = PARTICLE_HIT
        RETURN
      END IF
    END DO
  END IF
  
END SUBROUTINE LocateParticleInMeshOctree


!------------------------------------------------------------------------
! Locate the particle using controlled marching from element to element.
! The crossing point between given trajectory and all face elements is 
! computed. The one that is passed at first is associated to the next 
! bulk element.
!-------------------------------------------------------------------------
SUBROUTINE LocateParticleInMeshMarch( ElementIndex, Rinit, Rfin, Init, &
    ParticleStatus, StopFaceIndex, Lambda )
  
  INTEGER :: ElementIndex
  REAL(KIND=dp) :: Rinit(3), Rfin(3)
  LOGICAL :: Init
  REAL(KIND=dp), OPTIONAL :: Lambda
  INTEGER :: ParticleStatus
  INTEGER, OPTIONAL :: StopFaceIndex

  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  REAL(KIND=dp) :: Rtmp(3), MinLambda, eps 
  LOGICAL :: Hit, DoInit, Stat, StopAtFace, AtWall, Visited = .FALSE.,&
      Debug,UseCenter
  INTEGER :: i,j,k,n,FaceIndex,MaxTrials
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element, FaceElement, LeftElement, RightElement, &
      NextElement
  
  INTEGER, POINTER :: Neighbours(:)
  INTEGER :: NextPartition
  LOGICAL, POINTER :: FaceInterface(:)

  SAVE :: Mesh, StopAtFace, Debug, MaxTrials

  Mesh => GetMesh()

  IF( .NOT. Visited ) THEN
    Params => GetSolverParams()
    StopAtFace = ListGetLogical( Params,'Particle Stop At Face',Stat)
    MaxTrials = ListGetInteger( Params,'Particle Search Max Trials',Stat)
    IF(.NOT. Stat) MaxTrials = Mesh % NumberOfBulkElements

    CALL FindMeshEdges( Mesh, .FALSE.)
    IF ( ParEnv % PEs>1 ) THEN
      CALL SParEdgeNumbering(Mesh)
      CALL SParFaceNumbering(Mesh)
    END IF

    Debug = .FALSE.
    Visited = .TRUE.
  END IF


  ParticleStatus = PARTICLE_LOST
  IF( PRESENT (StopFaceIndex) ) StopFaceIndex=0

  IF( PRESENT( Lambda ) ) Lambda = 1.0_dp
  
  !--------------------------------------------------------------------
  ! This is a recursive algorithm that checks the intersections 
  ! of line segments and points until correct element is found.
  ! This is optimal when the stepsize is small and there are many steps.
  !--------------------------------------------------------------------
  DoInit = Init
  IF( ElementIndex == 0 ) THEN
    DoInit = .TRUE.
    ElementIndex = 1
    UseCenter = .TRUE.
  ELSE	
    UseCenter = .NOT. StopAtFace
  END IF
  
  Element => Mesh % Elements( ElementIndex ) 
  eps = 1.0d-10
  
  DO i=1,MaxTrials
    n = GetElementNOFNOdes(Element)
    CALL GetElementNodes(ElementNodes,Element)
    
    ! Use the previous element center if the true path is of no importance
    !---------------------------------------------------------------------	
    IF( UseCenter ) THEN
      Rtmp(1) = SUM( ElementNodes % x(1:n) ) / n
      Rtmp(2) = SUM( ElementNodes % y(1:n) ) / n
      Rtmp(3) = SUM( ElementNodes % z(1:n) ) / n
    ELSE
      Rtmp = Rinit
    END IF
    
    CALL SegmentElementIntersection(Mesh,Element,&
        Rtmp,Rfin,MinLambda,FaceElement )
    
    IF( .NOT. ASSOCIATED( FaceElement ) ) THEN
      ! The likely cause for unsuccessful operation is that the 
      ! initial node and target node are the same
      IF( SUM ( ( Rtmp - Rfin )**2 ) < eps**2 ) THEN
        ParticleStatus = PARTICLE_HIT
        EXIT
      ELSE
        CALL Warn('LocateParticleInMesh','No intersection found?')
        PRINT *,'Rtmp',Rtmp
        PRINT *,'Rfin',Rfin
        EXIT
      END IF
    ELSE IF( MinLambda > 1.0 - eps ) THEN
      ParticleStatus = PARTICLE_HIT
      Rtmp = Rfin
      EXIT
    ELSE 
      LeftElement  => FaceElement % BoundaryInfo % Left
      RightElement => FaceElement % BoundaryInfo % Right
      
      IF( ASSOCIATED( LeftElement) .AND. ASSOCIATED(RightElement)) THEN
        IF( ASSOCIATED(Element, LeftElement)) THEN
          NextElement => RightElement
        ELSE
          NextElement => LeftElement
        END IF
        
        IF( StopAtFace .AND. .NOT. DoInit ) ParticleStatus = PARTICLE_FACEBOUNDARY
      ELSE
        ParticleStatus = PARTICLE_WALLBOUNDARY
      END IF
      
      ! There are different reasons why the particle is only integrated until the face
      IF( ParticleStatus == PARTICLE_WALLBOUNDARY .OR. &
          ParticleStatus == PARTICLE_FACEBOUNDARY ) THEN
        IF( PRESENT( Lambda ) ) Lambda = MinLambda
        Rtmp = Rinit + MinLambda * (Rfin - Rinit) 
        StopFaceIndex = FaceElement % ElementIndex
        EXIT                      
      END IF
    END IF
    
    ! continue the search to new elements
    Element => NextElement
  END DO
  ElementIndex = Element % ElementIndex
  
END SUBROUTINE LocateParticleInMeshMarch



!------------------------------------------------------------------------
! Locate all the new elements of the particles
!-------------------------------------------------------------------------
SUBROUTINE LocateParticles( Particles, PartitionChangesOnly )

  TYPE(Particle_t) :: Particles
  LOGICAL, OPTIONAL :: PartitionChangesOnly

  INTEGER :: Status, ElementIndex, No, NoParticles, dim
  REAL(KIND=dp) :: Rinit(3), Rfin(3)
  LOGICAL :: InitLocation
  INTEGER :: FaceIndex
  REAL(KIND=dp) :: Lambda

  
  NoParticles = Particles % NumberOfParticles
  dim = Particles % dim
  
  DO No = 1, NoParticles
    Status = Particles % Status( No )
    IF( Status == PARTICLE_LOST ) CYCLE
    IF( Status < PARTICLE_INITIATED ) CYCLE

    IF ( PRESENT(PartitionChangesOnly) ) THEN
      IF ( PartitionChangesOnly .AND. Status /= PARTICLE_PARTBOUNDARY ) CYCLE
    END IF
    
    ElementIndex = Particles % ElementIndex( No )
    
    ! We only need to find the right element, path is not of importance
    InitLocation = ( Status < PARTICLE_LOCATED ) 
    Rfin(1:dim) = GetParticleCoord( Particles, No, 0 )
    ElementIndex = GetParticleElement( Particles, No )
    
    ! Note that if we want proper collisions with the boundary done within this
    ! routine the initial coordinates should really not be rfin!!

    CALL LocateParticleInMeshMarch(ElementIndex, Rfin, Rfin, InitLocation, &
        Status, FaceIndex, Lambda )

    Particles % FaceIndex(No) = FaceIndex
    Particles % Status(No) = Status
    Particles % ElementIndex(No) = ElementIndex
  END DO

END SUBROUTINE LocateParticles



!--------------------------------------------------------------------------
! Given the element & global coordinates returns the local coordinates.
! The idea of this routine is to transparently block the local coordinate
! search from the user by directly giving the basis function values related
! to a global coordinate.
!--------------------------------------------------------------------------
FUNCTION GlobalElementInfo( CurrentElement, GlobalCoord, &
    SqrtElementMetric, Basis, dBasisdx ) RESULT ( stat )
  
  TYPE(Element_t), POINTER :: CurrentElement
  REAL(KIND=dp) :: GlobalCoord(:), SqrtElementMetric
  REAL(KIND=dp) :: Basis(:)
  REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:)
  LOGICAL :: Stat

  TYPE(Nodes_t) :: ElementNodes
  REAL(KIND=dp) :: LocalCoord(3),u,v,w
  INTEGER :: n

  SAVE ElementNodes

  n = CurrentElement % TYPE % NumberOfNodes
  CALL GetElementNodes(ElementNodes,CurrentElement)
  
  Stat = PointInElement( CurrentElement, ElementNodes, &
      GlobalCoord, LocalCoord ) 
  IF( .NOT. Stat ) THEN
    CALL Warn('GlobalElementInfo','Should have found the node!')
    RETURN
  END IF
  
  u = LocalCoord(1)
  v = LocalCoord(2)
  w = LocalCoord(3)
    
  stat = ElementInfo( CurrentElement, ElementNodes, U, V, W, SqrtElementMetric, &
      Basis, dBasisdx )

END FUNCTION GlobalElementInfo



!-------------------------------------------------------------------------
! The routine returns velocity and optionally a gradient of velocity.
! These kind of functions are needed repeated and therefore to reduced the 
! size of individual solvers it has been hard coded here. 
! This may seem stupid but probably there are just a few fields where this
! has to be done...
!--------------------------------------------------------------------------

SUBROUTINE GetVelocityInMesh(CurrentElement, Basis, Velo, dBasisdx, GradVelo )
  
  TYPE(Element_t) :: CurrentElement
  REAL(KIND=dp) :: Basis(:), Velo(:) 
  REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:), GradVelo(:,:)

  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Variable_t), POINTER :: Var
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
  INTEGER :: VeloFieldDofs
  INTEGER, POINTER :: VeloFieldPerm(:)
  REAL(KIND=dp), POINTER :: VeloField(:)
  INTEGER :: i,j,n,dim
  LOGICAL :: GotIt,GotVeloField
  LOGICAL :: Visited


  SAVE :: Visited, Dim,GotVeloField, VeloField, VeloFieldPerm, VeloFieldDofs

  IF(.NOT. Visited ) THEN
    GotVeloField = .FALSE.
    Params => GetSolverParams()
    VariableName = ListGetString( Params,'Velocity Field Name',GotIt )
    IF(GotIt) THEN
      Mesh => GetMesh()
      Dim = Mesh % MeshDim
      Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
      GotVeloField = ASSOCIATED( Var )
      IF ( GotVeloField )  THEN
        VeloField => Var % Values
        VeloFieldPerm => Var % Perm
        VeloFieldDofs = Var % DOFs
      ELSE
        CALL Warn('GetVelocityInMesh','Velocity field variable does not exist: '//TRIM(VariableName))
      END IF
    END IF
    Visited = .TRUE.
  END IF

  Velo = 0.0_dp
  IF( PRESENT( GradVelo ) ) GradVelo = 0.0_dp
  IF(.NOT. GotVeloField ) RETURN

  NodeIndexes => CurrentElement % NodeIndexes
  IF( .NOT. ALL ( VeloFieldPerm( NodeIndexes) > 0 )) RETURN

  n = CurrentElement % TYPE % NumberOfNodes
  DO i=1,dim
    Velo(i) = SUM( Basis(1:n) * &
        VeloField( VeloFieldDofs*( VeloFieldPerm( NodeIndexes )-1)+i) )
  END DO
  IF( PRESENT( GradVelo ) ) THEN
    DO i=1,dim
      DO j=1,dim
        GradVelo(i,j) = SUM( dBasisdx(1:n,j) * &
            VeloField( VeloFieldDofs*( VeloFieldPerm( NodeIndexes )-1)+i) )
      END DO
    END DO
  END IF


END SUBROUTINE GetVelocityInMesh

!-------------------------------------------------------------------------
! The routine returns velocity and optionally a gradient of velocity.
! These kind of functions are needed repeated and therefore to reduced the 
! size of individual solvers it has been hard coded here. 
! This may seem stupid but probably there are just a few fields where this
! has to be done...
!--------------------------------------------------------------------------

SUBROUTINE GetPotentialInMesh(CurrentElement, Basis, Pot, dBasisdx, GradPot )
  
  TYPE(Element_t) :: CurrentElement
  REAL(KIND=dp) :: Basis(:), Pot 
  REAL(KIND=dp), OPTIONAL :: dBasisdx(:,:), GradPot(:)

  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Variable_t), POINTER :: Var
  CHARACTER(LEN=MAX_NAME_LEN) :: VariableName
  INTEGER, POINTER :: PotFieldPerm(:)
  REAL(KIND=dp), POINTER :: PotField(:)
  INTEGER :: i,j,n,dim
  LOGICAL :: GotIt,GotPotField
  LOGICAL :: Visited


  SAVE :: Visited, Mesh, Dim, GotPotField, PotField, PotFieldPerm

  IF(.NOT. Visited ) THEN
    GotPotField = .FALSE.
    Params => GetSolverParams()
    VariableName = ListGetString( Params,'Potential Field Name',GotIt )
    IF(GotIt) THEN
      Mesh => GetMesh()
      Dim = Mesh % MeshDim
      Var => VariableGet( Mesh % Variables, TRIM(VariableName) )
      GotPotField = ASSOCIATED( Var )
      IF ( GotPotField )  THEN
        PotField => Var % Values
        PotFieldPerm => Var % Perm
      ELSE
        CALL Warn('GetPotentialInMesh','Potential field variable does not exist: '//TRIM(VariableName))
      END IF
    END IF
    Visited = .TRUE.
  END IF

  Pot = 0.0_dp
  IF( PRESENT( GradPot ) ) GradPot = 0.0_dp
  IF(.NOT. GotPotField ) RETURN

  NodeIndexes => CurrentElement % NodeIndexes
  IF( .NOT. ALL ( PotFieldPerm( NodeIndexes) > 0 )) RETURN

  n = CurrentElement % TYPE % NumberOfNodes
  Pot = SUM( Basis(1:n) * PotField( PotFieldPerm( NodeIndexes ) ) )

  IF( PRESENT( GradPot ) ) THEN
    DO i=1,dim
      GradPot(i) = SUM( dBasisdx(1:n,i) * &
        PotField( PotFieldPerm( NodeIndexes )-1+i) ) 
    END DO
  END IF

END SUBROUTINE GetPotentialInMesh



!-------------------------------------------------------------
! This subroutine may be used to enquire position dependent data,
! for example, by using the GetReal() function and evaluating the
! result at the coordinate point. Note this this is bound to
! be expensive compared to the above strategies.
!-------------------------------------------------------------
FUNCTION GetMaterialPropertyInMesh(List, Name, GlobalCoord, CurrentElement, &
    Found ) RESULT ( ValueAtPoint ) 
  
  TYPE(ValueList_t), POINTER :: List
  CHARACTER(LEN=*)  :: Name
  REAL(KIND=dp) :: GlobalCoord(3)
  TYPE(Element_t), POINTER :: CurrentElement
  LOGICAL, OPTIONAL :: Found
  REAL(KIND=dp) :: ValueAtPoint
  
  REAL(KIND=dp), POINTER :: Basis(:), Values(:)
  INTEGER, POINTER :: NodeIndexes(:)
  REAL(KIND=dp) :: SqrtElementMetric
  TYPE(Mesh_t), POINTER :: Mesh
  LOGICAL :: Visited = .FALSE., Stat
  INTEGER :: n
  TYPE(ValueList_t), POINTER :: Material


  SAVE Visited, Basis, Values

  IF(.NOT. Visited ) THEN
    Mesh => GetMesh()
    n = Mesh % MaxElementNodes
    ALLOCATE( Basis(n), Values(n) )
    Visited = .TRUE.
  END IF

  IF(PRESENT(Found)) Found = .FALSE.
  ValueAtPoint = 0.0_dp

  ! First check that there is material
  Material => GetMaterial(  CurrentElement, Stat )
  IF(.NOT. Stat ) RETURN

  ! Then check that the keyword is present
  NodeIndexes => CurrentElement % NodeIndexes
  n = CurrentElement % TYPE % NumberOfNodes
  CurrentModel % CurrentElement => CurrentElement
  Values(1:n) = ListGetReal( Material, Name, n, NodeIndexes, Stat )
  IF(.NOT. Stat ) RETURN
  
  ! Then find the local basis functions
  Stat = GlobalElementInfo( CurrentElement, GlobalCoord, &
      SqrtElementMetric, Basis )
  IF( .NOT. Stat ) RETURN
  
  ValueAtPoint = SUM( Basis(1:n) * Values(1:n) )
  IF(PRESENT(Found)) Found = .TRUE.

END FUNCTION GetMaterialPropertyInMesh


!-------------------------------------------------------------
! This routine cretates the nearest neighbours for all nodes
! The particle-particle connections may then be found by going
! through all the nodes of elements
!-------------------------------------------------------------
SUBROUTINE CreateNeighbourList( Particles ) 

  TYPE(Particle_t) :: Particles
  
  INTEGER :: ElementIndex, dim
  REAL(KIND=dp) :: Coord(3), dist, mindist
  TYPE(ValueList_t), POINTER :: Params
  TYPE(Mesh_t), POINTER :: Mesh
  INTEGER :: i,j,k,n,node
  TYPE(Nodes_t), SAVE :: ElementNodes
  INTEGER, POINTER :: NodeIndexes(:)
  TYPE(Element_t), POINTER :: Element
  INTEGER :: NoNodes, NoParticles, MaxClosest  

  Mesh => GetMesh()
  NoNodes = Mesh % NumberOfNodes

  NoParticles = Particles % NumberOfParticles
  IF( .NOT. Particles % NeighbourTable ) THEN
    ALLOCATE( Particles % NoClosestParticle( NoNodes ) ) 
    ALLOCATE( Particles % CumClosestParticle( NoNodes+1 ) ) 
    Particles % NeighbourTable = .TRUE.
  END IF

  IF ( ASSOCIATED(Particles % ClosestNode) ) &
   DEALLOCATE(Particles % ClosestNode )
  ALLOCATE( Particles % ClosestNode(Particles % MaxNumberOfParticles) )
  
  dim = Particles % dim 

  ! First find the closest node to each particle
  !-----------------------------------------------
  Particles % ClosestNode = 0
  Particles % NoClosestParticle = 0
  DO i=1,NoParticles 
    IF( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    ElementIndex = Particles % ElementIndex(i)
    Element => Mesh % Elements( ElementIndex )
    n = GetElementNOFNodes(Element)
    CALL GetElementNodes(ElementNodes,Element)    
    Coord(1:dim) = Particles % Coordinate(i,1:dim)

    ! Find the minimum distance node (using squares is faster)
    mindist = HUGE( mindist ) 
    DO j=1,n
      dist = ( ElementNodes % x(j) - Coord(1) )**2
      dist = dist +  ( ElementNodes % y(j) - Coord(2) )**2
      IF( dim == 3 ) THEN
        dist = dist +  ( ElementNodes % z(j) - Coord(3) )**2
      END IF
      IF( dist < mindist ) THEN
        mindist = dist 
        k = j
      END IF
    END DO    
    node = Element % NodeIndexes(k)
    Particles % ClosestNode(i) = node
    Particles % NoClosestParticle(node) = Particles % NoClosestParticle(node) + 1
  END DO

  CALL ExchangeNeighbourParticles(Particles)
  NoParticles = Particles % NumberOfParticles

  ! Count the cumulative number of closest particles for given node
  !-----------------------------------------------------------------
  Particles % CumClosestParticle(1) = 1
  MaxClosest = 0
  DO i=1,NoNodes
    j = Particles % NoClosestParticle(i)
    MaxClosest = MAX( MaxClosest, j )
    Particles % CumClosestParticle(i+1) = Particles % CumClosestParticle(i)+j
  END DO
  Particles % MaxClosestParticles = MaxClosest

  ! And finally, add the closest neigbours to the table 
  !----------------------------------------------------------------
  IF ( ASSOCIATED(Particles % ClosestParticle) ) &
    DEALLOCATE(Particles % ClosestParticle )
  ALLOCATE( Particles % ClosestParticle(Particles % CumClosestParticle(NoNodes+1)) )

  Particles % NoClosestParticle = 0
  Particles % ClosestParticle = 0
  DO i=1,NoParticles     
    IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE
    node = Particles % ClosestNode(i) 
    j = Particles % NoClosestParticle(node) 
    k = Particles % CumClosestParticle(node)
    Particles % ClosestParticle(k+j) = i
    Particles % NoClosestParticle(node) = j + 1
  END DO
END SUBROUTINE CreateNeighbourList


SUBROUTINE ExchangeNeighbourParticles(Particles)
  TYPE(Particle_t) :: Particles
!---------------------------------------------------------
  INTEGER i,j,k,l,m,n,dim,NoPartitions, node, &
      Proc, ierr, status(MPI_STATUS_SIZE), n_part, nReceived

  INTEGER, ALLOCATABLE :: Perm(:), Indexes(:), Neigh(:), &
           Recv_parts(:), Requests(:)
  TYPE(Mesh_t), POINTER :: Mesh

  TYPE(ParallelInfo_t), POINTER :: PI

  INTEGER, POINTER :: Neighbours(:), Closest(:)

  TYPE ExchgInfo_t
    INTEGER :: n=0
    INTEGER, POINTER :: Gindex(:), Particles(:)
  END TYPE ExchgInfo_t

  REAL(KIND=dp), ALLOCATABLE :: Buf(:)
  TYPE(ExchgInfo_t), POINTER :: Info(:)
!--------------------------------------------------------

  nReceived = 0
  IF( ParEnv% PEs == 1 ) RETURN

  Mesh => GetMesh()
  dim = Particles % dim

  ! Count & Identify neighbouring partitions:
  ! -----------------------------------------
  NoPartitions = COUNT(ParEnv % IsNeighbour)
  ALLOCATE(Perm(ParEnv % PEs), Neigh(NoPartitions) )
  Perm = 0

  NoPartitions=0
  DO i=1,ParEnv % PEs
    IF ( i-1==ParEnv % Mype ) CYCLE
    IF ( ParEnv % IsNeighbour(i) ) THEN
      NoPartitions=NoPartitions+1
      Perm(i) = NoPartitions
      Neigh(NoPartitions) = i-1
    END IF
  END DO

  ! Receive interface sizes:
  !--------------------------
  ALLOCATE( Recv_Parts(NoPartitions), Requests(NoPartitions) )
  DO i=1,NoPartitions
    CALL MPI_iRECV( Recv_Parts(i),1, MPI_INTEGER, Neigh(i), &
         2000, MPI_COMM_WORLD, requests(i), ierr )
  END DO

  PI => Mesh % ParallelInfo

  ! Exchange interface particles
  ! ----------------------------
  ALLOCATE(Info(NoPartitions))
  DO i=1,NoPartitions
    Info(i) % n = 0
  END DO

  DO i=1,Particles % NumberOfParticles
    IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    node = Particles % ClosestNode(i)
    IF ( .NOT. PI % Interface(node) ) CYCLE
    Neighbours => PI % NeighbourList(node) % Neighbours
    DO j=1,SIZE(Neighbours)
      proc = Neighbours(j)
      IF ( Proc==Parenv % mype ) CYCLE
      proc = Perm(proc+1)
      IF ( Proc<=0 ) CYCLE
      Info(proc) % n = Info(proc) % n+1
    END DO
  END DO

  DO i=1,NoPartitions
    CALL MPI_BSEND( Info(i) % n, 1, MPI_INTEGER, Neigh(i), &
             2000, MPI_COMM_WORLD, ierr )
  END DO

  !
  ! Collect particles to be sent to neighbours:
  ! -------------------------------------------
  DO i=1,NoPartitions
    IF ( Info(i) % n==0 ) CYCLE
    ALLOCATE( Info(i) % Gindex(Info(i) % n), Info(i) % Particles(Info(i) % n) )
    Info(i) % n = 0
  END DO

  DO i=1,Particles % NumberOfParticles
    IF ( Particles % Status(i) == PARTICLE_LOST ) CYCLE

    node = Particles % ClosestNode(i)
    IF ( .NOT. PI % Interface(node) ) CYCLE
    Neighbours => PI % NeighbourList(node) % Neighbours
    DO j=1,SIZE(Neighbours)
      proc = Neighbours(j)
      IF ( Proc==Parenv % mype ) CYCLE
      proc = Perm(proc+1)
      IF ( Proc<=0 ) CYCLE
      Info(proc) % n = Info(proc) % n+1
      Info(proc) % Particles(Info(proc) % n) = i
      Info(proc) % Gindex(Info(proc) % n) = PI % GlobalDOFs(node)
    END DO
  END DO

  n = 0
  DO i=1,NoPartitions
    n = n + Info(i) % n
  END DO
  n = 2*(n+2*(2*n*dim+n) + MPI_BSEND_OVERHEAD*2*NoPartitions)
  CALL CheckBuffer(n)

  ! Send particles:
  ! ---------------
  DO j=1,NoPartitions
    n = Info(j) % n
    IF ( n<=0 ) CYCLE

    CALL MPI_BSEND( Info(j) % Gindex, n, MPI_INTEGER, &
        Neigh(j), 2001, MPI_COMM_WORLD, ierr )

    ALLOCATE(Buf(2*n*dim+n))
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Buf(m) = Particles % Coordinate(Info(j) % Particles(l),k)
      END DO
    END DO
    DO l=1,n
      m = m + 1
      Buf(m) = Particles % Dt(Info(j) % Particles(l))
    END DO
    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
            Buf(m) = Particles % Velocity(Info(j) % Particles(l),k)
        END DO
      END DO
    END IF
    CALL MPI_BSEND( Buf, m, MPI_DOUBLE_PRECISION, &
        Neigh(j), 2002, MPI_COMM_WORLD, ierr )
    DEALLOCATE(Buf)
  END DO

  CALL MPI_WaitAll( NoPartitions, Requests, MPI_STATUSES_IGNORE, ierr )
  n = SUM(Recv_Parts)
  IF ( Particles % NumberOfParticles+n > Particles % MaxNumberOfParticles ) THEN
    CALL IncreaseParticles( Particles, Particles % NumberOfParticles+2*n - &
                   Particles % MaxNumberOfParticles )
  END IF


  ! Recv particles:
  ! ---------------
  DO i=1,NoPartitions
    n = Recv_Parts(i)
    IF ( n<=0 ) CYCLE

    proc = Neigh(i)

    ALLOCATE(Indexes(n))
    CALL MPI_RECV( Indexes, n, MPI_DOUBLE_PRECISION, proc, &
         2001, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    DO j=1,n
      n_part = n_part+1
      Particles % Status(n_part) = PARTICLE_GHOST
      node = SearchNode(PI,Indexes(j))
      if ( node<=0 ) stop 'a'
      Particles % ClosestNode(n_part) = node
      Particles % NoClosestParticle(node) = &
              Particles % NoClosestParticle(node) + 1
    END DO
    DEALLOCATE(Indexes)

    m = n+n*dim
    IF ( ASSOCIATED(Particles % Velocity) ) m=m+n*dim

    ALLOCATE(Buf(m))
    CALL MPI_RECV( Buf, m, MPI_DOUBLE_PRECISION, proc, &
        2002, MPI_COMM_WORLD, status, ierr )

    n_part=Particles % NumberOfParticles
    m = 0
    DO k=1,dim
      DO l=1,n
        m = m + 1
        Particles % Coordinate(n_part+l,k)=Buf(m)
      END DO
    END DO

    DO l=1,n
      m = m + 1
      Particles % Dt(n_part+l) = Buf(m)
    END DO

    IF ( ASSOCIATED(Particles % Velocity) ) THEN
      DO k=1,dim
        DO l=1,n
          m = m + 1
          Particles % Velocity(n_part+l,k)=Buf(m)
        END DO
      END DO
    END IF
    DEALLOCATE(Buf)
    Particles % NumberOfParticles = Particles % NumberOfParticles+n
  END DO
  
  DEALLOCATE(Perm)
  DO i=1,NoPartitions
    IF ( Info(i) % n==0 ) CYCLE
    DEALLOCATE( Info(i) % Gindex, Info(i) % Particles )
  END DO
  DEALLOCATE(Info, Recv_Parts, Neigh, Requests)

END SUBROUTINE ExchangeNeighbourParticles
!------------------------------------------------------------





!------------------------------------------------------------
! For the first call of given node do the list, thereafter 
! Return the index until the list is finished
!------------------------------------------------------------
FUNCTION GetNextNeighbour( Particles, No ) RESULT ( No2 )
   IMPLICIT NONE

  TYPE(Particle_t) :: Particles
  INTEGER :: No, No2

  INTEGER :: PrevNo = 0
  INTEGER, POINTER :: NodeIndexes(:), NeighbourList(:) => NULL(), TmpList(:) => NULL()
  INTEGER :: i,j,k,n,ListSize,NoNeighbours,ElementIndex,Cnt
  LOGICAL :: Visited = .FALSE.
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Element_t), POINTER :: Element
  
  SAVE Visited,PrevNo,NeighbourList,ListSize,NoNeighbours,Cnt

  IF( PrevNo /= No ) THEN
    PrevNo = No
    IF( .NOT. Visited ) THEN
      Visited = .TRUE.
      Mesh => GetMesh()
      n = Mesh % MaxElementNodes 
      ListSize = n * Particles % MaxClosestParticles + 10
      ALLOCATE( NeighbourList( ListSize ) )
      NeighbourList = 0 
      Mesh => GetMesh()
    END IF

    Mesh => GetMesh()
    ElementIndex = Particles % ElementIndex(No)
    Element => Mesh % Elements( ElementIndex )
    n = GetElementNOFNodes(Element)
    NodeIndexes => Element % NodeIndexes

    NoNeighbours = 0
    DO i=1,n
      j = NodeIndexes(i)

      DO k=Particles % CumClosestParticle(j),Particles % CumClosestParticle(j+1)-1 
        No2 = Particles % ClosestParticle(k)

        ! No self coupling in this list	
        IF( No2 == No ) CYCLE

        ! Set symmetric forces Fij=-Fij so no need to go through twice
        IF ( No2 < No ) CYCLE

        NoNeighbours = NoNeighbours + 1

        IF( NoNeighbours > ListSize ) THEN
          ALLOCATE( TmpList( ListSize + 20 ) )
          TmpList(1:ListSize) = NeighbourList
          DEALLOCATE( NeighbourList ) 
          NeighbourList => TmpList
          ListSize = ListSize + 20
          NULLIFY( TmpList ) 
          CALL Info('GetNextNeighbour','Allocating more space')
        END IF

        NeighbourList(NoNeighbours) = No2
      END DO
    END DO
    Cnt = 0
  END IF 

  Cnt = Cnt + 1
  IF( Cnt > NoNeighbours ) THEN
    No2 = 0
  ELSE
    No2 = NeighbourList( Cnt ) 
  END IF

END FUNCTION GetNextNeighbour

!---------------------------------------------------------
! Take a time step
!---------------------------------------------------------
SUBROUTINE ParticleInitializeTime( Particles )
  TYPE(Particle_t) :: Particles

  Particles % Acceleration = 0.0_dp
END SUBROUTINE ParticleInitializeTime

!---------------------------------------------------------
! Take a time step
!---------------------------------------------------------
SUBROUTINE ParticleAdvanceTime( Particles, dtime )
  TYPE(Particle_t) :: Particles
  REAL(KIND=dp) :: dtime

  INTEGER :: No

  DO No=1,Particles % NumberOfParticles
    IF ( Particles % Status(No)==PARTICLE_LOST ) CYCLE

    Particles % Velocity(No,:) = Particles % Velocity(No,:) + &
        dtime * Particles % Acceleration(No,:)
    Particles % Acceleration(No,:)= 0.0_dp
  
    Particles % Coordinate(No,:) = Particles % Coordinate(No,:) + &
        dtime * Particles % Velocity(No,:)
  END DO
END SUBROUTINE ParticleAdvanceTime


!---------------------------------------------------------------    
! Checks the boundaries for rectangular and cubic shapes and 
! enforces elastic reflection or periodic BCs. 
! This is alternative and computationally more econimic way 
! of enforcing some boundary conditions for the particle that 
! may at best be use for testing purposes.
!---------------------------------------------------------------    
SUBROUTINE ParticleBoxLimits(Particles)
  
  TYPE(Particle_t) :: Particles

  TYPE(Solver_t), POINTER :: Solver
  REAL(KIND=dp) :: Coord(3), Velo(3)  , s(3)
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(ValueList_t), POINTER :: Params
  REAL(KIND=dP) :: MinCoord(3), MaxCoord(3), Ymin, Ymax, Zmin, Zmax
  INTEGER :: i,j,dim, ierr
  LOGICAL :: Mapped,Reflect,Periodic,Visited = .FALSE.
  INTEGER :: Operations, No, NoParticles, Status
  
  SAVE Visited, Reflect, Periodic, MinCoord, MaxCoord, dim
  
  IF( .NOT. Visited ) THEN
    Mesh => GetMesh()
    Params => GetSolverParams()
    dim = Mesh % Meshdim
    
    Reflect = GetLogical( Params,'Reflection BC')
    Periodic = GetLogical( Params,'Periodic BC')
    IF(Reflect) Periodic = .FALSE.
    
    MinCoord(1) = MINVAL(Mesh % Nodes % x)
    MinCoord(2) = MINVAL(Mesh % Nodes % y)
    MinCoord(3) = MINVAL(Mesh % Nodes % z)
    
    MaxCoord(1) = MAXVAL(Mesh % Nodes % x)
    MaxCoord(2) = MAXVAL(Mesh % Nodes % y)
    MaxCoord(3) = MAXVAL(Mesh % Nodes % z)

     s = MinCoord
     CALL MPI_ALLREDUCE( s, mincoord, 3, MPI_DOUBLE_PRECISION, &
            MPI_MIN, MPI_COMM_WORLD, ierr )

     s = MaxCoord
     CALL MPI_ALLREDUCE( s, maxcoord, 3, MPI_DOUBLE_PRECISION, &
            MPI_MAX, MPI_COMM_WORLD, ierr )
    
    Visited = .TRUE.
  END IF
  
  NoParticles = Particles % NumberOfParticles

  DO No = 1, NoParticles
    Status = Particles % Status(No) 
    IF( Status == PARTICLE_LOST ) CYCLE
    IF( Status < PARTICLE_INITIATED ) CYCLE

    Coord(1:dim) = Particles % Coordinate(No,1:dim)
    Velo(1:dim) = Particles % Velocity(No,1:dim)
    
    ! Boundary conditions for reflection. 
    ! Multiple reflections may be carried out.
    !------------------------------------------
    IF( Reflect ) THEN
      DO i=1,dim
        Mapped = .FALSE.
        DO j=1,dim
          IF( Coord(j) < MinCoord(j) ) THEN
            Coord(j) = 2 * MinCoord(j) - Coord(j)
            Velo(j) = -Velo(j)
            Mapped = .TRUE.
          ELSE IF ( Coord(j) > MaxCoord(j) ) THEN
            Coord(j) = 2 * MaxCoord(j) - Coord(j)
            Velo(j) = -Velo(j)
            Mapped = .TRUE.
          END IF
        END DO
        IF(.NOT. Mapped ) EXIT
      END DO
    END IF
    
    ! Boundary conditions for periodic BCs
    !------------------------------------------
    IF( Periodic ) THEN
      DO i=1,dim
        Mapped = .FALSE.
        DO j=1,dim
          IF( Coord(j) < MinCoord(j) ) THEN
            Coord(j) = MaxCoord(j) - MinCoord(j) + Coord(j)
            Mapped = .TRUE.
          ELSE IF ( Coord(j) > MaxCoord(j) ) THEN
            Coord(j) = MinCoord(j) - MaxCoord(j) + Coord(j)
            Mapped = .TRUE.
          END IF
        END DO
        IF(.NOT. Mapped ) EXIT
      END DO
    END IF
    
    Particles % Coordinate(No,1:dim) = Coord(1:dim)
    Particles % Velocity(No,1:dim) = Velo(1:dim)
  END DO
  
END SUBROUTINE ParticleBoxLimits



 !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutput( Particles ) 
    
    TYPE(Particle_t) :: Particles
    LOGICAL :: Visited = .FALSE.
    TYPE(ValueList_t), POINTER :: Params     
    CHARACTER(LEN=MAX_NAME_LEN) :: FileFormat
    LOGICAL :: VtuFormat, TableFormat, Found

    SAVE :: TableFormat, VtuFormat, Visited
    
    IF( .NOT. Visited ) THEN
      Params => GetSolverParams()
      TableFormat = GetLogical( Params,'Table Format',Found)
      VtuFormat = GetLogical( Params,'Vtu Format',Found)
      FileFormat = GetString( Params,'Output Format',Found) 
      IF( Found ) THEN
        IF( FileFormat == 'vtu') VtuFormat = .TRUE.
        IF( FileFormat == 'table') TableFormat = .TRUE.
      END IF
      Visited = .TRUE.
    END IF

    IF( TableFormat ) CALL ParticleOutputTable( Particles )
    IF( VtuFormat ) CALL ParticleOutputVtu( Particles ) 

  END SUBROUTINE ParticleOutput


  !------------------------------------------------------------------------
  ! Write particles in an ascii format 
  !-------------------------------------------------------------------------
  SUBROUTINE ParticleOutputTable( Particles ) 
    
    TYPE(Particle_t) :: Particles

    TYPE(Variable_t), POINTER :: TimeVar
    TYPE(ValueList_t), POINTER :: Params 
    CHARACTER(LEN=MAX_NAME_LEN) :: FilePrefix, FileName
    LOGICAL :: Found, NumberFilesByParticles, NumberFilesBySteps
    REAL(KIND=dp), POINTER :: Coord(:,:), Velo(:,:), Dist(:)
    REAL(KIND=dp) :: time
    TYPE(Mesh_t), POINTER :: Mesh
    INTEGER, POINTER :: Status(:)
    INTEGER :: i,j,dim, NoParticles, MinSaveStatus
    INTEGER :: VisitedTimes = 0

    SAVE :: VisitedTimes, Params, FilePrefix, NumberFilesByParticles, NumberFilesBySteps, &
        MinSaveStatus, TimeVar

    VisitedTimes = VisitedTimes + 1

    Mesh => GetMesh()
    dim = Particles % dim

    Coord => Particles % Coordinate
    Velo => Particles % Velocity 
    Dist => Particles % Distance
    Status => Particles % Status

    IF( VisitedTimes == 1 ) THEN
      Params => GetSolverParams()
      FilePrefix = ListGetString(Params,'Filename Prefix',Found )
      IF(.NOT. Found) FilePrefix = 'track'
      CALL WriteParticleFileNames(FilePrefix, dim)

      NumberFilesByParticles = ListGetLogical( Params,'File Numbering By Particles',Found) 
      NumberFilesBySteps = ListGetLogical( Params,'File Numbering By Steps',Found) 
      IF( NumberFilesByParticles .AND. NumberFilesBySteps ) THEN
        CALL Fatal('ParticleTracker','Files may be numbered either by steps or particles')
      END IF
      
      MinSaveStatus = ListGetInteger( Params,'Min Status for Saving',Found)
      
      TimeVar => VariableGet( Mesh % Variables,'time')
    END IF

    time = TimeVar % Values(1)
    NoParticles = Particles % NumberOfParticles

    IF(.NOT. NumberFilesByParticles ) THEN
      IF( NumberFilesBySteps ) THEN
        CALL OpenParticleFile(FilePrefix, VisitedTimes )
      ELSE
        CALL OpenParticleFile(FilePrefix, 0 )        
      END IF
      DO i = 1, NoParticles
        IF ( Particles % Status(i) == PARTICLE_LOST .OR. &
             Particles % Status(i) < MinSaveStatus )  CYCLE
        CALL WriteParticleLine( dim, i )        
      END DO
      CALL CloseParticleFile()
    ELSE
      DO i = 1, NoParticles
        CALL OpenParticleFile(FilePrefix, i)
        IF ( Particles % Status(i) == PARTICLE_LOST .OR. &
             Particles % Status(i) < MinSaveStatus )  CYCLE
        CALL WriteParticleLine( dim, i ) 
        CALL CloseParticleFile()
      END DO
    END IF


  CONTAINS

    !------------------------------------------------------------------------
    ! Write the names file for user information. Remember to update this if 
    ! SaveParticleStep is modified.
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleFileNames( Prefix, Dim ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: dim

      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      INTEGER :: i,j
      
      WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat.names'
      
      OPEN (10, FILE=FileName )
      
      WRITE( 10, '(A)' ) 'Variables in file: '//TRIM(FilePrefix)//'*.dat'
      WRITE( 10, '(A,I2)' ) 'Dimension of particle set is',dim
      i = 1
      WRITE( 10, '(I2,A)' )  i,': time'
      WRITE( 10, '(I2,A)' )  i+1,': Coordinate_1'
      WRITE( 10, '(I2,A)' )  i+2,': Coordinate_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Coordinate_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Velocity_1'
      WRITE( 10, '(I2,A)' )  i+2,': Velocity_2'
      IF(dim == 3) WRITE( 10, '(I2,A)' )  i+3,': Velocity_3'
      i = i + DIM
      WRITE( 10, '(I2,A)' )  i+1,': Distance'
      i = i + 1
      
      CLOSE( 10 )
      
    END SUBROUTINE WriteParticleFileNames



    !------------------------------------------------------------------------
    ! Open a numbered file for each particle. These must be separate since the 
    ! number of steps for each particle may vary greatly
    !-------------------------------------------------------------------------
    SUBROUTINE OpenParticleFile( Prefix, FileNo ) 
      
      CHARACTER(LEN=MAX_NAME_LEN) :: Prefix
      INTEGER :: FileNo
      LOGICAL, SAVE :: Visited = .FALSE.


      CHARACTER(LEN=MAX_NAME_LEN) :: FileName
      
      IF( FileNo == 0 ) THEN
        WRITE( FileName,'(A,A)') TRIM(FilePrefix),'.dat'
        IF( .NOT. Visited ) THEN
          CALL Info( 'ParticleTracker', 'Saving particle paths to file: '//TRIM(FileName), Level=4 )
        END IF
      ELSE
        IF ( FileNo==1 .AND.  .NOT. Visited ) THEN
          WRITE( Message, * ) 'Saving particle paths to files: ', TRIM(FilePrefix)//'_*.dat'
          CALL Info( 'ParticleTracker', Message, Level=4 )
        END IF
        FileName=TRIM(FilePrefix)//'_'//TRIM(i2s(fileno))//'.dat'
      END IF
      IF ( ParEnv % Pes>1 ) FileName=TRIM(FileName)//TRIM(i2s(ParEnv % myPE))

      
      IF( VisitedTimes == 1 .OR. NumberFilesBySteps ) THEN
        OPEN (10, FILE=FileName )
        WRITE( 10, '()', ADVANCE='no' ) ! delete old contents
      ELSE
        OPEN (10, FILE=FileName,POSITION='APPEND' )
      END IF

      Visited = .TRUE.

    END SUBROUTINE OpenParticleFile
    
    
    !------------------------------------------------------------------------
    ! Save one line in the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE WriteParticleLine( Dim, No )
      INTEGER :: Dim, No
      
      IF( NumberFilesBySteps ) THEN
        WRITE( 10, * ) time, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      ELSE IF( NumberFilesByParticles ) THEN
        WRITE( 10, * ) time, VisitedTimes, Coord(No,1:Dim), Velo(No,1:dim), Dist(No) 
      ELSE       
        WRITE( 10, * ) time, VisitedTimes, No, Coord(No,1:dim), Velo(No,1:dim), Dist(No) 
      END IF

    END SUBROUTINE WriteParticleLine
    
    
    !------------------------------------------------------------------------
    ! Close the particle file
    !-------------------------------------------------------------------------
    SUBROUTINE CloseParticleFile( )
      
      CLOSE( 10 )
      
    END SUBROUTINE CloseParticleFile
           
  END SUBROUTINE ParticleOutputTable




SUBROUTINE ParticleOutputVtu( Particles )
!------------------------------------------------------------------------------

  USE DefUtils 
  USE MeshUtils
  USE ElementDescription
  
  IMPLICIT NONE
  TYPE(Particle_t) :: Particles  
  
  TYPE(ValueList_t),POINTER :: Params
  INTEGER, SAVE :: nTime = 0
  LOGICAL :: GotIt, Parallel, FixedMesh
  CHARACTER(MAX_NAME_LEN), SAVE :: FilePrefix
  CHARACTER(MAX_NAME_LEN) :: VtuFile, PvtuFile 
  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Variable_t), POINTER :: Var
  INTEGER :: i, j, k, Partitions, Part, ExtCount, FileindexOffSet
  CHARACTER(MAX_NAME_LEN) :: Dir
  LOGICAL :: Visited = .FALSE.

  CHARACTER(MAX_NAME_LEN) :: Str
  INTEGER :: NumberOfNodes, ParallelNodes, Dim

  Params => GetSolverParams()
  Mesh => GetMesh()

  ExtCount = ListGetInteger( Params,'Output Count',GotIt)
  IF( GotIt ) THEN
    nTime = ExtCount
  ELSE
    nTime = nTime + 1
  END IF
  FileIndexOffset = ListGetInteger( Params,'Fileindex offset',GotIt)

  IF ( nTime == 1 ) THEN
    CALL Info('ParticleOutputVtu','Saving results in VTK XML format')
    FilePrefix = GetString( Params,'Filename Prefix',GotIt )
    IF ( .NOT.GotIt ) FilePrefix = "Particles"
  END IF
  
  Partitions = ParEnv % PEs
  Part = ParEnv % MyPE
  Parallel = (Partitions > 1) .OR. ListGetLogical(Params,'Enforce Parallel format',GotIt)

  Dim = Particles % dim
  NumberOfNodes = Particles % NumberOfParticles

  IF (LEN_TRIM(Mesh % Name) > 0 ) THEN
    Dir = TRIM(Mesh % Name) // "/"
  ELSE
    Dir = "./"
  END IF
  
  IF(Parallel .AND. Part == 0) THEN
    WRITE( PvtuFile,'(A,A,I4.4,".pvtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
    CALL WritePvtuFile( PvtuFile )
  END IF
  
  IF ( Parallel ) THEN
    WRITE( VtuFile,'(A,A,I4.4,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),Part+1,"par",nTime
  ELSE
    WRITE( VtuFile,'(A,A,I4.4,".vtu")' ) TRIM(Dir),TRIM(FilePrefix),nTime+FileIndexOffset
  END IF
  CALL WriteVtuFile( VtuFile )


CONTAINS

  
  SUBROUTINE WriteVtuFile( VtuFile )
    CHARACTER(LEN=*), INTENT(IN) :: VtuFile
    INTEGER, PARAMETER :: VtuUnit = 58
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=512) :: str
    INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
    CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
    LOGICAL :: ScalarsExist, VectorsExist, Found
    INTEGER, POINTER :: Perm(:)
    REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)
    REAL(KIND=dp) :: x,y,z

    
    OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
    
    WRITE( VtuUnit,'(A)') '<VTKFile type="UnstructuredGrid" version="0.1" byte_order="LittleEndian">'
    WRITE( VtuUnit,'(A)') '  <UnstructuredGrid>'
    WRITE( VtuUnit,'(A,I0,A)') '    <Piece NumberOfPoints="',NumberOfNodes,&
        '" NumberOfCells="0">'


    
    ! nodewise information
    !-------------------------------------
    ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
    VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
    IF( ScalarsExist .AND. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)&
          //'" Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE IF( ScalarsExist ) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Scalars="'//TRIM(ScalarFieldName)//'">'
    ELSE IF( VectorsExist ) THEN
      WRITE( VtuUnit,'(A)') '      <PointData Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE
      CALL Warn('WriteVtkXMLFile','Are there really no scalars or vectors?')
    END IF
    
    DO Rank = 0,1
      DO Vari = 1, 99
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        END IF
        
        FieldName = GetString( Params, TRIM(Txt), Found )
        IF(.NOT. Found) EXIT
        
        !---------------------------------------------------------------------
        ! Find the variable with the given name in the normal manner 
        !---------------------------------------------------------------------
        IF( FieldName == 'velocity' ) THEN
          VectorValues => Particles % Velocity
        ELSE IF( FieldName == 'acceleration') THEN
          VectorValues => Particles % Acceleration 
        ELSE IF( FieldName == 'distance') THEN
          ScalarValues => Particles % Distance
        ELSE IF( FieldName == 'dt') THEN
          ScalarValues => Particles % dt
        ELSE
          WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
          CALL Warn('WriteVtuXMLFile', Txt)
          CYCLE
        END IF

        !---------------------------------------------------------------------
        ! Finally save the field values 
        !---------------------------------------------------------------------
        IF( Rank == 0) THEN
          WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="1" format="ascii">'    
          DO i = 1, NumberOfNodes
            j = i
            IF(j > 0) THEN
              WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') ScalarValues(j)              
            ELSE
              WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0'  
            END IF
          END DO
          WRITE( VtuUnit,'(A)') ' '
          WRITE( VtuUnit,'(A)') '        </DataArray>'
        ELSE
          sdofs = 3
          WRITE( VtuUnit,'(A,I1,A)') '        <DataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="',sdofs,'" format="ascii">'    
          
          DO i = 1, NumberOfNodes
            j = i
            IF( dim == 2 ) THEN
              IF( j > 0 ) THEN
                WRITE( VtuUnit,'(2ES16.7E3,A)', ADVANCE='no') VectorValues(j,1:dim),' 0.0'
              ELSE
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
              END IF
            ELSE
              IF( j > 0 ) THEN
                WRITE( VtuUnit,'(ES16.7E3)', ADVANCE='no') VectorValues(j,1:dim)
              ELSE
                WRITE( VtuUnit,'(A)', ADVANCE='no') ' 0.0 0.0 0.0'  
              END IF              
            END IF
          END DO
          WRITE( VtuUnit,'(A)') ' '
          WRITE( VtuUnit,'(A)') '        </DataArray>'
        END IF
      END DO
    END DO
    
    IF( ScalarsExist .OR. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '      </PointData>'
    END IF
    
    
    ! Coordinates of each point
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <Points>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii">'    


    DO i = 1, NumberOfNodes
      DO j=1,dim
        WRITE(VtuUnit,'(ES16.7E3)', ADVANCE='no') Particles % Coordinate(i,j)
      END DO
      IF( dim == 3 ) THEN
        WRITE(VtuUnit,'(A)') ' '
      ELSE
        WRITE(VtuUnit,'(A)') ' 0.0'
      END IF
    END DO

    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '      </Points>'


    WRITE( VtuUnit,'(A)') '      <Cells>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="connectivity" format="ascii">'
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="offsets" format="ascii">'
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Int32" Name="types" format="ascii">'
    WRITE( VtuUnit,'(A)') '        </DataArray>'
    WRITE( VtuUnit,'(A)') '      </Cells>'

    WRITE( VtuUnit,'(A)') '    </Piece>'
    WRITE( VtuUnit,'(A)') '  </UnstructuredGrid>'
    WRITE( VtuUnit,'(A)') '</VTKFile>'

    CLOSE( VtuUnit )
  
  END SUBROUTINE WriteVtuFile
    


  SUBROUTINE WritePvtuFile( VtuFile )
    CHARACTER(LEN=*), INTENT(IN) :: VtuFile
    INTEGER, PARAMETER :: VtuUnit = 58
    TYPE(Variable_t), POINTER :: Var
    CHARACTER(LEN=512) :: str
    INTEGER :: i,j,k,dofs,Rank,cumn,n,vari,sdofs
    CHARACTER(LEN=1024) :: Txt, ScalarFieldName, VectorFieldName, FieldName
    LOGICAL :: ScalarsExist, VectorsExist, Found
    REAL(KIND=dp), POINTER :: ScalarValues(:), VectorValues(:,:)

    
    OPEN( UNIT=VtuUnit, FILE=VtuFile, STATUS='UNKNOWN' )
    
    WRITE( VtuUnit,'(A)') '<VTKFile type="PUnstructuredGrid" version="0.1" byte_order="LittleEndian">'
    WRITE( VtuUnit,'(A)') '  <PUnstructuredGrid>'
    
    ! nodewise information
    !-------------------------------------
    ScalarFieldName = GetString( Params,'Scalar Field 1',ScalarsExist)
    VectorFieldName = GetString( Params,'Vector Field 1',VectorsExist)
    IF( ScalarsExist .AND. VectorsExist) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)&
          //'" Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE IF( ScalarsExist ) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Scalars="'//TRIM(ScalarFieldName)//'">'
    ELSE IF( VectorsExist ) THEN
      WRITE( VtuUnit,'(A)') '    <PPointData Vectors="'//TRIM(VectorFieldName)//'">'
    ELSE
      CALL Warn('WriteVtkXMLFile','Are there really no scalars or vectors?')
    END IF

    
    DO Rank = 0,1
      DO Vari = 1, 99
        IF( Vari < 10 ) THEN
          IF(Rank==0) WRITE(Txt,'(A,I2)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I2)') 'Vector Field',Vari
        ELSE
          IF(Rank==0) WRITE(Txt,'(A,I3)') 'Scalar Field',Vari
          IF(Rank==1) WRITE(Txt,'(A,I3)') 'Vector Field',Vari
        END IF
        
        FieldName = GetString( Params, TRIM(Txt), Found )
        IF(.NOT. Found) EXIT
      
        IF( FieldName /= 'velocity' .AND. FieldName /= 'acceleration' .AND. &
            FieldName /= 'distance' .AND. FieldName /= 'dt' ) THEN
          WRITE(Txt, '(A,A)') 'Nonexistent variable: ',TRIM(FieldName)
          CALL Warn('WriteVtuXMLFile', Txt)
          CYCLE
        END IF

        IF( Rank == 0) THEN
          WRITE( VtuUnit,'(A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="1" format="ascii"/>'    
        ELSE
          sdofs = 3
          WRITE( VtuUnit,'(A,I1,A)') '      <PDataArray type="Float64" Name="'//TRIM(FieldName)&
              //'" NumberOfComponents="',sdofs,'" format="ascii"/>'    
        END IF
      END DO
    END DO
    WRITE( VtuUnit,'(A)') '    </PPointData>'

    ! Coordinates of each point
    !-------------------------------------
    WRITE( VtuUnit,'(A)') '      <PPoints>'
    WRITE( VtuUnit,'(A)') '        <DataArray type="Float64" NumberOfComponents="3" format="ascii"/>'    
    WRITE( VtuUnit,'(A)') '      </PPoints>' 

    DO i=1,Partitions
      WRITE( VtuUnit,'(A,I4.4,A,I4.4,A)' ) '    <Piece Source="'//&
          TRIM(FilePrefix),i,"par",nTime,'.vtu"/>'
    END DO

    WRITE( VtuUnit,'(A)') '  </PUnstructuredGrid>'
    WRITE( VtuUnit,'(A)') '</VTKFile>'

    CLOSE( VtuUnit )
  
  END SUBROUTINE WritePvtuFile



!------------------------------------------------------------------------------
END SUBROUTINE ParticleOutputVtu
!------------------------------------------------------------------------------



!--------------------------------------------------------------------------
! Set a the timestep for the particles in two possible modes
! 1) "No" is given => define step for each particle separately
! 2) "No" is not given => define the same step size for all particles
!-------------------------------------------------------------------------
FUNCTION GetParticlesTimeStep(Particles, InitInterval, No, tinit ) RESULT ( dt )
  
  TYPE(Particle_t) :: Particles
  LOGICAL :: InitInterval
  INTEGER, OPTIONAL :: No
  REAL(KIND=dp), OPTIONAL :: tinit
  REAL(KIND=dp) :: dt

  REAL(KIND=dp) :: dt0,tfin,tprev,dsmax,dsmin,hmax,hmin,dtmax,dtmin,dtup,dtlow, &
      CharSpeed, CharTime
  LOGICAL :: GotIt,TfinIs,NStepIs,DsMaxIs,DsMinIs,HmaxIs,HminIs
  INTEGER :: nstep, TimeStep, PrevTimeStep = -1
  TYPE(ValueList_t), POINTER :: Params

  SAVE dt0,dsmax,dsmin,hmax,hmin,dtmax,dtmin,dtup,dtlow,&
      tprev,Tfin,TfinIs,DsMaxIs,DsMinIs,HmaxIs,HminIs,PrevTimeStep
  
  IF( InitInterval ) THEN
    Params => GetSolverParams()
    
    ! directly defined timestep
    dt0 = GetCReal(Params,'Internal Timestep Size',GotIt)

    ! Constraint timestep directly
    dtmax = GetCReal( Params,'Max Timestep Size',GotIt)
    IF(.NOT. GotIt ) dtmax = HUGE( dtmax ) 
    dtmin = GetCReal( Params,'Min Timestep Size',GotIt)
    IF(.NOT. GotIt ) dtmin = -HUGE( dtmin ) 
    
    ! Constraint by absolute step size taken (in length units)
    dsmax = GetCReal( Params,'Max Timestep Distance',DsMaxIs)
    dsmin = GetCReal( Params,'Min Timestep Distance',DsMinIs)
    
    ! Constraint by relative step size taken (1 means size of the element)
    hmax = GetCReal( Params,'Max Timestep Courant',HMaxIs)
    hmin = GetCReal( Params,'Min Timestep Courant',HMinIs)
    
    TfinIs = .FALSE.
    IF( GetLogical(Params,'Use External Timestep Size',GotIt) ) THEN
      tfin = GetTimeStepsize()
      TfinIs = .TRUE.
    ELSE
      tfin = GetCReal(Params,'Max Cumulative Time',TfinIs)
    END IF
    
    Nstep = GetInteger( Params,'Internal Timestep Interval',NstepIs)

    tprev = 0.0_dp
  END IF

  IF( TfinIs .AND. ABS( tprev - tfin ) < TINY ( tfin ) ) THEN
    dt = 0.0_dp
    RETURN
  END IF


  ! Get upper and lower constraints for timestep size
  ! These generally depend on the velocity field and mesh
  !--------------------------------------------------------------------
  dtlow = dtmin
  dtup = dtmax 

  IF( DsMaxIs .OR. DsMinIs ) THEN
    CharSpeed = CharacteristicSpeed( Particles, No )     
    IF( DsMinIs ) THEN
      IF( CharSpeed * dtlow < dsmin ) dtlow = dsmin / CharSpeed
    END IF
    IF( DsMaxIs ) THEN
      IF( CharSpeed * dtup > dsmax  ) dtup = dsmax / CharSpeed
    END IF
  END IF

  IF( HmaxIs .OR. HminIs ) THEN
    CharTime = CharacteristicElementTime( Particles, No )     
    IF( HminIs ) THEN
      IF( dtlow < HMin * CharTime ) dtlow = HMin * CharTime ! ElementH / Speed
    END IF
    IF( HmaxIs ) THEN
      IF( dtup > HMax * CharTime ) dtup = HMax * CharTime ! ElementH / Speed
    END IF
  END IF

  IF( dtlow > dtup ) THEN
    CALL Warn('GetParticlesTimeStep','Upper and lower limits tangled')
  END IF

  ! Constrain the timestep
  !------------------------------------------------------------------
  dt = dt0
  IF( dt > dtup ) THEN
    ! PRINT *,'upper constraint',dtup
    dt = dtup
  END IF
  IF( dt < dtlow ) THEN
    ! PRINT *,'lower constaint',dtlow
    dt = dtlow
  END IF
  
  IF( dt < TINY(dt) ) THEN
    IF( TfinIs .AND. NstepIs ) THEN
      dt = tfin / Nstep
    ELSE
      ! PRINT *,'dt',dt
      CALL Fatal('GetParticlesTimeStep','Could not determine timestep size!')
    END IF
  END IF
  
  ! Do not exceed the total integration time
  !-------------------------------------------
  IF( PRESENT( tinit ) ) tprev = tinit
  IF( TfinIs .AND. dt + tprev > tfin ) THEN
    dt = tfin - tprev
  END IF
  tprev = tprev + dt

  
END FUNCTION GetParticlesTimeStep

!------------------------------------------------------------------------------
END MODULE ParticleUtils
!------------------------------------------------------------------------------
