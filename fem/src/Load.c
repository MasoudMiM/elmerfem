/******************************************************************************
! *
! *       ELMER, A Computational Fluid Dynamics Program.
! *
! *       Copyright 1st April 1995 - , Center for Scientific Computing,
! *                                    Finland.
! *
! *       All rights reserved. No part of this program may be used,
! *       reproduced or transmitted in any form or by any means
! *       without the written permission of CSC.
! *
! *****************************************************************************/
 
/*******************************************************************************
! *
! *  Utilities for dynamic loading of user functions, and other operating
! *  system interfaces.
! *
! ******************************************************************************
! *
! *                     Author:       Juha Ruokolainen
! *
! *                    Address: Center for Scientific Computing
! *                                Tietotie 6, P.O. BOX 405
! *                                  02
! *                                  Tel. +358 0 457 2723
! *                                Telefax: +358 0 457 2302
! *                              EMail: Juha.Ruokolainen@csc.fi
! *
! *                       Date: 02 Jun 1997
! *
! *                Modified by:
! *
! *       Date of modification:
! *
! *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>

/* macros and defs generated by configure */
#include "../config.h"


#ifdef WIN32
#  include <direct.h>
#  include <windows.h>
#else
#include <strings.h>
#  include <dlfcn.h>
#endif

#define MAX_NAME_LEN 128

#ifdef SGI64
void corename_()
{
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/prctl.h>

 prctl( PR_COREPID,0,0 );
}
#endif

/* WIN32 needs some weird attributes */
#ifdef WIN32
#define STDCALLBULL __stdcall
#else
#define STDCALLBULL 
#endif

/*--------------------------------------------------------------------------
  This routine will create a directory given name of the directory.
  -------------------------------------------------------------------------*/
void STDCALLBULL FC_FUNC(makedirectory,MAKEDIRECTORY)
     ( char *Name,int len )
{
#ifdef WIN32
    if ( _mkdir( Name ) != 0 ) {
#else
    if ( mkdir( Name, 0700 ) != 0 ) {
      chmod( Name, 0700 );
#endif
    }
}

/*--------------------------------------------------------------------------
  This routine execute a operating system command.
  -------------------------------------------------------------------------*/
void STDCALLBULL FC_FUNC(systemc,SYSTEMC)
  ( char *str, int l1 )
{
   system( str );
}

/*--------------------------------------------------------------------------
  This routine will return value of a environment variable to a
  given string variable.
  -------------------------------------------------------------------------*/
void STDCALLBULL FC_FUNC(envir,ENVIR)
#ifdef WIN32
  ( char *Name,int l1,char *Value,int l2,int *len )
#else
#  if defined(UNICOS)
  ( char *Name,int l1,char *Value,int l2,int *len )
#  else
#    if defined(AIX)
  ( char *Name,char *Value,int *len )
#    else
  ( char *Name,char *Value,int *len )
#    endif
#  endif
#endif
{
    if ( getenv( Name ) ) {
      strncpy( Value,(char *)getenv(Name), MAX_NAME_LEN );
      *len = strlen( Value );
    } else {
      *len = 0;
      *Value = '\0';
    }
}

/*--------------------------------------------------------------------------
  This routine will return address of a function given path to a dynamic
  load library and name of the routine.
  -------------------------------------------------------------------------*/

void *STDCALLBULL FC_FUNC(loadfunction,LOADFUNCTION)
#ifdef WIN32
     ( int Quiet, char *Library,int l1,char *Name,int l2 )
#else
#  if defined(UNICOS)
     ( int Quiet, char *Library,int l1,char *Name,int l2, int Quiet )
#  else
#     if defined(AIX)
     ( int Quiet, char *Library,char *Name )
#     else
     ( int Quiet, char *Library,char *Name )
#     endif
#  endif
#endif
{
/*--------------------------------------------------------------------------*/
   void (*Function)(),*Handle;
   int i;
/*--------------------------------------------------------------------------*/
   if ( Quiet==0 ) fprintf(stdout,"Loading user function library: [%s]...[%s]",Library,Name);
#ifndef WIN32
   if ( ( Handle = dlopen( Library,RTLD_NOW ) ) == NULL )
   { 
      fprintf( stderr, "Load: FATAL: Can't load shared image [%s]\n", Library );
      fprintf( stderr, "Load: [%s]\n", dlerror() );
      exit(0);
   }
#if defined(UNICOS)
   for( i=0; i<strlen(Name); i++ )
   {
      if ( Name[i] >= 'a'  && Name[i] <= 'z' ) Name[i] += 'A' - 'a';
   }
#else 
   for( i=0; i<strlen(Name); i++ )
   {
      if ( Name[i] >= 'A'  && Name[i] <= 'Z' ) Name[i] += 'a' - 'A';
   }
#  ifndef AIX
     strcat( Name, "_" );
#  endif
#endif

   if ( (Function = dlsym( Handle,Name ) ) == NULL )
   {
      fprintf( stderr, "Load: FATAL: Can't find procedure [%s]\n", Name );
      exit(0);
   }

#else

   if ( ( Handle = (void *)LoadLibrary( Library ) ) == NULL )
   { 
     fprintf( stderr, "Load: FATAL: Can't load shared image [%s]\n", Library );
     exit(0);
   }

   for( i=0; i<strlen(Name); i++ )
   {
     if ( Name[i] >= 'a'  && Name[i] <= 'z' ) Name[i] += 'A' - 'a';
   }

   if ( (Function = (void *)GetProcAddress( Handle,Name ) ) == NULL )
   {
     fprintf( stderr,"Load: FATAL: Can't find procedure [%s]\n", Name );
     exit(0);
   }

#endif
   if ( Quiet == 0 ) fprintf( stdout, "...done.\n" );

   return Function;
}

/*--------------------------------------------------------------------------
  INTERNAL: Execute given function returning integer value
  -------------------------------------------------------------------------*/
static int IntExec( int (*Function)(),void *Model )
{
   return (*Function)( Model );
}

/*--------------------------------------------------------------------------
   Execute given function returning integer value
  -------------------------------------------------------------------------*/
#ifdef WIN32
  int __stdcall EXECINTFUNCTION( int *Function,void *Model )
#else
#  if defined(UNICOS)
     int EXECINTFUNCTION( long int *Function,void *Model )
#  else
#    ifdef AIX
       int execintfunction( long int *Function,void *Model )
#    else
       int execintfunction_( long int *Function,void *Model )
#    endif
#  endif
#endif
{
   return IntExec( (int (*)())*Function,Model );
}


/*--------------------------------------------------------------------------
   INTERNAL: Execute given function returning double value
  -------------------------------------------------------------------------*/
static void DoubleArrayExec( double *(*Function)(), void *Model,
               int *Node, double *Value, double *Array )
{
   (*Function)( Model,Node,Value,Array );
}

/*--------------------------------------------------------------------------
   Execute given function returning double value
  -------------------------------------------------------------------------*/
#ifdef WIN32
  void __stdcall EXECREALARRAYFUNCTION( int *Function, void *Model,
                  int *Node, double *Value, double *Array )
#else
#  if defined(UNICOS)
     void EXECREALARRAYFUNCTION( long int *Function, void *Model,
            int *Node, double *Value, double *Array )
#  else
#    ifdef AIX
        void execrealarrayfunction(  long int *Function, void *Model,
                  int *Node, double *Value, double *Array )
#    else
       void execrealarrayfunction_( long int *Function, void *Model,
                  int *Node, double *Value, double *Array )
#    endif
#  endif
#endif
{
   DoubleArrayExec( (void (*)())*Function,Model,Node,Value, Array );
}


/*--------------------------------------------------------------------------
   INTERNAL: Execute given function returning double value
  -------------------------------------------------------------------------*/
static double DoubleExec( double (*Function)(), void *Model,
               int *Node, double *Value )
{
   return (*Function)( Model,Node,Value );
}

/*--------------------------------------------------------------------------
   Execute given function returning double value
  -------------------------------------------------------------------------*/
#ifdef WIN32
  double __stdcall EXECREALFUNCTION( int *Function, void *Model,
                  int *Node, double *Value )
#else
#  if defined(UNICOS)
     double EXECREALFUNCTION( long int *Function, void *Model,
                  int *Node, double *Value )
#  else
#    ifdef AIX
       double execrealfunction(  long int *Function, void *Model,
                  int *Node, double *Value )
#    else
       double execrealfunction_( long int *Function, void *Model,
                  int *Node, double *Value )
#    endif
#  endif
#endif
{
   return DoubleExec( (double (*)())*Function,Model,Node,Value );
}

/*--------------------------------------------------------------------------
   INTERNAL: Execute given function returning double value
  -------------------------------------------------------------------------*/
static double ConstDoubleExec( double (*Function)(), void *Model,
               double *x, double *y, double *z )
{
   return (*Function)( Model, x,y,z );
}

/*--------------------------------------------------------------------------
   Execute given function returning double value
  -------------------------------------------------------------------------*/
#ifdef WIN32
  double __stdcall EXECCONSTREALFUNCTION( int *Function, void *Model,
                  double *x, double *y, double *z )
#else
#  if defined(UNICOS)
     double EXECCONSTREALFUNCTION( long int *Function, void *Model,
                  double *x, double *y, double *z )
#  else
#    ifdef AIX
       double execconstrealfunction(  long int *Function, void *Model,
                  double *x, double *y, double *z )

#    else
       double execconstrealfunction_( long int *Function, void *Model,
                  double *x, double *y, double *z )
#    endif
#  endif
#endif
{
   return ConstDoubleExec( (double (*)())*Function,Model,x,y,z );
}


/*--------------------------------------------------------------------------
   Return argument (just to fool Fortran type checking)
  -------------------------------------------------------------------------*/
#ifdef WIN32
  void * __stdcall ADDRFUNC( void *Function )
#else
#  if defined(UNICOS)
     void *ADDRFUNC( void *Function )
#  else
#    ifdef AIX
       void *addrfunc(  void *Function )
#    else
       void *addrfunc_( void *Function )
#    endif
#  endif
#endif
{
   return (void *)Function;
}


/*--------------------------------------------------------------------------
   INTERNAL: Call solver routines at given address
  -------------------------------------------------------------------------*/
static void DoExecSolver(
  void (*SolverProc)(), void *Model, void *Solver, void *dt, void *Transient)
{
   (*SolverProc)( Model,Solver,dt,Transient );
}


/*--------------------------------------------------------------------------
   Call solver routines at given address
  -------------------------------------------------------------------------*/
#ifdef WIN32
  void __stdcall EXECSOLVER( int *SolverProc,
              void *Model, void *Solver, void *dt, void *Transient )
#else
#  if defined(UNICOS)
      void EXECSOLVER( long int *SolverProc,
              void *Model, void *Solver, void *dt, void *Transient )
#  else
#    ifdef AIX
        void execsolver(  long int *SolverProc,
              void *Model, void *Solver, void *dt, void *Transient )
#    else
#      ifdef SGIn32
        void execsolver_( long int *SolverProc,
              void *Model, void *Solver, double *dt, void *Transient )
#      else
        void execsolver_( long int *SolverProc,
              void *Model, void *Solver, void *dt, void *Transient )
#      endif
#    endif
#  endif
#endif
{
   DoExecSolver( (void (*)())*SolverProc,Model,Solver,dt,Transient );
}

/*--------------------------------------------------------------------------
   INTERNAL: Call lin. solve routines at given address
  -------------------------------------------------------------------------*/
static int DoLinSolveProcs(
  int (*SolverProc)(), void *Model, void *Solver, void *Matrix, void *b, 
                void *x, void *n, void *DOFs, void *Norm )
{
   return (*SolverProc)( Model,Solver,Matrix,b,x,n, DOFs,Norm );
}


/*--------------------------------------------------------------------------
   Call lin. solver routines at given address
  -------------------------------------------------------------------------*/
#ifdef WIN32
  int __stdcall EXECLINSOLVEPROCS( int *SolverProc,
   void *Model, void *Solver, void *Matrix, void *b, void *x, void *n, void *DOFs, void *Norm )
#else
#  if defined(UNICOS)
  int  EXECLINSOLVEPROCS( int *SolverProc,
   void *Model, void *Solver, void *Matrix, void *b, void *x, void *n, void *DOFs, void *Norm )
#  else
#    ifdef AIX
        int  execlinsolveprocs( int *SolverProc,
         void *Model, void *Solver, void *Matrix, void *b, void *x, void *n, void *DOFs, void *Norm )
#    else
       int  execlinsolveprocs_( long int *SolverProc,
         void *Model, void *Solver, void *Matrix, void *b, void *x, void *n, void *DOFs, void *Norm )

#    endif
#  endif
#endif
{
   return DoLinSolveProcs( (int (*)())*SolverProc,Model,Solver,Matrix,b,x,n,DOFs,Norm );
}

char *mtc_domath(char *);
void mtc_init(FILE *,FILE *, FILE *);

/*--------------------------------------------------------------------------
  This routine will call matc and return matc result
  -------------------------------------------------------------------------*/
#ifdef WIN32
  void  __stdcall MATC( char *cmd,int l1,char *Value,int l2,int *len )
#else
#  if defined(UNICOS)
     void MATC( char *cmd,int l1,char *Value,int l2,int *len )
#  else
#     if defined(AIX)
        void matc( char *cmd,char *Value,int *len )
#     else
        void matc_( char *cmd,char *Value,int *len )
#     endif
#  endif
#endif
{
#define MAXLEN 8192

    static int been_here = 0;
    char *ptr, cc[32], *cmdcopy;

    if ( been_here==0 ) {
#ifdef WIN32
       mtc_init_std( NULL, stdout, stderr ); 
       mtc_domath_std( "format(12,\"rowform\")" );
#else
       mtc_init( NULL, stdout, stderr ); 
       strcpy( cc, "format( 12,\"rowform\")" );
       mtc_domath( cc );
#endif
       been_here = 1;
     }

    cmd[*len] = '\0';

#ifdef WIN32
    if ( ptr = (char *)mtc_domath_std( cmd ) ) {
#else
    if ( ptr = (char *)mtc_domath( cmd ) ) {
#endif
      strcpy( Value, (char *)ptr );
      *len = strlen(Value)-1;

      if ( strncmp( Value, "MATC ERROR:", 11 ) == 0 ) {
          fprintf( stderr, "Solver input file error: %s\n", Value );
          exit(0);
      }
    } else {
      *len = 0;
      *Value = ' ';
    }
}


/*--------------------------------------------------------------------------
  INTERNAL: execute user material function
  -------------------------------------------------------------------------*/
static double DoViscFunction(
  double (*SolverProc)(), void *Model, void *Element, void *Nodes, void *n,
     void *Basis, void *GradBasis, void *Viscosity, void *Velo, void *GradV )
{
   double s;
   s = (*SolverProc)( Model,Element,Nodes,n,Basis,GradBasis,
                   Viscosity, Velo, GradV );
   return s;
}

/*--------------------------------------------------------------------------
  This routine will call user defined material def. function
  -------------------------------------------------------------------------*/
#ifdef WIN32
  double  __stdcall MATERIALUSERFUNCTION( int *Function,
   void *Model, void *Element, void *Nodes, void *n, void *Basis,
      void *GradBasis, void *Viscosity, void *Velo, void *gradV )
#else
#  if defined(UNICOS)
     double MATERIALUSERFUNCTION( int *Function,
      void *Model, void *Element, void *Nodes, void *n, void *Basis,
         void *GradBasis, void *Viscosity, void *Velo, void *gradV )
#  else
#     if defined(AIX)
        double materialuserfunction( int *Function,
         void *Model, void *Element, void *Nodes, void *n, void *Basis,
            void *GradBasis, void *Viscosity, void *Velo, void *gradV )
#     else
        double materialuserfunction_( long int *Function,
         void *Model, void *Element, void *Nodes, void *n, void *Basis,
            void *GradBasis, void *Viscosity, void *Velo, void *gradV )
#     endif
#  endif
#endif
{
   return DoViscFunction( (double (*)())*Function,Model,Element,Nodes,n,Basis,
                  GradBasis,Viscosity,Velo,gradV );
}

/*--------------------------------------------------------------------------
  INTERNAL: execute user material function
  -------------------------------------------------------------------------*/
static void DoSimulationProc( void (*SimulationProc)(), void *Model )
{ (*SimulationProc)( Model ); }

/*--------------------------------------------------------------------------
  This routine will call user defined material def. function
  -------------------------------------------------------------------------*/
#ifdef WIN32
  void __stdcall EXECSIMULATIONPROC( int *Function, void *Model )
#else
#  if defined(UNICOS)
     void EXECSIMULATIONPROC( int *Function, void *Model )
#  else
#     if defined(AIX)
        void execsimulationproc( int *Function, void *Model )
#     else
        void execsimulationproc_( long int *Function, void *Model )
#     endif
#  endif
#endif
{
   DoSimulationProc( (void (*)())*Function,Model );
}

