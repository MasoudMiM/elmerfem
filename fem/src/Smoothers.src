!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - IT Center for Science Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module containing the smoothers used in multigrid solvers.
! *  The routines were moved from module Multigrid.  
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 2001
! *
! *****************************************************************************/
 
MODULE Smoothers

  USE Types
  USE CRSMatrix
  USE Lists
  USE ParallelUtils  

  IMPLICIT NONE

CONTAINS

!------------------------------------------------------------------------------
    FUNCTION MGSmooth( Solver, A, Mesh, x, b, r, Level, DOFs, PreSmooth, CF) RESULT(RNorm)
!------------------------------------------------------------------------------
      USE ParallelUtils
      TYPE(Solver_t), POINTER :: Solver
      TYPE(Matrix_t), POINTER :: A
      TYPE(Mesh_t) :: Mesh
      INTEGER :: Level, DOFs
      REAL(KIND=dp), TARGET :: x(:),b(:),r(:),RNorm, rphi=5.0_dp
      LOGICAL PreSmooth
      INTEGER, POINTER, OPTIONAL :: CF(:)
!------------------------------------------------------------------------------
      CHARACTER(LEN=MAX_NAME_LEN) :: IterMethod, im
      LOGICAL :: Parallel, Found
      TYPE(Matrix_t), POINTER :: M
      INTEGER :: n, Rounds, InvLevel
      INTEGER, POINTER :: Iters(:)
      REAL(KIND=dp), POINTER :: Mx(:),Mb(:),Mr(:)
      REAL(KIND=dp) :: Omega, Bnorm
      REAL(KIND=dp), POINTER :: TmpArray(:,:)
      REAL(KIND=dp), ALLOCATABLE :: Q(:), Z(:), Ri(:), T(:), &
             T1(:), T2(:), S(:), V(:), Pr(:)
!------------------------------------------------------------------------------
      
      SAVE Z, Pr, Q, Ri, T, T1, T2, S, V

      Parallel = ParEnv % PEs > 1

      IF ( .NOT. Parallel ) THEN
        M  => A
        Mx => x
        Mb => b
        Mr => r
      ELSE
        CALL ParallelUpdateSolve( A,x,r )
        M => ParallelMatrix( A, Mx, Mb, Mr )
      END IF
      
      n = M % NumberOfRows
      InvLevel = 1 + Solver % MultiGridTotal - Level

!      Smoothing iterative method:
!      ---------------------------
      IterMethod = ListGetString( Solver % Values, 'MG Smoother', Found )
      
      IF ( .NOT. Found ) THEN
        IterMethod = ListGetString( Solver % Values, &
            'Linear System Iterative Method', Found )
      END IF
      IF ( .NOT. Found ) THEN
        IF( DOFs == 1) THEN
          IterMethod = 'sgs'
        ELSE
          IterMethod = 'bsgs'
        END IF
      END IF

      IF(Presmooth) THEN
        Iters => ListGetIntegerArray( Solver % Values,'MG Pre Smoothing Iterations',Found)
        IF(Found) THEN
          Rounds = Iters(MIN(InvLevel,SIZE(Iters)))
        ELSE        
          Rounds = 1
        END IF
      ELSE
        Iters => ListGetIntegerArray( Solver % Values,'MG Post Smoothing Iterations',Found)
        IF(Found) THEN
          Rounds = Iters(MIN(InvLevel,SIZE(Iters)))
        ELSE        
          Rounds = 1
        END IF
      END IF

      RNorm = MGnorm( n, Mr ) 
      IF ( Rounds <= 0 ) RETURN

      SELECT CASE( IterMethod )
      CASE( 'cg' )
        ALLOCATE( Z(n), Pr(n), Q(n) )
        
      CASE( 'bicgstab' )
        ALLOCATE( Pr(n), Ri(n), T(n), T1(n), T2(n), S(n), V(n) )
      END SELECT
    
      IF( IterMethod(1:1) == 'w') THEN
        TmpArray => ListGetConstRealArray(Solver % Values,'MG Smoother Relaxation Factor')
        IF( ASSOCIATED(TmpArray)) THEN
          Omega = TmpArray(MIN(InvLevel,SIZE(TmpArray,1)),1)
        ELSE
          Omega = 1.0d0
        END IF
      END IF

      SELECT CASE( IterMethod )
      CASE( 'jacobi' ) 
        CALL Jacobi( n, A, M, Mx, Mb, Mr, Rounds )
        
      CASE( 'gs' )                         
        CALL GS( n, A, M, Mx, Mb, Mr, Rounds )

      CASE( 'bgs' )                         
        CALL GS( n, A, M, Mx, Mb, Mr, Rounds )
       
      CASE( 'sgs' )                                     
        CALL SGS( n, A, M, Mx, Mb, Mr, Rounds)

      CASE( 'bsgs' )                                     
        CALL BSGS( n, A, M, Mx, Mb, Mr, DOFs, Rounds)
       
      CASE( 'wjacobi' )                                     
        CALL SmoothedJacobi( n, A, M, Mx, Mb, Mr, Omega, Rounds )
        
      CASE( 'wgs' )                                   
        CALL SmoothedGS( n, A, M, Mx, Mb, Mr, Omega, Rounds )
        
      CASE( 'wsgs' )                                     
        CALL SmoothedSGS( n, A, M, Mx, Mb, Mr, Omega, Rounds)
        
      CASE( 'csgs' )                                     
        CALL CSGS( n, A, M, Mx, Mb, Mr, Rounds)
        
      CASE( 'cjacobi' )                                     
        CALL CJacobi( n, A, M, Mx, Mb, Mr, Rounds )
        
      CASE( 'psgs' )                                     
        CALL PostSGS( n, A, M, Mx, Mb, Mr, CF, Rounds)

      CASE( 'cg' )
        CALL CG( n, A, M, Mx, Mb, Mr, Rounds )

      CASE( 'ccg' )
        CALL CCG( n, A, M, Mx, Mb, Mr, Rounds )
       
      CASE( 'bicgstab' )
       CALL BiCG( n, A, M, Mx, Mb, Mr, Rounds )

      CASE( 'uzawa' )                                   
        CALL Uzawa( n, A, M, Mx, Mb, Mr, Rounds )

      CASE( 'vanka' )                                   
        CALL Vanka( n, A, M, Mx, Mb, Mr, Rounds )

      CASE( 'test gs' )                                   
        CALL TestGS( n, A, M, Mx, Mb, Mr, Rounds )

      CASE DEFAULT
        CALL Warn('MGSmooth','Unknown smoother, using Jacobi')
        CALL Jacobi( n, A, M, Mx, Mb, Mr, Rounds )
      END SELECT

      CALL MGmv( A, x, r, .TRUE. )
      r = b - r
      IF ( Parallel ) Mr = Mb - Mr
     
      RNorm = MGnorm( n, Mr ) 

      SELECT CASE( Itermethod )
      CASE( 'cg' )
        DEALLOCATE( Z, Pr, Q)
        
      CASE( 'bicgstab' )
        DEALLOCATE( Pr, Ri, T, T1, T2, S, V )
      END SELECT

!------------------------------------------------------------------------------

    CONTAINS 

!------------------------------------------------------------------------------
      FUNCTION MGnorm( n, x ) RESULT(s)
!------------------------------------------------------------------------------
        INTEGER :: n
        REAL(KIND=dp) :: s,x(:)
!------------------------------------------------------------------------------
        IF ( .NOT. Parallel ) THEN
          s = SQRT( DOT_PRODUCT( x(1:n), x(1:n) ) )
        ELSE
          s = ParallelNorm( n, x )
        END IF
!------------------------------------------------------------------------------
      END FUNCTION MGnorm
!------------------------------------------------------------------------------

      
!------------------------------------------------------------------------------
      FUNCTION MGdot( n, x, y ) RESULT(s)
!------------------------------------------------------------------------------
        INTEGER :: n
        REAL(KIND=dp) :: s,x(:),y(:)
!------------------------------------------------------------------------------
        IF ( .NOT. Parallel ) THEN
          s = DOT_PRODUCT( x(1:n), y(1:n) )
        ELSE
          s = ParallelDot( n, x, y )
        END IF
!------------------------------------------------------------------------------
      END FUNCTION MGdot
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
    FUNCTION MGCdot( n, x, y ) RESULT(s)
!------------------------------------------------------------------------------
       INTEGER :: n
       COMPLEX(KIND=dp) :: s,x(:),y(:)
!------------------------------------------------------------------------------
       s = DOT_PRODUCT( x(1:n), y(1:n) )
!------------------------------------------------------------------------------
    END FUNCTION MGCdot
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE MGmv( A, x, b, Update )
!------------------------------------------------------------------------------
        REAL(KIND=dp) :: x(:), b(:)
        LOGICAL, OPTIONAL :: Update
        TYPE(Matrix_t), POINTER :: A
!------------------------------------------------------------------------------
        IF ( .NOT. Parallel ) THEN
          CALL CRS_MatrixVectorMultiply( A, x, b )
        ELSE
          IF ( PRESENT( Update ) ) THEN
            CALL ParallelMatrixVector( A,x,b,Update )
          ELSE
            CALL ParallelMatrixVector( A,x,b )
          END IF
        END IF
!------------------------------------------------------------------------------
      END SUBROUTINE MGmv
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE MGCmv( A, x, b, Update )
!------------------------------------------------------------------------------
        COMPLEX(KIND=dp) :: x(:), b(:)
        LOGICAL, OPTIONAL :: Update
        TYPE(Matrix_t), POINTER :: A
!------------------------------------------------------------------------------
        CALL CRS_ComplexMatrixVectorMultiply( A, x, b )
!------------------------------------------------------------------------------
      END SUBROUTINE MGCmv
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE Jacobi( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,n
!------------------------------------------------------------------------------
        DO i=1,Rounds
          CALL MGmv( A, x, r )
          r(1:n) = b(1:n) - r(1:n)
          x(1:n) = x(1:n) + r(1:n) / M % Values(M % Diag(1:n))
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE Jacobi
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE SmoothedJacobi( n, A, M, x, b, r, w, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: w, x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,n
!------------------------------------------------------------------------------
        DO i=1,Rounds
          CALL MGmv( A, x, r )
          r(1:n) = b(1:n) - r(1:n)
          x(1:n) = x(1:n) + w * r(1:n) / M % Values(M % Diag)
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE SmoothedJacobi
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE CJacobi( n, A, M, rx, rb, rr, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: n,Rounds
        REAL(KIND=dp) :: rx(:),rb(:),rr(:)
!------------------------------------------------------------------------------
        COMPLEX(KIND=dp) :: x(n/2),b(n/2),r(n/2)
        INTEGER :: i,j,diag
!------------------------------------------------------------------------------

        DO i=1,n/2
          r(i) = CMPLX( rr(2*i-1), rr(2*i),KIND=dp )
          x(i) = CMPLX( rx(2*i-1), rx(2*i),KIND=dp )
          b(i) = CMPLX( rb(2*i-1), rb(2*i),KIND=dp )
        END DO
        
        DO j=1,Rounds
          CALL MGCmv( A, x, r )
          r(1:n/2) = b(1:n/2) - r(1:n/2)
          
          DO i=1,n/2
            diag = M % diag(2*i-1)
            r(i) = r(i) / CMPLX( M % Values(diag), M % Values(diag+1),KIND=dp)
            x(i) = x(i) + r(i)
          END DO
        END DO
        
        DO i=1,n/2
          rr(2*i-1) =  REAL( r(i) )
          rr(2*i-0) =  AIMAG( r(i) )
          rx(2*i-1) =  REAL( x(i) )
          rx(2*i-0) =  AIMAG( x(i) )
          rb(2*i-1) =  REAL( b(i) )
          rb(2*i-0) =  AIMAG( b(i) )
        END DO

!------------------------------------------------------------------------------
      END SUBROUTINE CJacobi
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE GS( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,j,k,n
        REAL(KIND=dp) :: s
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
!------------------------------------------------------------------------------
     
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values
                
        DO k=1,Rounds
          
          DO i=1,n
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE GS
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE BGS( n, A, M, x, b, r, DOFs, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: DOFs, Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,j,k,n,id,dof
        REAL(KIND=dp) :: s(DOFs)
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
!------------------------------------------------------------------------------
     
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values
                
        DO k=1,Rounds          
          DO i=1,n / DOFs
            s = 0.0d0
            DO dof=1,DOFs
              id = (i-1)*DOFs + dof
              DO j=Rows(id),Rows(id+1)-1
                s(dof) = s(dof) + x(Cols(j)) * Values(j)
              END DO
            END DO
            DO dof=1,DOFs
              id = (i-1)*DOFs + dof             
              r(id) = (b(id)-s(dof)) / M % Values(M % Diag(id))
              x(id) = x(id) + r(id)
            END DO
          END DO
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE BGS
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
      SUBROUTINE SmoothedGS( n, A, M, x, b, r, w, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: w, x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,j,k,n
        REAL(KIND=dp) :: s
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
!------------------------------------------------------------------------------
     
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values

       
        DO k=1,Rounds
          DO i=1,n
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + w * r(i)
          END DO
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE SmoothedGS
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE SGS( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
        INTEGER :: i,j,k,n
        REAL(KIND=dp) :: s
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
        
        Rows   => M % Rows
        Cols   => M % Cols
        Values => M % Values
        
        DO k=1,Rounds
          DO i=1,n
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
          
          DO i=n,1,-1
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
        END DO
      END SUBROUTINE SGS
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Block Symmetric Gauss Seidel 
!------------------------------------------------------------------------------
      SUBROUTINE BSGS( n, A, M, x, b, r, DOFs, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: DOFs, Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
        INTEGER :: i,j,k,n,id,dof
        REAL(KIND=dp) :: s(DOFs)
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
        
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values

        DO k=1,Rounds
          DO i=1,n/DOFs
            s = 0.0d0
            DO dof = 1,DOFs
              id = (i-1)*DOFs + dof
              DO j=Rows(id),Rows(id+1)-1
                s(dof) = s(dof) + x(Cols(j)) * Values(j)
              END DO
            END DO
            DO dof = 1,DOFs
              id = (i-1)*DOFs + dof
              r(id) = (b(id)-s(dof)) / M % Values(M % Diag(id))
              x(id) = x(id) + r(id)
            END DO
          END DO
          
          DO i=n/DOFs,1,-1
            s = 0.0d0
            DO dof = 1,DOFs
              id = (i-1)*DOFs + dof
              DO j=Rows(id),Rows(id+1)-1
                s(dof) = s(dof) + x(Cols(j)) * Values(j)
              END DO
            END DO
            DO dof = 1,DOFs
              id = (i-1)*DOFs + dof
              r(id) = (b(id)-s(dof)) / M % Values(M % Diag(id))
              x(id) = x(id) + r(id)
            END DO
          END DO
        END DO
      END SUBROUTINE BSGS
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE SmoothedSGS( n, A, M, x, b, r, w, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: w, x(:),b(:),r(:)
        INTEGER :: i,j,k,n
        REAL(KIND=dp) :: s
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
        
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values
        
        DO k=1,Rounds
          DO i=1,n
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + w * r(i)
          END DO
          
          DO i=n,1,-1
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + w * r(i)
          END DO
        END DO
      END SUBROUTINE SmoothedSGS
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE CSGS( n, A, M, rx, rb, rr, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: rx(:),rb(:),rr(:)
        INTEGER :: i,j,k,n,l
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
        COMPLEX(KIND=dp) :: r(n/2),b(n/2),x(n/2),s
        
        DO i=1,n/2
          r(i) = CMPLX( rr(2*i-1), rr(2*i), KIND=dp )
          x(i) = CMPLX( rx(2*i-1), rx(2*i), KIND=dp )
          b(i) = CMPLX( rb(2*i-1), rb(2*i), KIND=dp )
        END DO
        
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values
        
        DO k=1,Rounds
          DO i=1,n/2
            s = 0.0d0
            
            DO j=Rows(2*i-1),Rows(2*i)-1,2             
              s = s + x((Cols(j)+1)/2) * CMPLX( Values(j), -Values(j+1),KIND=dp)
            END DO
            
            j = A % Diag(2*i-1)
            r(i) = (b(i)-s) / CMPLX( Values(j), -Values(j+1),KIND=dp )
            x(i) = x(i) + r(i)
          END DO
          
          DO i=n/2,1,-1
            s = 0.0d0
            
            DO j=Rows(2*i-1),Rows(2*i)-1,2             
              s = s + x((Cols(j)+1)/2) * CMPLX( Values(j), -Values(j+1),KIND=dp)
            END DO
            
            j = A % Diag(2*i-1)
            r(i) = (b(i)-s) / CMPLX( Values(j), -Values(j+1),KIND=dp )
            x(i) = x(i) + r(i)
          END DO
          
        END DO
        
        DO i=1,n/2
          rr(2*i-1) =  REAL( r(i) )
          rr(2*i-0) =  AIMAG( r(i) )
          rx(2*i-1) =  REAL( x(i) )
          rx(2*i-0) =  AIMAG( x(i) )
          rb(2*i-1) =  REAL( b(i) )
          rb(2*i-0) =  AIMAG( b(i) )
        END DO
        
      END SUBROUTINE CSGS
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE PostSGS( n, A, M, x, b, r, f, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        INTEGER, POINTER :: f(:)
        REAL(KIND=dp) :: x(:),b(:),r(:)
        INTEGER :: i,j,k,n
        REAL(KIND=dp) :: s
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
        
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values
        
        DO k=1,Rounds
          
          DO i=1,n
            IF(f(i) /= 0) CYCLE
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
          DO i=1,n
            IF(f(i) == 0) CYCLE
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
          
          DO i=n,1,-1
            IF(f(i) /= 0) CYCLE
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
          DO i=n,1,-1
            IF(f(i) == 0) CYCLE
            s = 0.0d0
            DO j=Rows(i),Rows(i+1)-1
              s = s + x(Cols(j)) * Values(j)
            END DO
            r(i) = (b(i)-s) / M % Values(M % Diag(i))
            x(i) = x(i) + r(i)
          END DO
          
        END DO
      END SUBROUTINE PostSGS
!------------------------------------------------------------------------------



!------------------------------------------------------------------------------
      SUBROUTINE CG( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A,M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
        REAL(KIND=dp) :: alpha,rho,oldrho
!------------------------------------------------------------------------------
        INTEGER :: i,n
!------------------------------------------------------------------------------
        CALL MGmv( A, x, r )
        r(1:n) = b(1:n) - r(1:n)
        
        DO i=1,Rounds
          Z(1:n) = r(1:n)
          CALL CRS_LUSolve( n, M, Z )
          rho = MGdot( n, r, Z )
          
          IF ( i == 1 ) THEN
            Pr(1:n) = Z(1:n)
          ELSE
            Pr(1:n) = Z(1:n) + rho * Pr(1:n) / oldrho
          END IF
          
          CALL MGmv( A, Pr, Q )
          alpha  = rho / MGdot( n, Pr, Q )
          oldrho = rho
          
          x(1:n) = x(1:n) + alpha * Pr(1:n)
          r(1:n) = r(1:n) - alpha * Q(1:n)
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE CG
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE CCG( n, A, M, rx, rb, rr, Rounds )
!------------------------------------------------------------------------------
        INTEGER :: i,n, Rounds
        TYPE(Matrix_t), POINTER :: A,M
        REAL(KIND=dp) :: rx(:),rb(:),rr(:)
        COMPLEX(KIND=dp) :: alpha,rho,oldrho
        COMPLEX(KIND=dp) :: r(n/2),b(n/2),x(n/2)
        COMPLEX(KIND=dp) :: Z(n), Pc(n), Q(n)
!------------------------------------------------------------------------------
        DO i=1,n/2
          r(i) = CMPLX( rr(2*i-1), rr(2*i),KIND=dp )
          x(i) = CMPLX( rx(2*i-1), rx(2*i),KIND=dp )
          b(i) = CMPLX( rb(2*i-1), rb(2*i),KIND=dp )
        END DO
        
        CALL MGCmv( A, x, r )
        r(1:n/2) = b(1:n/2) - r(1:n/2)
        
        DO i=1,Rounds
          Z(1:n/2) = r(1:n/2)
          CALL CRS_ComplexLUSolve( n, M, Z )
          rho = MGCdot( n/2, r, Z )
          
          IF ( i == 1 ) THEN
            Pc(1:n/2) = Z(1:n/2)
          ELSE
            Pc(1:n/2) = Z(1:n/2) + rho * Pc(1:n/2) / oldrho
          END IF
          
          CALL MGCmv( A, Pc, Q )
          alpha  = rho / MGCdot( n/2, Pc, Q )
          oldrho = rho
          
          x(1:n/2) = x(1:n/2) + alpha * Pc(1:n/2)
          r(1:n/2) = r(1:n/2) - alpha * Q(1:n/2)
        END DO

        DO i=1,n/2
          rr(2*i-1) =  REAL( r(i) )
          rr(2*i-0) =  AIMAG( r(i) )
          rx(2*i-1) =  REAL( x(i) )
          rx(2*i-0) =  AIMAG( x(i) )
          rb(2*i-1) =  REAL( b(i) )
          rb(2*i-0) =  AIMAG( b(i) )
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE CCG
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE Uzawa( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        USE LinearAlgebra

        TYPE(Matrix_t), POINTER :: A,M
        INTEGER :: Rounds, n
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,j,k,l,t,k0,k1,dofs,nn,elem,it
        INTEGER, POINTER :: ind(:)
        TYPE(Variable_t), POINTER :: Var
        REAL(KIND=dp) :: st_norm
        REAL(KIND=dp), ALLOCATABLE :: px(:), pb(:), pr(:)
!------------------------------------------------------------------------------

         Var => VariableGet( Mesh % Variables,  &
               CurrentModel % Solver % Variable % Name, ThisOnly=.TRUE. )

         dofs = Var % DOFs

         ALLOCATE( px(n), pr(n), pb(n) )

         CALL MGMv( A,x,r )
         r(1:n) = b(1:n) - r(1:n)
         st_norm = SQRT(SUM(r**2))

IF ( Rounds == 0 ) RETURN

DO it=1,200
         k = 0
         DO i=dofs,n,dofs
           k = k + 1
           px(k) = x(i) 
           pb(k) = b(i) 
           pr(k) = r(i) 
         END DO

         k = 0
         r = b
         DO i=1,n
           IF ( MOD(i,dofs)==0 ) CYCLE
           DO j=A % Rows(i),A % Rows(i+1)-1
             IF ( MOD(A % Cols(j),dofs)==0 ) CYCLE
             r(i) = r(i) - A % Values(j)*x(A % Cols(j))
           END DO
         END DO

         DO i=1,n
           IF ( MOD(i,dofs)==0 ) CYCLE
           r(i) = r(i)/(rphi*A % Values(A % Diag(i)))
         END DO


         k = 0
         DO i=dofs,n,dofs
           k = k+1
           DO j=A % Rows(i),A % Rows(i+1)-1
             IF ( MOD(A % Cols(j),dofs)==0 ) CYCLE
             pb(k) = pb(k) - A % Values(j)*x(A % Cols(j))
             pb(k) = pb(k) - A % Values(j)*r(A % Cols(j))
           END DO
         END DO

         CALL BiCGUzawa( k,A,M,px,pb,pr,Rounds, st_norm*1.d-2 )
         k = 0
         DO i=dofs,n,dofs
           k = k + 1
           x(i) = px(k)
         END DO

         px = x(1:n)
         k = 0
         DO i=1,n
           IF ( MOD(i,dofs)==0 ) CYCLE
           k = k+1
           px(i) = px(i) + r(i)
         END DO

         k = 0
         DO i=1,n
           IF ( MOD(i,dofs)==0 ) CYCLE
           k = k+1
           DO j=A % Rows(i)+dofs-1,A % Rows(i+1)-1,dofs
             px(i) = px(i) - A % Values(j)*x(A % Cols(j)) / &
                   (rphi*A % Values(A % Diag(i)))
           END DO
         END DO
         x(1:n) = px

         CALL MGMv( A,x,r )
         r(1:n) = b(1:n) - r(1:n)
         PRINT*,'AAAAAAAAAA: ', it, Rounds, st_norm*0.5_dp, SQRT(SUM(r**2))

         IF ( it > Rounds ) THEN
           IF ( SQRT(SUM(r**2)) < 0.5_dp*st_norm ) EXIT
         END IF
END DO
!------------------------------------------------------------------------------
      END SUBROUTINE Uzawa
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
     SUBROUTINE UzawaMv( A, x, b )
!------------------------------------------------------------------------------
        TYPE(Matrix_t) :: A
        INTEGER :: i,j,k,n,q,dofs=3
        REAL(KIND=dp) :: x(:),b(:)
        REAL(KIND=dp), ALLOCATABLE :: temp(:)
!------------------------------------------------------------------------------
         n = A % NumberOfRows
         ALLOCATE(temp(n))

         b = 0._dp
         temp = 0._dp

         DO i=1,n
           IF ( MOD(i,dofs)==0 ) CYCLE
           DO j=A % Rows(i)+dofs-1,A % Rows(i+1)-1,dofs
             q = A % Cols(j)/dofs
             temp(i) = temp(i) + A % Values(j)*x(q)
           END DO
         END DO

         DO i=1,n
           IF ( MOD(i,dofs)==0 ) CYCLE
           temp(i) = temp(i)/(rphi*A % Values(A % Diag(i)))
         END DO

         k = 0
         DO i=dofs,n,dofs
           k = k + 1
           DO j=A % Rows(i),A % Rows(i+1)-1
             IF ( MOD(A % Cols(j),dofs)==0 ) CYCLE
             b(k) = b(k) - A % Values(j)*temp(A % Cols(j))
           END DO
         END DO

         k = 0
         DO i=dofs,n,dofs
           k = k + 1
           DO j=A % Rows(i)+dofs-1,A % Rows(i+1)-1,dofs
             q = A % Cols(j)/dofs
             b(k) = b(k) + A % Values(j)*x(q)
           END DO
         END DO
!------------------------------------------------------------------------------
     END SUBROUTINE UzawaMv
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
     SUBROUTINE UzawaPcond( A, b )
!------------------------------------------------------------------------------
        TYPE(Matrix_t) :: A
        REAL(KIND=dp) :: b(:)
!------------------------------------------------------------------------------
       REAL(KIND=dp) :: s
       INTEGER :: i,k,dofs=3,n

        n = A % NumberOfRows
        k = 0
        DO i=dofs,n,dofs
          k = k + 1
          s = A % Values(A % Diag(i))
          IF ( ABS(s) > 100*AEPS ) b(k) = b(k) / s
        END DO
!------------------------------------------------------------------------------
     END SUBROUTINE UzawaPcond
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE BiCGUzawa( n, A, M, x, b, r, Rounds, reps )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A,M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,n
        REAL(KIND=dp) :: alpha,beta,omega,rho,oldrho, reps
        REAL(KIND=dp), ALLOCATABLE :: Pr(:), Ri(:), V(:), S(:), T(:), T1(:), T2(:)
!------------------------------------------------------------------------------
        ALLOCATE( Pr(n), Ri(n), T(n), T1(n), T2(n), S(n), V(n) )
        PR = 0; Ri=0; T=0; T1=0; T2=0; S=0; V=0

        CALL UzawaMv( A, x, r )
        r(1:n) = b(1:n) - r(1:n)
        
        Ri(1:n) = r(1:n)
        Pr(1:n) = 0
        V(1:n) = 0
        omega  = 1
        alpha  = 0
        oldrho = 1
        
        DO i=1,200
          rho = MGdot( n, r, Ri )
          
          beta = alpha * rho / ( oldrho * omega )
          Pr(1:n) = r(1:n) + beta * (Pr(1:n) - omega*V(1:n))
          
          V(1:n) = Pr(1:n)
          CALL UzawaPcond( A,V )
          T1(1:n) = V(1:n)
          CALL UzawaMv( A, T1, V )

          alpha = rho / MGdot( n, Ri, V )
          S(1:n) = r(1:n) - alpha * V(1:n)
          
          T(1:n) = S(1:n)
          CALL UzawaPcond( A,T )
          T2(1:n) = T(1:n)
          CALL UzawaMv( A, T2, T )

          omega = MGdot( n,T,S ) / MGdot( n,T,T )
          oldrho = rho
          r(1:n) = S(1:n) - omega*T(1:n)
          x(1:n) = x(1:n) + alpha*T1(1:n) + omega*T2(1:n)

          CALL UzawaMv( A, x, t1 )
          t1(1:n) = b(1:n) - t1(1:n)
          IF ( SQRT(SUM(t1**2)) < reps ) EXIT
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE BiCGUzawa
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE BiCG( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A,M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,n
        REAL(KIND=dp) :: alpha,beta,omega,rho,oldrho
!------------------------------------------------------------------------------
        IF ( Rounds <= 0 ) RETURN

        CALL MGmv( A, x, r )
        r(1:n) = b(1:n) - r(1:n)
        
        Ri(1:n) = r(1:n)
        Pr(1:n) = 0
        V(1:n) = 0
        omega  = 1
        alpha  = 0
        oldrho = 1
        
        DO i=1,Rounds
          rho = MGdot( n, r, Ri )
          
          beta = alpha * rho / ( oldrho * omega )
          Pr(1:n) = r(1:n) + beta * (Pr(1:n) - omega*V(1:n))
          
          V(1:n) = Pr(1:n)
          CALL CRS_LUSolve( n, M, V )
          T1(1:n) = V(1:n)
          CALL MGmv( A, T1, V )

          alpha = rho / MGdot( n, Ri, V )
          
          S(1:n) = r(1:n) - alpha * V(1:n)
          
          T(1:n) = S(1:n)
          CALL CRS_LUSolve( n, M, T )
          T2(1:n) = T(1:n)
          CALL MGmv( A, T2, T )
          omega = MGdot( n,T,S ) / MGdot( n,T,T )

          oldrho = rho
          r(1:n) = S(1:n) - omega*T(1:n)
          x(1:n) = x(1:n) + alpha*T1(1:n) + omega*T2(1:n)
        END DO
!------------------------------------------------------------------------------
      END SUBROUTINE BiCG
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
      SUBROUTINE Vanka( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
USE linearalgebra
        TYPE(Matrix_t), POINTER :: A,M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,j,k,l,n,t,nn,k1,k2,elem,nsize,it
        REAL(KIND=dp) :: s

        LOGICAL :: NS

        TYPE(Variable_t), POINTER :: Var
        TYPE(Element_t), POINTER :: element

        INTEGER, ALLOCATABLE :: ind(:)
        REAL(KIND=dp), ALLOCATABLE :: AL(:,:), h(:)
!------------------------------------------------------------------------------
        Var => VariableGet( Mesh % Variables, &
                 CurrentModel % Solver % Variable % Name, ThisOnly=.TRUE. )

        NS = .FALSE.
        IF ( Var % Name=='flow solution' ) NS=.TRUE.
        
        elem = Mesh % NumberOfBulkElements
        nsize = Mesh % MaxElementDOFs*DOFs
        ALLOCATE( AL(nsize,nsize), ind(nsize), h(nsize) )
        AL = 0._dp

        DO it=1,Rounds
          DO t=1,elem
            element => Mesh % Elements(t)
            IF ( ANY(Var % Perm(Element % NodeIndexes)<=0) ) CYCLE

            nn = Element % TYPE % NumberOfnodes
            nsize = nn*DOFs

            k = 0
            DO i=1,nn
              l = Element % Nodeindexes(i)
              DO j=1,DOFs
                k = k +1
                ind(k) = DOFs*(Var % Perm(l)-1)+j
              END DO
            END DO

            DO i=1,nsize
              j = ind(i)
              s = 0._dp
              DO k=A % Rows(j),A % Rows(j+1)-1
                s = s + A % Values(k)*x(A % Cols(k))
              END DO
              h(i) = b(j)-s
            END DO

            IF (NS) THEN
              DO i=1,nsize
                DO j=1,nsize
                  AL(i,j) = CRS_GetMatrixElement( A,ind(i),ind(j) )
                END DO
              END DO
              CALL SolveLinSys( nsize,SIZE(AL,1),AL,h )
            ELSE
              h(1:nsize)=h(1:nsize)/A % Values(A % Diag(ind(1:nsize)))
            END IF

            x(ind(1:nsize))=x(ind(1:nsize))+h(1:nsize)
          END DO
        END DO

        DEALLOCATE( AL, h, ind )
!------------------------------------------------------------------------------
      END SUBROUTINE Vanka
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
      SUBROUTINE SolveLinSys( N,LDa,A,x )
!------------------------------------------------------------------------------
        INTEGER  N,IPIV(N),LDa,info
        DOUBLE PRECISION  A(LDa,*),x(n)

        IF ( N .LE. 0 ) RETURN
        CALL DGETRF( N,N,A,LDa,IPIV,INFO )
        CALL DGETRS( 'N',N,1,A,LDa,IPIV,X,N,INFO )
!------------------------------------------------------------------------------
      END SUBROUTINE SolveLinSys
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Gauss-Seidel for testing purposes
!------------------------------------------------------------------------------
      SUBROUTINE TestGS( n, A, M, x, b, r, Rounds )
!------------------------------------------------------------------------------
        TYPE(Matrix_t), POINTER :: A, M
        INTEGER :: Rounds
        REAL(KIND=dp) :: x(:),b(:),r(:)
!------------------------------------------------------------------------------
        INTEGER :: i,j,k,l,n,o,nsize
        REAL(KIND=dp) :: s
        INTEGER, POINTER :: Cols(:),Rows(:)
        REAL(KIND=dp), POINTER :: Values(:)
!------------------------------------------------------------------------------
     
        n = A % NumberOfRows
        Rows   => A % Rows
        Cols   => A % Cols
        Values => A % Values
        
        PRINT *,'TestGS: Starting',&
            ASSOCIATED(Rows),ASSOCIATED(Cols),ASSOCIATED(Values),ASSOCIATED(M % diag)
        PRINT *,'TestGS: Sizes',&
            SIZE(Cols),SIZE(Values),SIZE(Rows)-1,SIZE(M % diag),SIZE(b),SIZE(r)
        PRINT *,'TestGS: MinVal',&
            MINVAL(Rows),MINVAL(Cols),MINVAL(Values),MINVAL(M % diag)
        PRINT *,'TestGS: MaxVal',&
            MAXVAL(Rows),MAXVAL(Cols),MAXVAL(Values),MAXVAL(M % diag)
        
        nsize = SIZE(Cols)
        
        
        DO k=1,Rounds
          
          DO i=1,n
            s = 0.0d0
            
            DO j=Rows(i),Rows(i+1)-1
              IF(j<1 .OR. j>nsize) THEN
                PRINT *,'TestGs A:',i,j
              END IF
              o = Cols(j)
              IF(o<1 .OR. o>n) THEN
                PRINT *,'TestGs B:',i,j,o
              END IF
              s = s + x(o) * Values(j)
            END DO
            
            l = M % diag(i)
            IF(l<1 .OR. l>nsize) THEN
              PRINT *,'TestGs C:',i,j,o,l
            END IF
            r(i) = (b(i)-s) / M % Values(l)
            x(i) = x(i) + r(i)
          END DO
        END DO
        
        PRINT *,'TestGS: Finished'
!------------------------------------------------------------------------------
      END SUBROUTINE TestGS
!------------------------------------------------------------------------------

    END FUNCTION MGSmooth


!------------------------------------------------------------------------------
! NOTE: The following could rather be placed in a new module called 
!       ClusteringMethods or something. 
!       This is here temporarely to avoid changes in make scripts.
!------------------------------------------------------------------------------

  
!------------------------------------------------------------------------------
! Create the clusters 
!------------------------------------------------------------------------------

  SUBROUTINE ChooseClusterNodes(Amat, Solver, Components, EliminateDir, CF)
    
    TYPE(Matrix_t), POINTER  :: Amat
    TYPE(solver_t), TARGET :: Solver
    INTEGER :: Components
    LOGICAL :: EliminateDir
    INTEGER, POINTER :: CF(:)

    INTEGER :: matsize, nodesize, Component1
    LOGICAL, POINTER :: Bonds(:), Fixed(:)
    INTEGER, POINTER :: Cols(:),Rows(:)
    LOGICAL :: GotIt

    Component1 = 1
    IF(Components > 1) THEN
      Component1 = ListGetInteger(Solver % Values,'MG Determining Component',&
          GotIt,minv=1,maxv=Components)
      IF(.NOT. GotIt) Component1 = 1
    END IF

    Rows => Amat % Rows
    Cols => Amat % Cols
    matsize = Amat % NumberOfRows
    nodesize = matsize / Components
    ALLOCATE( Bonds(SIZE(Amat % Cols)), Fixed(nodesize), CF(nodesize) )

    CALL CMGBonds(Amat, Bonds, Fixed, Components,Component1)      
    CALL CMGClusterForm(Amat, Bonds, Fixed, Components, Component1, CF)

    DEALLOCATE(Bonds, Fixed)

    IF(.FALSE.) CALL Info('ChooseClusterNodes','Clusters chosen')

  CONTAINS


!------------------------------------------------------------------------------
! Mark the strong connections based on the relative absolute magnitude of the 
! matrix element.
!------------------------------------------------------------------------------

    SUBROUTINE CMGBonds(Amat, Bonds, Fixed, Components, Component1)
      
      LOGICAL, POINTER :: Bonds(:), Fixed(:)
      TYPE(Matrix_t), POINTER  :: Amat
      INTEGER :: Components, Component1
      
      REAL(KIND=dp) :: StrongLim
      INTEGER :: nods, cnods, matsize, nodesize, maxconn, newbonds, MaxConns, MinConns
      INTEGER :: i,j,k,cj,ci,no,elimnods,strongbonds,nodeind,matind
      INTEGER, POINTER :: Cols(:),Rows(:),localind(:)
      LOGICAL :: ElimDir, Choose, GotIt
      REAL(KIND=dp), POINTER :: Values(:), measures(:)
      REAL(KIND=dp) :: maxbond, diagbond, dirlim, meas
      
      StrongLim = ListGetConstReal(Solver % Values,'MG Strong Connection Limit',GotIt)
      IF(.NOT. GotIt) StrongLim = 0.06
      MaxConns = ListGetInteger(Solver % Values,'MG Strong Connection Maximum',GotIt)
      MinConns = ListGetInteger(Solver % Values,'MG Strong Connection Minimum',GotIt)
      
      ElimDir = EliminateDir
      DirLim = ListGetConstReal(Solver % Values,'MG Eliminate Dirichlet Limit',GotIt)
      IF(.NOT. GotIt) DirLim = 1.0d-8      
      
      matsize = Amat % NumberOfRows
      Rows   => Amat % Rows
      Cols   => Amat % Cols
      Values => Amat % Values    
      nodesize = matsize / Components
      
      maxconn = 0
      DO matind=1,matsize
        maxconn = MAX(maxconn,Rows(matind+1)-Rows(matind))
      END DO
      ALLOCATE(measures(maxconn),localind(maxconn))
      
      Bonds = .FALSE.
      Fixed = .FALSE.
      strongbonds = 0
      elimnods = 0
      
      DO nodeind=1,nodesize
        
        matind = (nodeind-1)*Components + Component1
        no = 0
        maxbond = 0.0d0
        
        DO j=Rows(matind),Rows(matind+1)-1
          cj = Cols(j)
          IF( MOD(matind, Components) /= MOD(cj, Components) ) CYCLE
          
          IF(cj /= matind ) THEN
            no = no + 1
            localind(no) = j
            measures(no) = ABS( Values(j) )
          ELSE
            diagbond = ABS(Values(j))
          END IF
        END DO
        
        IF(no > 0) maxbond = MAXVAL( measures(1:no) )
        
        ! Mark Dirichlet nodes in order to favor boundaries in future
        IF( ElimDir .AND. maxbond < DirLim * diagbond ) THEN
          Fixed(nodeind) = .TRUE.
          elimnods = elimnods + 1
          CYCLE
        END IF
        
        IF(no == 0) CYCLE
        Choose = .FALSE.
        
        ! Check whether the tentative list would give the right number anaway
        IF(MaxConns > 0 .OR. MinConns > 0) THEN
          newbonds = 0
          DO i=1,no
            IF( measures(i) >= Stronglim * maxbond) newbonds = newbonds + 1
          END DO
          IF(MaxConns > 0 .AND. newbonds > MaxConns) Choose = .TRUE.
          IF(MinConns > 0 .AND. newbonds < MinConns) Choose = .TRUE.
        END IF
        
        IF(.NOT. Choose) THEN
          newbonds = 0
          DO i=1,no
            IF( measures(i) >= StrongLim * maxbond) THEN
              newbonds = newbonds + 1
              Bonds(LocalInd(i)) = .TRUE.
            END IF
          END DO
          strongbonds = strongbonds + newbonds
        ELSE
          CALL SortR(no,LocalInd,measures)
          IF(MaxConns > 0 .AND. newbonds > MaxConns) THEN
            strongbonds = strongbonds + MaxConns
            DO i=1,MaxConns
              Bonds(LocalInd(i)) = .TRUE.
            END DO
          END IF
          
          IF(MinConns > 0 .AND. newbonds < MinConns) THEN
            no = MIN(MinConns, no)
            strongbonds = strongbonds + no
            DO i=1,no
              Bonds(LocalInd(i)) = .TRUE.
            END DO
          END IF
        END IF
      END DO
      
      DEALLOCATE(measures, localind)
      
      IF(elimnods > 0) THEN
        WRITE(Message,'(A,I8)') 'Number of eliminated nodes',elimnods
        CALL Info('CMGBonds',Message)
      END IF
      WRITE(Message,'(A,F8.3)') 'Average number of strong bonds',&
          1.0*strongbonds/nodesize
      CALL Info('CMGBonds',Message)
      
    END SUBROUTINE CMGBonds
    

    !------------------------------------------------------------------------------
    ! Creates clusters of nodes using the given list of strong connections. 
    ! Only nodes assigned by the Cands vector may be included in the 
    ! clusters - others are ignored. The subroutine returns the vector CF which tells
    ! to which cluster each node belongs to.
    !------------------------------------------------------------------------------
    
    SUBROUTINE CMGClusterForm(Amat, Bonds, Fixed, Components, Component1, CF)
      
      TYPE(Matrix_t), POINTER :: Amat
      INTEGER :: Components, Component1
      LOGICAL :: Bonds(:), Fixed(:)
      INTEGER, POINTER :: CF(:)
      
      INTEGER :: nods, cnods    
      INTEGER :: i,j,k,l,n,k2,cj,ci,nodeci,nodecj, &
          MaxCon, MaxConInd, RefCon, cind, find, rind, &
          GatMax, anods, points, neworder, oldorder, nodesize,matsize,&
          nextind, sumcon, maxsumcon, ClusterSize, nbonds, &
          nsize, nodeind, nodeind2, matind, BoundPoints, ClusterPoints, &
          ConnectionPoints, ClusterMode, HalfSize
      INTEGER :: LocalCon(100), LocalInd(100)
      REAL(KIND=dp) :: LocalVal(100),LocalVal2(100), maxv
      INTEGER, POINTER :: Con(:)
      INTEGER, POINTER :: Cols(:),Rows(:)
      INTEGER, ALLOCATABLE :: GatLims(:), GatNos(:), ConInd(:), RevConInd(:)
      REAL(KIND=dp), POINTER :: Values(:)
      LOGICAL :: ClusterOrphans, OrphansBest, ClusterGrow, hit, GotIt
      
      
      BoundPoints = ListGetInteger(Solver % Values,'MG Boundary Priority',GotIt)
      IF(.NOT. GotIt) BoundPoints = 1
      ClusterPoints = ListGetInteger(Solver % Values,'MG Cluster Priority',GotIt)
      IF(.NOT. GotIt) ClusterPoints = MIN(1,BoundPoints+1)
      ConnectionPoints = ListGetInteger(Solver % Values,'MG Connection Priority',GotIt)
      IF(.NOT. GotIt) ConnectionPoints = 1
      ClusterSize = ListGetInteger(Solver % Values,'MG Cluster Size',GotIt)
      HalfSize = ListGetInteger(Solver % Values,'MG Cluster Half Size',GotIt)
      IF(.NOT. GotIt) HalfSize = (ClusterSize-1)/2 
      
      ! Paricularly for small clusters the orphan control seems to be important
      ClusterOrphans = ListGetLogical(Solver % Values,'MG Cluster Orphans',GotIt)
      IF(.NOT. GotIt) ClusterOrphans = .TRUE.
      OrphansBest = ListGetLogical(Solver % Values,'MG Cluster Orphans Best',GotIt)
      ClusterGrow = ListGetLogical(Solver % Values,'MG Cluster Grow',GotIt)
      
      IF(ClusterSize == 0) THEN
        ClusterMode = 0
      ELSE IF(ClusterSize <= 2) THEN
        ClusterMode = 1
      ELSE 
        ClusterMode = 2
      END IF
      
      matsize = Amat % NumberOfRows
      nodesize = matsize / Components
      Rows   => Amat % Rows
      Cols   => Amat % Cols
      Values => Amat % Values
      
      CF = 0
      ALLOCATE(Con(nodesize))
      Con = 0
      cnods = 0
      cind = 0
      
      ! Set an initial measure of importance
      DO nodeind = 1, nodesize
        IF(Fixed(nodeind)) THEN
          Con(nodeind) = 0
        ELSE
          Con(nodeind) = 1
        END IF
      END DO
      
      ! Add a point for each clustered neighbour 
      DO nodeind = 1, nodesize
        IF(CF(nodeind) > 0) THEN
          matind = Components*(nodeind-1) + Component1
          DO i=Rows(matind),Rows(matind+1)-1
            IF(.NOT. Bonds(i)) CYCLE
            ci = Cols(i)     
            nodeci = (ci-Component1) / Components + 1
            IF(.NOT. Fixed(nodeci) .AND. CF(nodeci) == 0) THEN
              Con(nodeci) = Con(nodeci) + ClusterPoints
            END IF
          END DO
        END IF
      END DO
      
      ! Add some weight if the node is connected to a Dirichlet node
      ! This way the clustering will follow the natural boundaries
      IF(BoundPoints /= 0) THEN
        DO nodeind = 1, nodesize
          IF(Fixed(nodeind)) CYCLE
          matind = Components*(nodeind-1) + Component1
          DO i=Rows(matind),Rows(matind+1)-1
            IF(.NOT. Bonds(i)) CYCLE
            ci = Cols(i)
            nodeci = (ci-Component1) / Components + 1
            IF(Fixed(nodeci)) THEN
              Con(nodeind) = Con(nodeind) + BoundPoints
            END IF
          END DO
        END DO
      END IF
      
      MaxCon = MAXVAL( Con ) 
      GatMax = 2 * MaxCon + 100
      
      ! Bookkeeping is kept on category boundaries of the points
      ALLOCATE( GatLims(GatMax), GatNos(GatMax) )
      GatLims = 0
      GatNos = 0
      
      ! Number of points in different categories 
      DO nodeind = 1, nodesize
        IF(Con(nodeind) == 0) CYCLE
        GatNos(Con(nodeind)) = GatNos(Con(nodeind)) + 1 
      END DO
      anods = SUM(GatNos)
      
      DO nodeind = 2, MaxCon
        GatLims(nodeind) = GatLims(nodeind-1) + GatNos(nodeind-1)
      END DO
      
      ALLOCATE( ConInd(nodesize), RevConInd(anods) )
      ConInd = 0
      RevConInd = 0
      
      GatNos = 0
      DO nodeind = 1, nodesize
        IF(Con(nodeind) == 0) CYCLE
        GatNos(Con(nodeind)) = GatNos(Con(nodeind)) + 1
        ConInd(nodeind) = GatNos(Con(nodeind)) + GatLims(Con(nodeind))
      END DO
      
      RevConInd = 0
      DO nodeind = 1, nodesize
        IF(Con(nodeind) == 0) CYCLE
        RevConInd(ConInd(nodeind)) = nodeind
      END DO
      
      DO WHILE( MaxCon > 0 ) 
        nodeind = RevConInd(anods)
        
        IF(ClusterSize /= 0) THEN    
          ! Assume that the cluster consists of the point with maximum weight and its
          ! closest tightly coupled neighbours.
          n = 0
          nbonds = 0
          matind = Components*(nodeind-1)+Component1
          DO j=Rows(matind),Rows(matind+1)-1
            
            IF(Bonds(j)) THEN
              cj = Cols(j)   
              nodecj = (cj-Component1) / Components + 1
              IF( Fixed(nodecj) ) CYCLE
              
              nbonds = nbonds + 1    
              IF(CF(nodecj) == 0) THEN
                n = n + 1
                LocalCon(n) = Con(nodecj)
                LocalInd(n) = nodecj
                LocalVal(n) = ABS( Values(j) )
              END IF
            END IF
          END DO
          
          ! Favor maximum number of connections before strength of connections
          IF( n > ClusterSize - 1 ) THEN
            
            ! Renormalize the effect of strength of connection to [0,1]
            maxv = MAXVAL(LocalVal(1:n))
            LocalVal(1:n) = 0.999 * ConnectionPoints * LocalVal(1:n) / maxv + LocalCon(1:n)
            k = HalfSize
            IF( HalfSize > 0) THEN
              CALL SortR(n,LocalInd,LocalVal)
            END IF
            
            IF( ClusterMode == 2 ) THEN
              k = HalfSize
              ! Ensure that the strongest connections are always at the top of the list 
              IF(k > 0) LocalVal(1:k) = LocalVal(1:k) + 1000.0d0
              
              ! This and the other commented line could be checked for higher dimension
              IF(.FALSE.) LocalVal(k+1:n) = LocalVal(k+1:n) + 10.0d0
              
              ! Add points for the connection to the already chosen ones
              DO l=1,k
                nodeind2 = LocalInd(l)
                matind = Components*(nodeind2-1)+Component1
                DO j=Rows(matind),Rows(matind+1)-1
                  IF(Bonds(j)) THEN
                    cj = Cols(j)   
                    nodecj = (cj-Component1) / Components + 1
                    ! Let the connection dominate over other points
                    DO k2=k+1,n
                      IF( LocalInd(k2) == nodecj) THEN
                        LocalVal(k2) = LocalVal(k2) + 10.0d0
                        EXIT
                      END IF
                    END DO
                    IF(ClusterGrow .AND. k2 > n) THEN
                      n=n+1
                      LocalInd(n) = nodecj
                      LocalVal(n) = 10.0d0
                    END IF
                  END IF
                END DO
                
              END DO
            END IF
            
            CALL SortR(n,LocalInd,LocalVal)
            n = ClusterSize - 1
          END IF
          

          ! If a tightly coupled node cannot be a start of a new cluster join it 
          ! to the cluster of its most strongly coupled neighbour
          ! The other option is that the orphan node builds its own cluster.
          IF( ClusterOrphans .AND. n == 0 .AND. nbonds > 0) THEN
            
            maxv = 0.0d0
            DO j=Rows(matind),Rows(matind+1)-1
              IF(Bonds(j)) THEN
                cj = Cols(j)
                nodecj = (cj-Component1) / Components + 1               
                IF( Fixed(nodecj) ) CYCLE
                k = CF(nodecj) 
                IF( k > 0) THEN
                  IF( ABS(Values(j)) > maxv) THEN
                    maxv = ABS( Values(j) )
                    rind = k
                  END IF
                END IF
              END IF
            END DO
            
            ! If there are many possible candinate parents for the orphan take into account the 
            ! sum of all normalized contributions
            IF( OrphansBest .AND. nbonds > 2) THEN
              LocalInd(1:nbonds) = 0
              LocalVal(1:nbonds) = 0.0_dp 
              
              DO j=Rows(matind),Rows(matind+1)-1
                IF(Bonds(j)) THEN
                  cj = Cols(j)
                  nodecj = (cj-Component1) / Components + 1               
                  IF( Fixed(nodecj) ) CYCLE
                  k = CF(nodecj) 
                  
                  IF( k > 0) THEN
                    hit = .FALSE.
                    DO k2=1,n              
                      IF( LocalInd(k2) == k) THEN
                        hit = .TRUE.
                        EXIT
                      END IF
                    END DO
                    IF(.NOT. hit) THEN
                      n = n + 1
                      k2 = n
                      LocalInd(k2) = k
                    END IF
                    LocalVal(k2) = LocalVal(k2) + ABS(Values(j)) / maxv + 0.0_dp
                  END IF
                END IF
              END DO
              
              maxv = 0.0_dp
              DO k=1,n
                IF( LocalVal(k) > maxv) THEN
                  maxv = LocalVal(k) 
                  k2 = LocalInd(k)
                END IF
              END DO
              n = 0
              rind = k2
            END IF
          ELSE
            cind = cind + 1
            rind = cind
          END IF
          
          DO j=0,n
            IF(j==0) THEN
              nodecj = nodeind
            ELSE
              nodecj = LocalInd(j)
            END IF
            
            CF(nodecj) = rind
            cnods = cnods + 1
            
            ! Recompute the measure of importance for the neighbours
            cj = Components*(nodecj-1) + Component1
            DO i=Rows(cj),Rows(cj+1)-1
              IF(Bonds(i)) THEN
                ci = Cols(i)          
                nodeci = (ci-Component1)/Components + 1
                IF(.NOT. Fixed(nodeci) .AND. CF(nodeci) == 0) THEN
                  
                  DO l=1,ClusterPoints
                    points = Con(nodeci) + 1
                    oldorder = ConInd(nodeci)
                    IF(GatLims(points) == 0) GatLims(points) = anods
                    neworder = GatLims(points)
                    Con(nodeci) = points
                    GatLims(points) = GatLims(points) - 1
                    
                    IF(neworder /= oldorder) THEN
                      k = RevConInd(neworder)
                      
                      ConInd(nodeci) = neworder
                      ConInd(k) = oldorder
                      
                      RevConInd(neworder) = nodeci
                      RevConInd(oldorder) = k
                    END IF
                  END DO
                  
                END IF
              END IF
            END DO
          END DO
        END IF  ! ClusterSize /= 0
        
        ! Assume that the center of clustering is the node with maximum weight,
        ! or any of its strongly coupled neighbours. Compute the total weight of
        ! the candidate clusters.       
        ! Compute first the cluster points for the point with maximum points
        IF(ClusterSize == 0) THEN
          sumcon = 0
          nbonds = 0
          matind = Components*(nodeind-1) + Component1
          DO j=Rows(matind),Rows(matind+1)-1
            IF(Bonds(j)) THEN
              cj = Cols(j)        
              nodecj = (cj-Component1)/Components + 1
              nbonds = nbonds + 1
              IF(CF(nodecj) == 0) sumcon = sumcon + Con(nodecj) 
            END IF
          END DO
          maxsumcon = sumcon
          nextind = nodeind
          
          IF(ClusterOrphans .AND. sumcon == 0 .AND. nbonds > 0) THEN
            ! If a tightly coupled node cannot be a start of a new cluster join it 
            ! to the cluster of its most stronly coupled neighbour
            maxv = 0.0d0
            DO j=Rows(matind),Rows(matind+1)-1
              IF(Bonds(j)) THEN
                cj = Cols(j)   
                nodecj = (cj-Component1)/Components + 1
                IF( Fixed(nodecj) ) CYCLE
                IF( CF(nodecj) > 0) THEN
                  IF( ABS(Values(j)) > maxv) THEN
                    maxv = ABS( Values(j) )
                    rind = CF(nodecj)
                  END IF
                END IF
              END IF
            END DO
          ELSE
            ! Next compute the cluster points for all its strongly coupled 
            ! unclustered neighbours
            nbonds = 0
            DO j=Rows(matind),Rows(matind+1)-1
              IF(Bonds(j)) THEN
                sumcon = 0
                cj = Cols(j)                  
                nodecj = (cj-Component1)/Components + 1
                IF(.NOT. Fixed(nodecj) .AND. CF(nodecj) == 0) THEN
                  DO i=Rows(cj),Rows(cj+1)-1
                    IF(Bonds(i)) THEN
                      ci = Cols(i)          
                      nodeci = (ci-Component1)/Components + 1
                      IF(CF(nodeci) == 0) sumcon = sumcon + Con(nodeci)
                    END IF
                  END DO
                END IF
                IF(sumcon > maxsumcon) THEN
                  maxsumcon = sumcon
                  nextind = nodecj
                END IF
              END IF
            END DO
            cind = cind + 1
            rind = cind
          END IF
          
          ! The new center for clustering is nextind
          nodeind = nextind
          CF(nodeind) = rind
          cnods = cnods + 1
          
          ! Go through all strongly bonded neighbours to 'ind'
          matind = Components*(nodeind-1) + Component1
          DO j=Rows(matind),Rows(matind+1)-1
            IF(.NOT. Bonds(j)) CYCLE
            cj = Cols(j)
            nodecj = (cj-Component1)/Components + 1
            
            IF(CF(nodecj) == 0) THEN
              CF(nodecj) = cind
              cnods = cnods + 1
              IF(Fixed(nodecj)) CYCLE
              
              ! Recompute the measure of importance for the neighbours
              DO i=Rows(cj),Rows(cj+1)-1
                IF(Bonds(i)) THEN
                  ci = Cols(i)          
                  nodeci = (ci-Component1)/Components + 1
                  IF(.NOT. Fixed(nodeci) .AND. CF(nodeci) == 0) THEN
                    
                    DO l=1,ClusterPoints
                      points = Con(nodeci) + 1
                      oldorder = ConInd(nodeci)
                      IF(GatLims(points) == 0) GatLims(points) = anods
                      neworder = GatLims(points)
                      Con(nodeci) = points
                      GatLims(points) = GatLims(points) - 1
                      
                      IF(neworder /= oldorder) THEN
                        k = RevConInd(neworder)
                        
                        ConInd(nodeci) = neworder
                        ConInd(k) = oldorder
                        
                        RevConInd(neworder) = nodeci
                        RevConInd(oldorder) = k
                      END IF
                    END DO
                    
                  END IF
                END IF
              END DO
            END IF
          END DO
        END IF  ! ClusterSize == 0
        
        ! Shorten the list from top in case the node is already set
        Refcon = 0
        DO WHILE( anods > 0 .AND. CF(RevConInd(anods)) /= 0 )
          MaxCon = Con(RevConInd(anods))          
          Refcon = MAX(MaxCon,RefCon)
          anods = anods - 1
          Refcon = MAX(MaxCon,RefCon)            
        END DO
        
        IF(anods > 0) THEN
          MaxCon = Con(RevConInd(anods))
          RefCon = MAX(MaxCon,RefCon)
          GatLims((MaxCon+1):(Refcon+1)) = 0
        ELSE        
          MaxCon = 0
        END IF
      END DO
      
      DEALLOCATE(Con, GatLims, GatNos, ConInd, RevConInd)
      
      WRITE(Message,'(A,I8)') 'Number of clusters',cind
      CALL Info('CMGClusterForm',Message)
      WRITE(Message,'(A,F8.3)') 'Average size of clusters',1.0*cnods/cind
      CALL Info('CMGClusterForm',Message)
    
    END SUBROUTINE CMGClusterForm
    
  END SUBROUTINE ChooseClusterNodes




END MODULE Smoothers
