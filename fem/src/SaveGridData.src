!/******************************************************************************
! * 
! * Subroutine for saving data on a uniform mesh. This could be of use for 
! * light-weight visualization of glyphs in a otherwise heavy simulation.
! *
! ******************************************************************************
! *
! *  Authors: Peter Råback & Juha Ruokolainen
! *  Email:   Peter.Raback@csc.fi & Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - IT Center for Science Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 26.5. 2010
! *
! *****************************************************************************/



!------------------------------------------------------------------------------
SUBROUTINE SaveGridData( Model,Solver,dt,TransientSimulation )
!------------------------------------------------------------------------------
!******************************************************************************
!
!  This subroutine saves scalar values to a matrix.
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh, materials, BCs, etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear & nonlinear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations
!
!  LOGICAL :: TransientSimulation
!     INPUT: Steady state or transient simulation
!
!******************************************************************************
  USE DefUtils
  USE ParticleUtils

  IMPLICIT NONE
!------------------------------------------------------------------------------
  TYPE(Solver_t), TARGET :: Solver
  TYPE(Model_t) :: Model
  REAL(KIND=dp) :: dt
  LOGICAL :: TransientSimulation
!------------------------------------------------------------------------------
! Local variables
!------------------------------------------------------------------------------

  TYPE(Mesh_t), POINTER :: Mesh
  TYPE(Particle_t) :: Particles
  TYPE(ValueList_t), POINTER :: Params
  LOGICAL :: Visited = .FALSE.
  

  SAVE Visited

!------------------------------------------------------------------------------

  CALL Info('SaveGridData','-----------------------------------------', Level=4 )
  CALL Info('SaveGridData','Saving data an uniform grid point        ', Level=4 )

  
  Params => Solver % Values
  Mesh => Solver % Mesh

  ! Initialize the particles on the first calling
  !------------------------------------------------------------------------
  IF( .NOT. Visited ) THEN
    Particles % TimeOrder = 0
    Particles % dim = CoordinateSystemDimension()
    CALL CreateGridParticles( Particles ) 

    CALL CreateListForSaving( Model, Solver % Values,.TRUE. )    

    Visited = .TRUE.
  END IF
  
  CALL ParticleOutput( Particles ) 
  
  CALL Info('SaveGridData','All done',Level=4)
  CALL Info('SaveGridData', '-----------------------------------------', Level=4 )
  

CONTAINS


  !---------------------------------------------------------
  ! Allocate particles for visualization
  !---------------------------------------------------------
  SUBROUTINE AllocateGridParticles(Particles,NoParticles)
    
    TYPE(Particle_t) :: Particles
    INTEGER :: NoParticles   
    REAL(KIND=dp), POINTER :: Coordinate(:,:), UVW(:,:)
    INTEGER, POINTER :: Status(:), ElementIndex(:)
    INTEGER :: PrevNoParticles, dim, No, n
    

    IF( NoParticles <= Particles % MaxNumberOfParticles ) THEN
      ! CALL Info('AllocateParticles','There are already enough particles')
      RETURN
    ELSE
      !WRITE(Message,*) 'Allocating number of particles:',NoParticles
      !CALL Info('AllocateParticles',Message)    
    END IF
    
    dim = Particles % dim 
    
    IF( Particles % MaxNumberOfParticles == 0 ) THEN
      ALLOCATE( Particles % Coordinate(NoParticles,dim))
      ALLOCATE( Particles % uvw(NoParticles,dim))
      ALLOCATE( Particles % ElementIndex(NoParticles))
      ALLOCATE( Particles % Status(NoParticles))
      
      Particles % Coordinate = 0.0_dp
      Particles % uvw = 0.0_dp
      Particles % ElementIndex = 0
      Particles % MaxNumberOfParticles = NoParticles
    ELSE
      Coordinate => Particles % Coordinate
      UVW => Particles % UVW
      Status => Particles % Status
      ElementIndex => Particles % ElementIndex
      
      ALLOCATE( Particles % Coordinate(NoParticles,dim) )
      ALLOCATE( Particles % UVW(NoParticles,dim) )
      ALLOCATE( Particles % Status(NoParticles) )
      ALLOCATE( Particles % ElementIndex(NoParticles) )
      
      ! ------------------------

      PrevNoParticles = Particles % MaxNumberOfParticles
      Particles % NumberOfParticles = n
      

      Particles % Coordinate(1:PrevNoParticles,:) = Coordinate
      Particles % UVW(1:PrevNoParticles,:) = UVW
      Particles % ElementIndex(1:PrevNoParticles) = ElementIndex
      Particles % Status(1:PrevNoParticles) = Status


      DEALLOCATE(Coordinate, uvw, Status, ElementIndex)
      
      Particles % Coordinate(PrevNoParticles+1:NoParticles,:) = 0.0_dp
      Particles % UVW(PrevNoParticles+1:NoParticles,:) = 0.0_dp
      Particles % ElementIndex(PrevNoParticles+1:NoParticles) = 0
      Particles % Status(PrevNoParticles+1:NoParticles) = PARTICLE_ALLOCATED
      
      Particles % MaxNumberOfParticles = NoParticles
    END IF
  END SUBROUTINE AllocateGridParticles
  

  !-----------------------------------------------------------------
  ! Add one single particle to list, allocating more space if needed
  !------------------------------------------------------------------

  SUBROUTINE AddGridParticle(Particles,ElementIndex,GlobalCoords,LocalCoords)

    TYPE(Particle_t) :: Particles
    INTEGER :: ElementIndex
    REAL(KIND=dp) :: GlobalCoords(3),LocalCoords(3)
    
    INTEGER :: i,j,n,m,dim

    n = Particles % NumberOfParticles 
    IF( n == Particles % MaxNumberOfParticles ) THEN
      m = MAX( 100, n / 10 ) 
      CALL AllocateGridParticles( Particles, n + m )
    END IF
    
    dim = Particles % dim
    n = n + 1
    
    Particles % NumberOfParticles = n
    Particles % ElementIndex(n) = ElementIndex
    Particles % Status(n) = PARTICLE_READY
    
    Particles % Coordinate(n,1:dim) = GlobalCoords(1:dim)
    Particles % uvw(n,1:dim) = LocalCoords(1:dim)

    
  END SUBROUTINE AddGridParticle


  !-----------------------------------------------------------------
  ! Find grid particles in a uniform grid
  !------------------------------------------------------------------     
  SUBROUTINE CreateGridParticles(Particles)
     
    TYPE(Particle_t) :: Particles

    TYPE(Mesh_t), POINTER :: Mesh
    REAL(KIND=dp) :: MinCoord(3), MaxCoord(3), Origin(3)
    REAL(KIND=dp) :: LocalCoords(3), GlobalCoords(3)
    REAL(KIND=dp) :: x,y,z,u,v,w,dx,dy,dz
    INTEGER, POINTER :: MaskPerm(:)
    INTEGER :: dim,t,i,j,k,n,nx,ny,nz,imin,imax,jmin,jmax,kmin,kmax, &
        imintot,imaxtot,jmintot,jmaxtot,kmintot,kmaxtot,elemdim
    INTEGER :: ioff,joff,koff,cands1, cands2
    INTEGER :: ParallelNodes, NumberOfNodes
    TYPE(Nodes_t) :: Nodes
    TYPE(ValueList_t), POINTER :: Params
    TYPE(ELement_t), POINTER :: Element
    LOGICAL, POINTER :: GridPointActive(:,:,:)
    LOGICAL :: CheckForDuplicates, LowerDimensional, MaskExist, GotIt
    CHARACTER(MAX_NAME_LEN) :: Str


    Mesh => GetMesh()
    IF( .NOT. ASSOCIATED( Mesh ) ) THEN
      CALL Fatal('FindGridParticles','No Mesh associated')
    END IF

    dim = Mesh % MeshDim
    Params => Solver % Values


    ! The bounding box may be given, otherwise it is taken to include the whole mesh
    !-------------------------------------------------------------------------------
    MinCoord(1) = GetCReal( Params,'Min Coordinate 1',GotIt) 
    IF(.NOT. GotIt) MinCoord(1) = MINVAL(Mesh % Nodes % x )
    MinCoord(2) = GetCReal( Params,'Min Coordinate 2',GotIt) 
    IF(.NOT. GotIt) MinCoord(2) = MINVAL(Mesh % Nodes % y )
    MinCoord(3) = GetCReal( Params,'Min Coordinate 3',GotIt) 
    IF(.NOT. GotIt) MinCoord(3) = MINVAL(Mesh % Nodes % z )

    MaxCoord(1) = GetCReal( Params,'Max Coordinate 1',GotIt) 
    IF(.NOT. GotIt) MaxCoord(1) = MAXVAL(Mesh % Nodes % x )
    MaxCoord(2) = GetCReal( Params,'Max Coordinate 2',GotIt) 
    IF(.NOT. GotIt) MaxCoord(2) = MAXVAL(Mesh % Nodes % y )    
    MaxCoord(3) = GetCReal( Params,'Max Coordinate 3',GotIt) 
    IF(.NOT. GotIt) MaxCoord(3) = MAXVAL(Mesh % Nodes % z )

    ! print *,'Bounding box min:',MinCoord
    ! print *,'Bounding box max:',MaxCoord

    ! Optionally the mesh origin may be moved to guarantee that there is 
    ! a node at (x0,y0,z0) always.
    !--------------------------------------------------------------------
    Origin(1) = GetCReal( Params,'Grid Origin 1',GotIt) 
    Origin(2) = GetCReal( Params,'Grid Origin 2',GotIt) 
    Origin(3) = GetCReal( Params,'Grid Origin 3',GotIt) 

    ! print *,'Origin:',Origin

    MinCoord = MinCoord - Origin
    MaxCoord = MaxCoord - Origin


    ! Get the grid resolution assuming that the grid is cartesian and uniform.
    !----------------------------------------------------------------------------
    dx = GetCReal( Params,'Grid dx',GotIt) 
    IF(.NOT. GotIt ) THEN
      nx = GetInteger( Params,'Grid nx',GotIt) 
      IF( GotIt) THEN
        dx = ( MaxCoord(1) - MinCoord(1) ) / nx 
      ELSE
        CALL Fatal('FindGridParticles','Give either > Grid dx < or > Grid nx <')
      END IF
    END IF

    dy = GetCReal( Params,'Grid dy',GotIt) 
    IF(.NOT. GotIt ) THEN
      ny = GetInteger( Params,'Grid nx',GotIt) 
      IF( GotIt) THEN
        dy = ( MaxCoord(2) - MinCoord(2) ) / ny
      ELSE
        dy = dx
      END IF
    END IF

    IF( dim == 3 ) THEN
      dz = GetCReal( Params,'Grid dz',GotIt) 
      IF(.NOT. GotIt ) THEN
        nz = GetInteger( Params,'Grid nz',GotIt) 
        IF( GotIt) THEN
          dz = ( MaxCoord(1) - MinCoord(1) ) / nz
        ELSE
          dz = dx
        END IF
      END IF
    END IF


    ! Set limits for the global indexes. These are used particularly if the 
    ! bounding box has been manually reduced. 
    !----------------------------------------------------------------------------
    imintot = CEILING( MinCoord(1) / dx ) 
    imaxtot = FLOOR( MaxCoord(1) / dx ) 
    
    IF( dim >= 2 ) THEN
      jmintot = CEILING( MinCoord(2) / dy ) 
      jmaxtot = FLOOR( MaxCoord(2) / dy ) 
    ELSE
      jmintot = 0
      jmaxtot = 0
    END IF

    IF( dim == 3 ) THEN 
      kmintot = CEILING( MinCoord(3) / dz ) 
      kmaxtot = FLOOR( MaxCoord(3) / dz ) 
    ELSE
      kmintot = 0
      kmaxtot = 0
    END IF

    ! PRINT *,'indexes:',imintot,imaxtot,jmintot,jmaxtot,kmintot,kmaxtot

    ! Create a table for checking active gridpoints
    !----------------------------------------------------------------------------
    CheckForDuplicates = GetLogical( Params,'Check for Duplicates')
    IF( CheckForDuplicates ) THEN
      ioff = imintot-1
      joff = jmintot-1
      koff = kmintot-1

      ALLOCATE( GridPointActive(imaxtot-ioff,jmaxtot-joff,kmaxtot-koff) )
      GridPointActive = .FALSE.
    END IF


    ! Create a mask for saving only part of data
    !---------------------------------------------------------------
    MaskExist = .FALSE.
    Str = ListGetString( Params,'Mask Name',GotIt) 
    IF( GotIt ) THEN
      ALLOCATE( MaskPerm( Model % NumberOfNodes ) ) 
      CALL MakePermUsingMask( Model,Solver,Mesh,Str, &
          .FALSE., MaskPerm, Mesh % NumberOfNodes )
      NumberOfNodes = MAXVAL( MaskPerm ) 
      ParallelNodes = NINT( ParallelReduction( 1.0_dp * NumberOfNodes ) )
      IF( ParallelNodes == 0 ) THEN
        CALL Fatal('ElmerPostOutputSolver','Given mask not active: '//TRIM(Str) )
      ELSE
        MaskExist = .TRUE.
        CALL Info('SaveGridData','Using > '// TRIM(Str) // ' < as mask variable')
      END IF
    END IF


    ! Create particles in the uniform grid
    !----------------------------------------------------------------------------
    
    cands1 = 0
    cands2 = 0

    LowerDimensional = .FALSE.

    DO t=1,Mesh % NumberOfBulkElements + Mesh % NumberOfBoundaryElements

      Element => Mesh % Elements(t)
      n = GetElementNOFNodes(Element)
      CALL GetElementNodes(Nodes,Element)

      IF( MaskExist ) THEN
        IF( ANY( MaskPerm( Element % NodeIndexes ) == 0 ) ) CYCLE
      END IF
      elemdim = Element % Type % Dimension

      imin = CEILING( ( MINVAL( Nodes % x(1:n) ) - Origin(1) ) / dx )
      imax = FLOOR( ( MAXVAL( Nodes % x(1:n) ) - Origin(1) ) / dx )
      imin = MAX( imin, imintot )
      imax = MIN( imax, imaxtot )

      IF( elemdim >= 2 ) THEN
        jmin = CEILING( ( MINVAL( Nodes % y(1:n) ) - Origin(2) ) / dy )
        jmax = FLOOR( ( MAXVAL( Nodes % y(1:n) ) - Origin(2) ) / dy )
        jmin = MAX( jmin, jmintot )
        jmax = MIN( jmax, jmaxtot )
      ELSE
        jmin = jmintot
        jmax = jmintot

        ! If the element is of reduced order the flatten it in order to make 
        ! PointInElement function better.
        !-------------------------------------------------------------------
        IF( dim >= 2 ) THEN
          Nodes % y(1:n) = 0.0_dp
        END IF
      END IF

      IF( elemdim == 3 ) THEN 
        kmin = CEILING( ( MINVAL( Nodes % z(1:n) ) - Origin(3) ) / dz )
        kmax = FLOOR( ( MAXVAL( Nodes % z(1:n) ) - Origin(3) ) / dz )
        kmin = MAX( kmin, kmintot )
        kmax = MIN( kmax, kmaxtot )     
      ELSE
        kmin = kmintot
        kmax = kmaxtot
        IF( dim == 3 ) THEN
          Nodes % z(1:n) = 0.0_dp
        END IF
      END IF

      ! The loop is ordered in this way since more often 
      ! nz < ny < nx than any other way minimizing the cost
      !-----------------------------------------------------
      GlobalCoords = 0.0_dp

      DO k=kmin,kmax
        IF( elemdim == 3 ) GlobalCoords(3) = k * dz + Origin(3)
        
        DO j=jmin,jmax
          IF( elemdim >= 2 ) GlobalCoords(2) = j * dy + Origin(2)
          
          DO i=imin,imax
            GlobalCoords(1) = i * dx + Origin(1)
 
            cands1 = cands1 + 1

            IF( CheckForDuplicates ) THEN
              IF( GridPointActive(i-ioff,j-joff,k-koff) ) CYCLE
              cands2 = cands2 + 1
            END IF
            
            IF ( PointInElement( Element, Nodes, &
                GlobalCoords, LocalCoords ) ) THEN
             
              IF( CheckForDuplicates ) THEN
                GridPointActive(i-ioff,j-joff,k-koff) = .TRUE.
              END IF
              CALL AddGridParticle(Particles,t,GlobalCoords,LocalCoords)
            END IF
            
          END DO
        END DO
      END DO
	
      IF( t == Mesh % NumberOfBulkElements ) THEN        
        IF( Particles % NumberOfParticles > 0 ) EXIT
        LowerDimensional = .TRUE.
      END IF
	
    END DO

    IF( MaskExist ) THEN
      DEALLOCATE( MaskPerm )
    END IF


    WRITE( Message,'(A,I8)') 'Number of candidate nodes:',cands1
    CALL Info('CreateGridParticles',Message)

    IF( CheckForDuplicates ) THEN
      WRITE( Message,'(A,I8)') 'Number of duplicate nodes:',cands1-cands2
      CALL Info('CreateGridParticles',Message)
      DEALLOCATE( GridPointActive )
    END IF

    WRITE( Message,'(A,I8)') 'Number of created nodes:',Particles % NumberOfParticles
    CALL Info('CreateGridParticles',Message)
    
    WRITE( Message,'(A,F8.2)') 'Search hit fraction:',1.0_dp * Particles % NumberOfParticles / cands1
    CALL Info('CreateGridParticles',Message)


  END SUBROUTINE CreateGridParticles
     
!------------------------------------------------------------------------------
END SUBROUTINE SaveGridData
!------------------------------------------------------------------------------


