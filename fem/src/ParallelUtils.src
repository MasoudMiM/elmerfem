!/******************************************************************************
! *
! *       ELMER, A Computational Fluid Dynamics Program.
! *
! *       Copyright 1st April 1995 - , Center for Scientific Computing,
! *                                    Finland.
! *
! *       All rights reserved. No part of this program may be used,
! *       reproduced or transmitted in any form or by any means
! *       without the written permission of CSC.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! * Parallel solver utilities for *Solver - routines
! *
! ******************************************************************************
! *
! *                     Author:       Juha Ruokolainen
! *
! *                    Address: Center for Scientific Computing
! *                                Tietotie 6, P.O. BOX 405
! *                                  02101 Espoo, Finland
! *                                  Tel. +358 0 457 2723
! *                                Telefax: +358 0 457 2302
! *                              EMail: Juha.Ruokolainen@csc.fi
! *
! *                       Date: 02 Apr 2001
! *
! *                Modified by:
! *
! *       Date of modification:
! *
! *****************************************************************************/

MODULE ParallelUtils

     USE SparIterSolve

     IMPLICIT NONE

CONTAINS

#define PARALLEL_FOR_REAL
!-------------------------------------------------------------------------------
  FUNCTION ParallelInit() RESULT ( ParallelEnv )
!-------------------------------------------------------------------------------
    TYPE (ParEnv_t), POINTER :: ParallelEnv
                                                                                                                               
#ifdef PARALLEL_FOR_REAL
    ParallelEnv => ParCommInit( )
#else
    ParEnv % MyPE = 0
    ParEnv % PEs  = 1
    ParallelEnv => ParEnv
#endif
!-------------------------------------------------------------------------------
  END FUNCTION ParallelInit
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
  SUBROUTINE ParallelFinalize()
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
    CALL ParEnvFinalize()
#endif
!-------------------------------------------------------------------------------
  END SUBROUTINE ParallelFinalize
!-------------------------------------------------------------------------------
                                                                                                                               
!-------------------------------------------------------------------------------
    SUBROUTINE ParallelInitMatrix( Solver, Matrix )
!-------------------------------------------------------------------------------
       TYPE(Solver_t) :: Solver
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
       INTEGER :: i, j, n, DOFs
!-------------------------------------------------------------------------------

#ifdef PARALLEL_FOR_REAL
       IF ( ParEnv % PEs <= 1 .OR. .NOT. ASSOCIATED(Solver % Matrix) ) RETURN
       DOFs = Solver % Variable % DOFs
       n = SIZE( Solver % Variable % Perm )

       ALLOCATE( Matrix % Perm(DOFs*n), Matrix % InvPerm(DOFs*n) )

       Matrix % Perm    = 0
       Matrix % INVPerm = 0

       DO i=1,n
          IF ( Solver % Variable % Perm(i) /= 0 )  THEN
             DO j=1,DOFs
                Matrix % Perm( (i-1)*DOFs+j ) = &
                   DOFs * (Solver % Variable % Perm(i)-1) + j
             END DO
          END IF
       END DO

       DO i=1,DOFs*n
          IF ( Matrix % Perm(i) /= 0 ) THEN
             Matrix % INVPerm(Matrix % Perm(i)) = i
          END IF
       END DO

       Matrix % ParMatrix => &
          ParInitMatrix( Matrix, Solver % Mesh % ParallelInfo, DOFs )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelInitMatrix
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelInitSolve( Matrix, x, b, r, DOFs, Mesh  )
!-------------------------------------------------------------------------------
       TYPE(Mesh_t), POINTER :: Mesh
       INTEGER :: DOFs
       REAL(KIND=dp) :: x(:), b(:), r(:)
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       CALL SParInitSolve( Matrix, x, b, r, DOFs, Mesh % ParallelInfo )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelInitSolve
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelUpdateSolve( Matrix, x, r )
!-------------------------------------------------------------------------------
       REAL(KIND=dp) :: x(:), r(:)
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       CALL SParUpdateSolve( Matrix, x, r )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelUpdateSolve
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelMatrixVector( Matrix, x, b, Update, UseMassVals )
!-------------------------------------------------------------------------------
      REAL(KIND=dp) :: x(:), b(:)
      LOGICAL, OPTIONAL :: Update, UseMassVals
      TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
      INTEGER :: i,ipar(1)
      REAL(KIND=dp), POINTER :: Mx(:), Mr(:), Mb(:)

      TYPE(SplittedMatrixT), POINTER :: SP
      TYPE(Matrix_t), POINTER :: saveptrif(:), saveptrnb(:), saveptrin
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
      GlobalData => Matrix % ParMatrix
      IF ( PRESENT( Update ) ) THEN
         IF ( Update ) THEN
            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN

                  SP => GlobalData % SplittedMatrix
                  ALLOCATE( saveptrif( ParEnv % PEs ) )
                  ALLOCATE( saveptrnb( ParEnv % PEs ) )
                  ALLOCATE( saveptrIn )
                  DO i=1,ParEnv % PEs
                  IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) THEN
                     saveptrif(i) % values => SP % IfMatrix(i) % values
                  end if
                  IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) THEN
                     saveptrnb(i) % values => SP % NbsIfMatrix(i) % values
                  endif
                  END DO
                  saveptrin % values => SP % InsideMatrix % values

                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) THEN
                         SP % IfMatrix(i) % Values => SP % IfMatrix(i) % MassValues
                    END IF

                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) THEN
                         SP % NbsIfMatrix(i) % Values => SP % NbsIfMatrix(i) % MassValues 
                    END IF
                  END DO
                  SP % InsideMatrix % Values => SP % InsideMatrix % MassValues
               END IF

               Mx => GlobalData % SplittedMatrix % TmpXVec 
               Mr => GlobalData % SplittedMatrix % TmpRVec 
               CALL SParMatrixVector( Mx, Mr, ipar )
               CALL SParUpdateResult( Matrix, x, b, .FALSE. )
            ELSE
               Mx => GlobalData % SplittedMatrix % TmpXVec 
               Mr => GlobalData % SplittedMatrix % TmpRVec 
               CALL SParMatrixVector( Mx, Mr, ipar )
               CALL SParUpdateResult( Matrix, x, b, .FALSE. )
            END IF

            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN
                  DO i=1,ParEnv % PEs
                  IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) THEN
                   SP % IfMatrix(i) % values =>  saveptrif(i) % values
                  end if
                  IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) THEN
                   SP % NbsIfMatrix(i) % values =>  saveptrnb(i) % values 
                  end if
                  END DO
                  SP % InsideMatrix % values => saveptrin % values 
                  DEALLOCATE( saveptrif )
                  DEALLOCATE( saveptrnb )
                  DEALLOCATE( saveptrIn )
               END IF
            END IF
         ELSE
            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN

                  SP => GlobalData % SplittedMatrix
                  ALLOCATE( saveptrif( ParEnv % PEs ) )
                  ALLOCATE( saveptrnb( ParEnv % PEs ) )
                  ALLOCATE( saveptrIn )
                  DO i=1,ParEnv % PEs
                  IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) THEN
                     saveptrif(i) % values => SP % IfMatrix(i) % values
                  end if
                  IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) THEN
                     saveptrnb(i) % values => SP % NbsIfMatrix(i) % values
                  endif
                  END DO
                  saveptrin % values => SP % InsideMatrix % values

                  DO i=1,ParEnv % PEs
                    IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) THEN
                         SP % IfMatrix(i) % Values => SP % IfMatrix(i) % MassValues
                    END IF

                    IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) THEN
                         SP % NbsIfMatrix(i) % Values => SP % NbsIfMatrix(i) % MassValues 
                    END IF
                  END DO
                  SP % InsideMatrix % Values => SP % InsideMatrix % MassValues
               END IF
            END IF

            CALL SParMatrixVector( x, b, ipar )

            IF ( PRESENT(UseMassVals) ) THEN
               IF ( UseMassVals ) THEN
                  DO i=1,ParEnv % PEs
                  IF ( SP % IfMatrix(i) % NumberOfRows /= 0 ) THEN
                   SP % IfMatrix(i) % values =>  saveptrif(i) % values
                  end if
                  IF ( SP % NbsIfMatrix(i) % NumberOfRows /= 0 ) THEN
                   SP % NbsIfMatrix(i) % values =>  saveptrnb(i) % values 
                  end if
                  END DO
                  SP % InsideMatrix % values => saveptrin % values 
                  DEALLOCATE( saveptrif )
                  DEALLOCATE( saveptrnb )
                  DEALLOCATE( saveptrIn )
               END IF
            END IF
         END IF
      ELSE
         CALL SParMatrixVector( x, b, ipar )
      END IF
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelMatrixVector
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelUpdateResult( Matrix, x, r )
!-------------------------------------------------------------------------------
       REAL(KIND=dp) :: x(:), r(:)
       TYPE(Matrix_t), POINTER :: Matrix
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
       CALL SParUpdateResult( Matrix, x, r, .TRUE. )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelUpdateResult
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------

    FUNCTION ParallelMatrix( A,x,b,r ) RESULT(M)
!-------------------------------------------------------------------------------
       TYPE(Matrix_t), POINTER :: A, M
       REAL(KIND=dp),  POINTER, OPTIONAL :: x(:),b(:),r(:)
!-------------------------------------------------------------------------------
       M => NULL()
#ifdef PARALLEL_FOR_REAL
       M => A % ParMatrix % SplittedMatrix % InsideMatrix
       IF ( PRESENT(x) ) THEN
          b => M % RHS
          x => A % ParMatrix % SplittedMatrix % TmpXVec
          r => A % ParMatrix % SplittedMatrix % TmpRVec
       END IF
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelMatrix
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    FUNCTION ParallelNorm( n, x ) RESULT(s)
!-------------------------------------------------------------------------------
      INTEGER :: n
      REAL(KIND=dp) :: x(:),s
!-------------------------------------------------------------------------------
      s = 0.0d0
#ifdef PARALLEL_FOR_REAL
      s = SParNorm( n, x, 1 )
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelNorm
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    FUNCTION ParallelDOT( n, x, y ) RESULT(s)
!-------------------------------------------------------------------------------
      INTEGER :: n
      REAL(KIND=dp) :: x(:),y(:),s
!-------------------------------------------------------------------------------
      s = 0.0d0
#ifdef PARALLEL_FOR_REAL
      s = SParDotProd( n, x, 1, y, 1 )
#endif
!-------------------------------------------------------------------------------
    END FUNCTION ParallelDOT
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
    SUBROUTINE ParallelGlobalNumbering(Mesh,NewNodes,IntCnts,IntArray,Reorder)
!-------------------------------------------------------------------------------
       TYPE(Mesh_t) :: Mesh
       INTEGER :: NewNodes,IntCnts(:),IntArray(:),Reorder(:)
!-------------------------------------------------------------------------------
#ifdef PARALLEL_FOR_REAL
        CALL SparGlobalNumbering( Mesh,NewNodes,IntCnts,IntArray,Reorder )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelGlobalNumbering
!-------------------------------------------------------------------------------

!-------------------------------------------------------------------------------
    SUBROUTINE ParallelIter( SourceMatrix, ParallelInfo, DOFs, XVec, &
              RHSVec, Solver, SParMatrixDesc )
!-------------------------------------------------------------------------------
                                                                                                                               
       TYPE (Matrix_t) :: SourceMatrix
       TYPE (ParallelInfo_t) :: ParallelInfo
       INTEGER :: DOFs
       REAL(KIND=dp), DIMENSION(:) :: XVec, RHSVec
       TYPE (Solver_t) :: Solver
       TYPE (SParIterSolverGlobalD_t), POINTER :: SParMatrixDesc
                                                                                                                               
#ifdef PARALLEL_FOR_REAL
       CALL SParIterSolver( SourceMatrix, ParallelInfo, DOFs, XVec, &
                 RHSVec, Solver, SParMatrixDesc )
#endif
!-------------------------------------------------------------------------------
    END SUBROUTINE ParallelIter
!-------------------------------------------------------------------------------


END MODULE ParallelUtils
