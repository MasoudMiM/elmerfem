!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - Scientific Computing Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module containing a iterative solver for linear systems.
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - Scientific Computing Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! ****************************************************************************/
! *
! * $Id: IterSolve.src,v 1.12 2007/05/22 08:34:54 jpr Exp $
! *****************************************************************************

#include "huti_fdefs.h"

!------------------------------------------------------------------------------
MODULE IterSolve

   USE Lists
   USE CRSMatrix
   USE BandMatrix

   IMPLICIT NONE

   !/*
   ! * Iterative method selection
   ! */
   INTEGER, PARAMETER, PRIVATE :: ITER_BiCGStab     =           320
   INTEGER, PARAMETER, PRIVATE :: ITER_TFQMR        =           330
   INTEGER, PARAMETER, PRIVATE :: ITER_CG           =           340
   INTEGER, PARAMETER, PRIVATE :: ITER_CGS          =           350
   INTEGER, PARAMETER, PRIVATE :: ITER_GMRES        =           360
   INTEGER, PARAMETER, PRIVATE :: ITER_BiCGStab2    =           370

   !/*
   ! * Preconditioning type code
   ! */
   INTEGER, PARAMETER, PRIVATE :: PRECOND_NONE      =           400
   INTEGER, PARAMETER, PRIVATE :: PRECOND_DIAGONAL  =           410
   INTEGER, PARAMETER, PRIVATE :: PRECOND_ILUn      =           420
   INTEGER, PARAMETER, PRIVATE :: PRECOND_ILUT      =           430
   INTEGER, PARAMETER, PRIVATE :: PRECOND_MG        =           440
   INTEGER, PARAMETER, PRIVATE :: PRECOND_BILUn     =           450

   LOGICAL :: FirstCall = .TRUE.

CONTAINS


!------------------------------------------------------------------------------
! We use backward error estimate e = ||Ax-b||/(||A|| ||x|| + ||b||)
! as stopping criteriation.
!------------------------------------------------------------------------------
  FUNCTION STOPC( x,b,r,ipar,dpar ) RESULT(err)
!------------------------------------------------------------------------------

     INTEGER :: ipar(*),n
     DOUBLE PRECISION :: x(*),b(*),r(*),dpar(*),err,res(HUTI_NDIM)

     n = HUTI_NDIM

     CALL CRS_MatrixVectorMultiply( GlobalMatrix,x,res )
     res = res - b(1:n)

     err = SQRT(SUM( res(1:n)**2) ) /  &
        ( SQRT(SUM(GlobalMatrix % Values**2)) * SQRT(SUM(x(1:n)**2)) + SQRT(SUM(b(1:n)**2)) )

  END FUNCTION STOPC
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
  SUBROUTINE IterSolver( A,x,b,SolverParam,DotF,NormF,MatvecF )
!------------------------------------------------------------------------------

    USE SParIterGlobals
    IMPLICIT NONE

!------------------------------------------------------------------------------
    TYPE(Solver_t) :: SolverParam

    REAL(KIND=dp), DIMENSION(:) :: x,b
    TYPE(Matrix_t), POINTER :: A, Adiag

    INTEGER(KIND=AddrInt), OPTIONAL :: DotF, NormF, MatVecF
!------------------------------------------------------------------------------

    REAL(KIND=dp) :: dpar(50),stopfun,dnrm2
!   external stopfun
    REAL(KIND=dp), ALLOCATABLE :: work(:,:)
    INTEGER :: k,N,ipar(50),wsize,istat,IterType,PCondType,ILUn,Blocks

    REAL(KIND=dp) :: ILUT_TOL
    LOGICAL :: Condition,GotIt,AbortNotConverged, Refactorize

    CHARACTER(LEN=MAX_NAME_LEN) :: str

    EXTERNAL MultigridPrec

    INTEGER  :: HUTI_D_BICGSTAB, HUTI_D_BICGSTAB_2, HUTI_D_TFQMR, HUTI_D_CG, HUTI_D_CGS, HUTI_D_GMRES
    EXTERNAL :: HUTI_D_BICGSTAB, HUTI_D_BICGSTAB_2, HUTI_D_TFQMR, HUTI_D_CG, HUTI_D_CGS, HUTI_D_GMRES

    INTEGER  :: HUTI_Z_BICGSTAB, HUTI_Z_BICGSTAB_2, HUTI_Z_TFQMR, HUTI_Z_CG, HUTI_Z_CGS, HUTI_Z_GMRES
    EXTERNAL :: HUTI_Z_BICGSTAB, HUTI_Z_BICGSTAB_2, HUTI_Z_TFQMR, HUTI_Z_CG, HUTI_Z_CGS, HUTI_Z_GMRES

    INTEGER(KIND=Addrint) :: dotProc, normProc, pcondProc, &
            pcondrProc=0, mvProc,AddrFunc, iterProc
!------------------------------------------------------------------------------
    N = A % NumberOfRows

    ipar = 0
    dpar = 0.0D0

!------------------------------------------------------------------------------
    str = ListGetString( SolverParam % Values,'Linear System Iterative Method' )

    IF ( str(1:9) == 'bicgstab2' ) THEN
      IterType = ITER_BiCGStab2
    ELSE IF ( str(1:8) == 'bicgstab' ) THEN
      IterType = ITER_BiCGStab
    ELSE IF ( str(1:5) == 'tfqmr' )THEN
      IterType = ITER_TFQMR
    ELSE IF ( str(1:3) == 'cgs' ) THEN
      IterType = ITER_CGS
    ELSE IF ( str(1:2) == 'cg' ) THEN
      IterType = ITER_CG
    ELSE IF ( str(1:5) == 'gmres' ) THEN
      IterType = ITER_GMRES
    ELSE
      IterType = ITER_BiCGStab
    END IF
!------------------------------------------------------------------------------

    SELECT CASE ( IterType )
      CASE (ITER_BiCGStab)
        HUTI_WRKDIM = HUTI_BICGSTAB_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_BiCGStab2)
        HUTI_WRKDIM = HUTI_BICGSTAB_2_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_TFQMR)
        HUTI_WRKDIM = HUTI_TFQMR_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_CG)
        HUTI_WRKDIM = HUTI_CG_WORKSIZE
        wsize = HUTI_WRKDIM

      CASE (ITER_CGS)
        HUTI_WRKDIM = HUTI_CGS_WORKSIZE
        wsize = HUTI_WRKDIM
          
      CASE (ITER_GMRES)

        HUTI_GMRES_RESTART = ListGetInteger( SolverParam % Values, &
             'Linear System GMRES Restart',  GotIt ) 
        IF ( .NOT. GotIT ) HUTI_GMRES_RESTART = 10
        HUTI_WRKDIM = HUTI_GMRES_WORKSIZE + HUTI_GMRES_RESTART
        wsize = HUTI_WRKDIM
     END SELECT
!------------------------------------------------------------------------------
          
     HUTI_STOPC = HUTI_TRESID_SCALED_BYB
     HUTI_NDIM  = N

     HUTI_DBUGLVL  = ListGetInteger( SolverParam % Values, &
           'Linear System Residual Output', GotIt )
     IF ( .NOT.Gotit ) HUTI_DBUGLVL = 1
     IF ( Parenv % myPE /= 0 ) HUTI_DBUGLVL=0

     IF ( .NOT. OutputLevelMask(6) )  HUTI_DBUGLVL = 0

     HUTI_MAXIT = ListGetInteger( SolverParam % Values, &
         'Linear System Max Iterations', minv=1 )
 
     ALLOCATE( work(N,wsize),stat=istat )
     IF ( istat /= 0 ) THEN
       CALL Fatal( 'IterSolve', 'Memory allocation failure.' )
     END IF

     IF ( ALL(x == 0.0) ) x = 1.0d-8
     HUTI_INITIALX = HUTI_USERSUPPLIEDX

     HUTI_TOLERANCE = ListGetConstReal( SolverParam % Values, &
             'Linear System Convergence Tolerance' )
!------------------------------------------------------------------------------

     str = ListGetString( SolverParam % Values, &
      'Linear System Preconditioning',gotit )

     IF ( .NOT.gotit ) str = 'none'

     IF ( str(1:4) == 'none' ) THEN
       PCondType = PRECOND_NONE
     ELSE IF ( str(1:8) == 'diagonal' ) THEN
       PCondType = PRECOND_DIAGONAL
     ELSE IF ( str(1:4) == 'ilut' ) THEN
       ILUT_TOL = ListGetConstReal( SolverParam % Values, &
           'Linear System ILUT Tolerance',GotIt )
       PCondType = PRECOND_ILUT
     ELSE IF ( str(1:3) == 'ilu' ) THEN
       ILUn = ICHAR(str(4:4)) - ICHAR('0')
       IF ( ILUn  < 0 .OR. ILUn > 9 ) ILUn = 0
       PCondType = PRECOND_ILUn
     ELSE IF ( str(1:4) == 'bilu' ) THEN
       ILUn = ICHAR(str(5:5)) - ICHAR('0')
       IF ( ILUn  < 0 .OR. ILUn > 9 ) ILUn = 0
       PCondType = PRECOND_BILUn
     ELSE IF ( str(1:9) == 'multigrid' ) THEN
       PCondType = PRECOND_MG
     ELSE
       PCondType = PRECOND_NONE
       CALL Warn( 'IterSolve', 'Unknown preconditioner type, feature disabled.' )
     END IF

     IF ( .NOT. ListGetLogical( SolverParam % Values, 'No Precondition Recompute',GotIt ) ) THEN
        n = ListGetInteger( SolverParam % Values, 'Linear System Precondition Recompute', GotIt )
        IF ( n <= 0 ) n = 1

        Refactorize = ListGetLogical( SolverParam % Values, 'Linear System Refactorize', Gotit )
        IF ( .NOT. Gotit ) Refactorize = .TRUE.

        IF (.NOT. ASSOCIATED(A % ILUValues).OR.(Refactorize .AND. MOD(A % SolveCount, n)==0) ) THEN
           IF ( A % FORMAT == MATRIX_CRS ) THEN

             IF ( A % COMPLEX ) THEN
                IF ( PCondType == PRECOND_ILUn ) THEN
                   Condition = CRS_ComplexIncompleteLU(A,ILUn)
                ELSE IF ( PCondType == PRECOND_ILUT ) THEN
                   Condition = CRS_ComplexILUT( A,ILUT_TOL )
                END IF
             ELSE
               IF ( PCondType == PRECOND_ILUn ) THEN
                 Condition = CRS_IncompleteLU(A,ILUn)
               ELSE IF ( PCondType == PRECOND_ILUT ) THEN
                 Condition = CRS_ILUT( A,ILUT_TOL )
               ELSE IF ( PCondType == PRECOND_BILUn ) THEN
                 Blocks = SolverParam % Variable % Dofs
                 ALLOCATE(Adiag)
                 CALL CRS_BlockDiagonal(A,Adiag,Blocks)
                 Condition = CRS_IncompleteLU(Adiag,ILUn)
                 A % ILURows   => Adiag % ILURows
                 A % ILUCols   => Adiag % ILUCols
                 A % ILUDiag   => Adiag % ILUDiag
                 A % ILUValues => Adiag % ILUValues
                 DEALLOCATE(Adiag % Rows,Adiag % Cols, Adiag % Values)
                 DEALLOCATE(Adiag)
               END IF
             END IF
           ELSE
             IF ( PCondType == PRECOND_ILUn ) THEN
               CALL Warn( 'IterSolve', 'No ILU Preconditioner for Band Matrix format,' )
               CALL Warn( 'IterSolve', 'using Diagonal preconditioner instead...' )
               PCondType = PRECOND_DIAGONAL
             END IF
           END IF
        END IF
     END IF

     A % SolveCount = A % SolveCount + 1
!------------------------------------------------------------------------------

     AbortNotConverged = ListGetLogical( SolverParam % Values, &
          'Linear System Abort Not Converged', GotIt )
     IF ( .NOT. GotIt ) AbortNotConverged = .TRUE.

!------------------------------------------------------------------------------
     FirstCall = .TRUE.

     IF ( PRESENT(MatvecF) ) THEN
       mvProc = MatvecF
     ELSE
       mvProc = AddrFunc( CRS_MatrixVectorProd )
     END IF

     IF ( PRESENT(dotF) ) THEN
       dotProc = dotF
     ELSE
       dotProc =0
     END IF

     IF ( PRESENT(normF) ) THEN
       normProc = normF
     ELSE
       normProc =0
     END IF

     SELECT CASE( PCondType )
       CASE (PRECOND_NONE)
         pcondProc = 0

       CASE (PRECOND_DIAGONAL)
         pcondProc = AddrFunc( CRS_DiagPrecondition )

       CASE (PRECOND_ILUn, PRECOND_ILUT, PRECOND_BILUn )

         PRINT *,'b1'
         pcondProc = AddrFunc( CRS_LUPrecondition )

       CASE (PRECOND_MG)
         pcondProc = AddrFunc( MultiGridPrec )

       CASE DEFAULT
         pcondProc = 0
     END SELECT

     IF ( .NOT. A % COMPLEX ) THEN
       SELECT CASE ( IterType )
       CASE (ITER_BiCGStab)
          iterProc = AddrFunc( HUTI_D_BICGSTAB )
       CASE (ITER_BiCGStab2)
          iterProc = AddrFunc( HUTI_D_BICGSTAB_2 )
       CASE (ITER_TFQMR)
          iterProc = AddrFunc( HUTI_D_TFQMR )
       CASE (ITER_CG)
          iterProc = AddrFunc( HUTI_D_CG )
       CASE (ITER_CGS)
          iterProc = AddrFunc( HUTI_D_CGS )
       CASE (ITER_GMRES)
          iterProc = AddrFunc( HUTI_D_GMRES )
       END SELECT
     ELSE
       HUTI_NDIM = HUTI_NDIM / 2
       SELECT CASE ( IterType )
       CASE (ITER_BiCGStab)
          iterProc = AddrFunc( HUTI_Z_BICGSTAB )
       CASE (ITER_BiCGStab2)
          iterProc = AddrFunc( HUTI_Z_BICGSTAB_2 )
       CASE (ITER_TFQMR)
          iterProc = AddrFunc( HUTI_Z_TFQMR )
       CASE (ITER_CG)
          iterProc = AddrFunc( HUTI_Z_CG )
       CASE (ITER_CGS)
          iterProc = AddrFunc( HUTI_Z_CGS )
       CASE (ITER_GMRES)
          iterProc = AddrFunc( HUTI_Z_GMRES )
       END SELECT
     END IF
!------------------------------------------------------------------------------

     GlobalMatrix => A
     CALL iterCall( iterProc, x, b, ipar, dpar, work, &
       mvProc, pcondProc, pcondrProc, dotProc, normProc, STOPC )

     IF ( A % COMPLEX ) HUTI_NDIM = HUTI_NDIM * 2
!------------------------------------------------------------------------------
     IF ( HUTI_INFO /= HUTI_CONVERGENCE .AND. ParEnv % myPE==0 ) THEN
        IF ( AbortNotConverged ) THEN
           CALL Fatal( 'IterSolve', 'Failed convergence tolerances.' )
        ELSE
           CALL Error( 'IterSolve', 'Failed convergence tolerances.' )
        END IF
     END IF
!------------------------------------------------------------------------------
     DEALLOCATE( work )
!------------------------------------------------------------------------------
  END SUBROUTINE IterSolver 
!------------------------------------------------------------------------------

END MODULE IterSolve
