!/*****************************************************************************/
! *
! *  Elmer, A Finite Element Software for Multiphysical Problems
! *
! *  Copyright 1st April 1995 - , CSC - Scientific Computing Ltd., Finland
! * 
! *  This program is free software; you can redistribute it and/or
! *  modify it under the terms of the GNU General Public License
! *  as published by the Free Software Foundation; either version 2
! *  of the License, or (at your option) any later version.
! * 
! *  This program is distributed in the hope that it will be useful,
! *  but WITHOUT ANY WARRANTY; without even the implied warranty of
! *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! *  GNU General Public License for more details.
! *
! *  You should have received a copy of the GNU General Public License
! *  along with this program (in file fem/GPL-2); if not, write to the 
! *  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
! *  Boston, MA 02110-1301, USA.
! *
! *****************************************************************************/
!
!/******************************************************************************
! *
! *  Module containing a solver for linear stress equations
! *
! ******************************************************************************
! *
! *  Authors: Juha Ruokolainen
! *  Email:   Juha.Ruokolainen@csc.fi
! *  Web:     http://www.csc.fi/elmer
! *  Address: CSC - Scientific Computing Ltd.
! *           Keilaranta 14
! *           02101 Espoo, Finland 
! *
! *  Original Date: 08 Jun 1997
! *
! *****************************************************************************/
! *
! * $Log: StressSolve.src,v $
! * Revision 1.41  2007/04/16 10:03:08  raback
! * Corrected definition of lumped mass.
! *
! * Revision 1.40  2007/04/16 09:41:16  raback
! * Corrected a conflict in sprig constant computation.
! *
! * Revision 1.39  2007/04/12 20:21:52  raback
! * Debugged lumped spring computation.
! *
! * Revision 1.37  2007/03/21 15:32:42  raback
! * Perfecting harmonic scanning options for coupled damped analysis.
! *
! * Revision 1.35  2007/03/20 11:37:51  raback
! * Added computation of lumped mass with the same center of coordinates
! * as the computation of lumped springs.
! *
! * Revision 1.33  2006/12/22 11:19:08  jpr
! * Small formatting changes.
! *
! * Revision 1.32  2006/12/18 12:23:07  jpr
! * Added 'Harmonic analysis' option.
! *
! * Revision 1.31  2006/12/18 10:23:44  jpr
! * added 'Constant Bulk Matrix' & check for varying timestep when using
! * 'Linear System Refactorize'.
! *
! * Revision 1.30  2006/12/01 20:23:51  jpr
! * Still about 'Constant Bulk System' and time dependence.
! *
! * Revision 1.28  2006/12/01 12:33:00  jpr
! * More formatting changes.
! *
! * Revision 1.27  2006/12/01 09:47:00  jpr
! * Just a bit of formatting.
! *
! * Revision 1.26  2006/12/01 09:02:17  jpr
! * Initial changes to enable 'constant bulk system' for time dependent
! * simulations.
! *
! * Revision 1.25  2006/11/30 11:03:45  jpr
! * Added keyword 'Constant System' & 'Constant Bulk System'. The usefullness
! * of these keywords is limited: only steady cases work. The 'Constant System'
! * may not be used if boundary reaction forces are to be computed by
! * SolveSystem() (other than for dirichlet boundaries).
! *
! * Revision 1.24  2006/11/28 12:06:49  jpr
! * Relaxed the conditions for insisting user to supply density.
! *
! * Revision 1.23  2006/11/28 11:48:18  jpr
! * Added missing initialization for NodalMeshVelo for non-transient cases.
! *
! * Revision 1.22  2006/11/27 10:23:57  jpr
! * Removed some execess (unrelated) use of TRIM & POINTER.
! *
! * Revision 1.15  2006/04/07 11:22:46  jpr
! * Modified stress computation to include thermal expansion effects.
! *
! * Revision 1.14  2006/02/20 08:06:19  jpr
! * Moved handling of Normal-Tangential BCs inside SolverUtils. Corrected
! * a few bugs in Adaptive.src, Lists.src.
! *
! * Revision 1.13  2006/02/02 07:14:32  jpr
! * Small formatting changes.
! *
! * Revision 1.12  2006/02/01 08:07:59  jpr
! * Replaced most of the usage of MAX_NODES by dynamic allocations.
! *
! * Revision 1.11  2006/01/10 13:48:45  apursula
! * Updated header information (GPL).
! *
! * Revision 1.10  2005/09/01 15:46:07  vierinen
! * windows fixes
! *
! * Revision 1.9  2005/07/07 09:12:30  jpr
! * Changed ElementInfo to have dBasisdx,ddBasisddx as OPTIONAL arguments.
! * Changed all calls to ElementInfo accordingly.
! *
! * Revision 1.8  2005/06/22 04:40:53  jpr
! * Bubbles to global system by default.
! *
! * Revision 1.7  2005/06/21 10:49:57  jpr
! * Removed debug prints...
! *
! * Revision 1.6  2005/06/21 10:04:43  jpr
! * Force BC:s with p-elements should work now.
! *
! * Revision 1.5  2005/06/21 09:38:28  jpr
! * still about the p-stuff
! *
! * Revision 1.4  2005/06/21 09:23:26  jpr
! * p-element corrections... force bc:s need more work.
! *
! * Revision 1.3  2005/06/21 09:05:18  jpr
! * Initial support for p-elements
! *
! * Revision 1.2  2005/05/26 12:33:19  jpr
! * Removed explicit DLLEXPORT definitions
! *
! * Revision 1.1  2005/05/26 08:24:56  vierinen
! * moved .f90 to .src because .f90 is needed for preprosessed files
! *
! * Revision 1.2  2005/05/04 09:16:36  vierinen
! * minor modifications
! *
! * Revision 1.120  2005/04/19 08:53:48  jpr
! * Renamed module LUDecomposition as LinearAlgebra.
! *
! * Revision 1.119  2005/04/15 13:01:42  jpr
! * Corrected a bug in the Stress computation related to bandwidth optimization.
! *
! * Revision 1.114  2005/02/15 13:41:21  jpr
! * Some more cleaning up of the code.
! *
! * Revision 1.113  2005/02/15 09:36:12  jpr
! * Use computed stress solution in StressInsideResidual if present ('Calculate
! * Stresses' activated), instead of trying to compute this to nodes directly.
! *
! * Revision 1.111  2005/02/15 08:28:14  jpr
! * Cleaning up of the residual functions. Some bodyforce & bc options still
! * missing from the r-functions. Also modified the interface to LocalStress
! * to include number of dofs/element different from number of element nodal
! * points.
! *
! * Revision 1.110  2005/02/14 15:04:00  raback
! * Added second strategy for model lumping.
! *
! * Revision 1.109  2005/02/14 10:34:39  jpr
! * Corrected a bug in the boundary residual routine (adaptive meshing).
! *
! * Revision 1.101  2005/02/14 07:04:34  jpr
! * Rewrite of the stress calculation.
! *
! * Revision 1.100  2004/12/16 11:02:07  apursula
! * Added possibility to rotate the elasticity matrix in 3d with
! * anisotropic material
! *
! * Revision 1.99  2004/11/09 08:43:39  jpr
! * Corrected a bug in computing Von Mises stress. The bug resulted in
! * indexing arrays over allocated size when the domain of the displacement
! * solver was not the whole mesh.
! *
! * Revision 1.96  2004/10/15 14:26:43  raback
! * Enabled model lumping for 3D structures loaded at one boundary.
! *
! * Revision 1.93  2004/10/06 11:08:49  jpr
! * Added keyword 'Stress(n)' to sections 'Body Force', 'Boundary Condition'
! * and 'Material'. Added keyword 'Strain(n)' to sections 'Body Force' and
! * 'Material'. These keywords may be used to give stress and strain
! * engineering vectors, with following meanings:
! *
! * Body Force-section:
! * Bulk term of the partial integration of the div(Sigma)*Phi is added
! * as a body force. For divergence free Sigma this amounts to setting
! * the boundary normal stress to (Sigma,n). Given Strain is used to
! * compute Sigma.
! *
! * Material-section:
! * Stress and Strain are used as prestress and prestrains to geometric
! * stiffness and/or buckling analysis (in addition to given load case).
! *
! * Boundary Condition-section:
! * Given Stress is multiplied by normal giving the the normal stress on
! * the boundary.
! *
! * Stress and Strain keywords give the components
! * 2D:
! * Strain(3) = Eta_xx Eta_yy 2*Eta_xy
! * Stress(3) = Sigma_xx Sigma_yy Sigma_xz
! * Axi Symmetric:
! * Strain(4) = Eta_rr Eta_pp Eta_zz 2*Eta_rz
! * Stress(4) = Sigma_rr Sigma_pp Sigma_zz Sigma_rz
! * 3D:
! * Strain(6) = Eta_xx Eta_yy Eta_zz 2*Eta_xy 2*Eta_yz 2*Eta_xz
! * Stress(6) = Sigma_xx Sigma_yy Sigma_zz Sigma_xy Sigma_yz Sigma_xz
! *
! *
! * Revision 1.83  2004/08/09 06:42:16  apursula
! * Changed: asking for Poisson Ratio only in isotropic cases
! *
! * Revision 1.81  2004/07/29 08:11:14  apursula
! * Added complaints if density is not given
! *
! * Revision 1.78  2004/03/04 13:09:11  jpr
! * Modified axisymmetric case to call StressBoundary instead of
! * StressGeneralBoundary to implement boundary damping in axisymmetric cases.
! * Still to be implemented in general coordinate case.
! *
! * Revision 1.77  2004/03/03 09:12:01  jpr
! * Added 3rd argument to GetLocical(...) to stop the complaint about
! * missing "Output Version Numbers" keyword.
! *
! * Revision 1.75  2004/03/01 14:59:55  jpr
! * Modified residual function interfaces for goal oriented adaptivity,
! * no functionality yet.
! * Started log.
! *
! *****************************************************************************/

!------------------------------------------------------------------------------
   SUBROUTINE StressSolver( Model,Solver,dt,Transient )
!DEC$ATTRIBUTES DLLEXPORT :: StressSolver
!------------------------------------------------------------------------------

    USE CoordinateSystems
    USE StressLocal
    USE StressGeneral
    USE Adaptive
    USE DefUtils

    IMPLICIT NONE
!------------------------------------------------------------------------------
!******************************************************************************
!
!  Solve stress equations for one timestep
!
!  ARGUMENTS:
!
!  TYPE(Model_t) :: Model,  
!     INPUT: All model information (mesh,materials,BCs,etc...)
!
!  TYPE(Solver_t) :: Solver
!     INPUT: Linear equation solver options
!
!  REAL(KIND=dp) :: dt,
!     INPUT: Timestep size for time dependent simulations (NOTE: Not used
!            currently)
!
!******************************************************************************

     TYPE(Model_t)  :: Model
     TYPE(Solver_t), TARGET :: Solver

     LOGICAL ::  Transient
     REAL(KIND=dp) :: dt
!------------------------------------------------------------------------------
!    Local variables
!------------------------------------------------------------------------------
     INTEGER :: i,j,k,l,n,ntot,t,iter,STDOFs,istat, body_id

     TYPE(ValueList_t),POINTER :: SolverParams, Equation, Material, BodyForce, BC
     TYPE(Nodes_t) :: ElementNodes
     TYPE(Element_t),POINTER :: Element

     REAL(KIND=dp) :: RelativeChange,UNorm,PrevUNorm, &
              NonlinearTol,s, UzawaParameter

     INTEGER ::  MaxIter, MinIter
     TYPE(Variable_t), POINTER :: StressSol, TempSol, Var, TimeVar

     REAL(KIND=dp), POINTER :: Temperature(:),Displacement(:),Work(:,:,:), &
            VonMises(:), NodalStress(:), StressComp(:), ContactPressure(:), &
            NormalDisplacement(:), TransformMatrix(:,:), UWrk(:,:)

     REAL(KIND=dp) :: UnitNorm, Unit1(3), Unit2(3), Unit3(3), Prevdt=-1, PrevTime=-1

     INTEGER, POINTER :: TempPerm(:),DisplPerm(:),StressPerm(:),NodeIndexes(:)

     LOGICAL :: GotForceBC,Found
     LOGICAL :: PlaneStress, CalcStress, CalcStressAll, Isotropic = .TRUE.
     LOGICAL :: Contact = .FALSE.
     LOGICAL :: stat, stat2, stat3, RotateC, MeshDisplacementActive, &
                ConstantBulkSystem, ConstantBulkMatrix, ConstantBulkMatrixInUse, ConstantSystem, &
                UpdateSystem

     LOGICAL :: AllocationsDone = .FALSE., NormalTangential
     LOGICAL :: StabilityAnalysis = .FALSE., ModelLumping, FixDisplacement
     LOGICAL :: GeometricStiffness = .FALSE., EigenAnalysis=.FALSE., OrigEigenAnalysis, &
           Refactorize = .TRUE.

     REAL(KIND=dp),ALLOCATABLE:: MASS(:,:),STIFF(:,:),&
       DAMP(:,:), LOAD(:,:),FORCE(:), &
       LocalTemperature(:),ElasticModulus(:,:,:),PoissonRatio(:), &
       HeatExpansionCoeff(:,:,:),DampCoeff(:),SpringCoeff(:),Beta(:), &
       ReferenceTemperature(:), Density(:), Damping(:), &
       NodalDisplacement(:,:), ContactLimit(:), LocalNormalDisplacement(:), &
       LocalContactPressure(:), PreStress(:,:), PreStrain(:,:), &
       StressLoad(:,:), StrainLoad(:,:), NodalMeshVelo(:,:)

     SAVE MASS,DAMP, STIFF,LOAD, &
       FORCE,ElementNodes,DampCoeff,SpringCoeff,Beta,Density, Damping, &
       LocalTemperature,AllocationsDone,ReferenceTemperature, &
       ElasticModulus, PoissonRatio,HeatExpansionCoeff, VonMises, NodalStress, &
       CalcStress, CalcStressAll, NodalDisplacement, Contact, ContactPressure, &
       NormalDisplacement, ContactLimit, LocalNormalDisplacement, &
       LocalContactPressure, PreStress, PreStrain, StressLoad, StrainLoad, Work, &
       RotateC, TransformMatrix, body_id, NodalMeshVelo, PrevTime
!------------------------------------------------------------------------------
     INTEGER :: dim
     REAL(KIND=dp) :: at,at0,CPUTime,RealTime
     REAL(KIND=dp) :: LumpedArea, LumpedCenter(3), LumpedMoments(3,3)

     INTERFACE
        FUNCTION StressBoundaryResidual( Model,Edge,Mesh,Quant,Perm, Gnorm ) RESULT(Indicator)
          USE Types
          TYPE(Element_t), POINTER :: Edge
          TYPE(Model_t) :: Model
          TYPE(Mesh_t), POINTER :: Mesh
          REAL(KIND=dp) :: Quant(:), Indicator(2), Gnorm
          INTEGER :: Perm(:)
        END FUNCTION StressBoundaryResidual

        FUNCTION StressEdgeResidual( Model,Edge,Mesh,Quant,Perm ) RESULT(Indicator)
          USE Types
          TYPE(Element_t), POINTER :: Edge
          TYPE(Model_t) :: Model
          TYPE(Mesh_t), POINTER :: Mesh
          REAL(KIND=dp) :: Quant(:), Indicator(2)
          INTEGER :: Perm(:)
        END FUNCTION StressEdgeResidual

        FUNCTION StressInsideResidual( Model,Element,Mesh,Quant,Perm, Fnorm ) RESULT(Indicator)
          USE Types
          TYPE(Element_t), POINTER :: Element
          TYPE(Model_t) :: Model
          TYPE(Mesh_t), POINTER :: Mesh
          REAL(KIND=dp) :: Quant(:), Indicator(2), Fnorm
          INTEGER :: Perm(:)
        END FUNCTION StressInsideResidual
     END INTERFACE
!------------------------------------------------------------------------------
     CHARACTER(LEN=MAX_NAME_LEN) :: VersionID = "$Id: StressSolve.src,v 1.42 2007/04/17 06:57:28 raback Exp $"

!------------------------------------------------------------------------------
!    Check if version number output is requested
!------------------------------------------------------------------------------
     IF ( .NOT. AllocationsDone ) THEN
        IF ( ListGetLogical( GetSimulation(), 'Output Version Numbers', Found ) ) THEN
           CALL Info( 'StressSolve', 'StressSolver version:', Level = 0 ) 
           CALL Info( 'StressSolve', VersionID, Level = 0 ) 
           CALL Info( 'StressSolve', ' ', Level = 0 ) 
        END IF
     END IF

     DIM = CoordinateSystemDimension()
!------------------------------------------------------------------------------
!    Get variables needed for solution
!------------------------------------------------------------------------------
     IF ( .NOT. ASSOCIATED( Solver % Matrix ) ) RETURN
     IF ( COUNT( Solver % Variable % Perm > 0 ) <= 0 ) RETURN

     SolverParams => GetSolverParams()

     StressSol => Solver % Variable
     DisplPerm      => StressSol % Perm
     STDOFs         =  StressSol % DOFs
     Displacement   => StressSol % Values

     TempSol => VariableGet( Solver % Mesh % Variables, 'Temperature' )
     IF ( ASSOCIATED( TempSol) ) THEN
       TempPerm    => TempSol % Perm
       Temperature => TempSol % Values
     END IF

     MeshDisplacementActive = ListGetLogical( Solver % Values,  &
               'Displace Mesh', Found )
     IF ( .NOT. Found ) MeshDisplacementActive = .TRUE.

     IF ( AllocationsDone .AND. MeshDisplacementActive ) THEN
        CALL DisplaceMesh( Solver % Mesh, Displacement, -1, DisplPerm, STDOFs )
     END IF

     UNorm = Solver % Variable % Norm
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!     Allocate some permanent storage, this is done first time only
!------------------------------------------------------------------------------
     IF ( .NOT. AllocationsDone .OR. Solver % Mesh % Changed) THEN
       N = Solver % Mesh % MaxElementDOFs

       IF ( AllocationsDone ) THEN
         DEALLOCATE( Density,                &
                     Damping,                &
                     DampCoeff,              &
                     SpringCoeff,            &
                     ReferenceTemperature,   &
                     HeatExpansionCoeff,     &
                     LocalTemperature,       &
                     ElasticModulus,         &
                     PoissonRatio,           &
                     PreStress, PreStrain,   &
                     StressLoad, StrainLoad, &
                     NodalDisplacement,      &
                     NodalMeshVelo,          &
                     FORCE, MASS, DAMP, STIFF, LOAD, Beta, &
                     ContactLimit, LocalNormalDisplacement, LocalContactPressure, &
                     TransformMatrix )
       END IF

       ALLOCATE( Density( N ),              &
                 Damping( N ),              &
                 DampCoeff( N ),            &
                 PreStress( 6,N ),          &
                 PreStrain( 6,N ),          &
                 StressLoad( 6,N ),         &
                 StrainLoad( 6,N ),         &
                 SpringCoeff( N ),          &
                 ReferenceTemperature( N ), &
                 HeatExpansionCoeff( 3,3,N ), &
                 LocalTemperature( N ),       &
                 ElasticModulus(6,6,N),       &
                 PoissonRatio( N ),           &
                 FORCE( STDOFs*N ),           &
                 MASS(  STDOFs*N,STDOFs*N ),  &
                 DAMP(  STDOFs*N,STDOFs*N ),  &
                 STIFF( STDOFs*N,STDOFs*N ),  &
                 NodalDisplacement( 3, N ),   &
                 NodalMeshVelo( 3, N ),       &
                 LOAD( 4,N ), Beta( N ),      &
                 ContactLimit(N), LocalNormalDisplacement(N), &
                 LocalContactPressure(N),     &
                 TransformMatrix(3,3),  STAT=istat )


       NULLIFY( Work )

       TransformMatrix = 0.0d0

       IF ( .NOT. AllocationsDone ) THEN
          CalcStressAll = GetLogical( SolverParams, 'Calculate Stresses',Found )

          CalcStress = .FALSE.
          DO i=1,Model % NumberOfEquations
             CalcStress = CalcStress .OR. GetLogical( &
                 Model % Equations(i) % Values, 'Calculate Stresses', Found )

             IF ( .NOT. Found .AND. CalcStressAll ) THEN
                CALL ListAddLogical( &
                    Model % Equations(i) % Values, 'Calculate Stresses', .TRUE. )
             END IF
          END DO

          IF ( CalcStress .OR. CalcStressAll ) THEN
             n = SIZE( Displacement ) / STDOFs

             Var => VariableGet( Solver % Mesh % Variables, 'Stress' )
             IF ( .NOT. ASSOCIATED( Var ) ) THEN
               ALLOCATE( NodalStress( 6*n ) )
               CALL VariableAdd(Solver % Mesh % Variables, Solver % Mesh, Solver, &
                           'Stress', 6, NodalStress, DisplPerm )

               DO i=1,6
                  StressComp => NodalStress(i::6)
                  CALL VariableAdd(Solver % Mesh % Variables,Solver % Mesh,Solver, &
                     'Stress '//CHAR(i+ICHAR('0')), 1, StressComp, DisplPerm )
               END DO
             END IF

             Var => VariableGet( Solver % Mesh % Variables, 'VonMises' )
             IF ( .NOT. ASSOCIATED( Var ) ) THEN
               ALLOCATE( VonMises( n ) )
               CALL VariableAdd(Solver % Mesh % Variables, Solver % Mesh, Solver, &
                           'VonMises', 1, VonMises, DisplPerm )
             END IF
          END IF

          Contact = GetLogical( SolverParams, 'Contact', Found )
          IF( Contact ) THEN
             n = SIZE( Displacement ) / STDOFs
             ALLOCATE( ContactPressure( n ), NormalDisplacement( n ) )
             ContactPressure = 0.0d0
             NormalDisplacement = 0.0d0
             CALL VariableAdd(Solver % Mesh % Variables, Solver % Mesh, Solver, &
                  'Contact Pressure', 1, ContactPressure, DisplPerm )
          END IF

       END IF

       IF ( istat /= 0 ) THEN
          CALL Fatal( 'StressSolve', 'Memory allocation error.' )
       END IF

       AllocationsDone = .TRUE.
     END IF

!------------------------------------------------------------------------------
!    Do some additional initialization, and go for it
!------------------------------------------------------------------------------
     IF ( CalcStress .OR. CalcStressAll ) THEN
        Var => VariableGet( Solver % Mesh % Variables, 'VonMises', .TRUE. )
        VonMises => Var % Values
        Var => VariableGet( Solver % Mesh % Variables, 'Stress', .TRUE. )
        StressPerm  => Var % Perm
        NodalStress => Var % Values
     END IF

!------------------------------------------------------------------------------
     NonlinearTol = GetConstReal( SolverParams, &
        'Nonlinear System Convergence Tolerance', Found )

     MaxIter = GetInteger( SolverParams, &
         'Nonlinear System Max Iterations',Found )
     IF ( .NOT.Found ) MaxIter = 1

     MinIter = GetInteger( SolverParams, &
         'Nonlinear System Min Iterations',Found )

     EigenAnalysis = GetLogical( SolverParams, 'Eigen Analysis', Found )
     OrigEigenAnalysis = EigenAnalysis

     StabilityAnalysis = GetLogical( SolverParams, 'Stability Analysis', Found )
     IF( .NOT. Found ) StabilityAnalysis = .FALSE.

     IF( StabilityAnalysis .AND. (CurrentCoordinateSystem() /= Cartesian) ) &
         CALL Fatal( 'StressSolve', &
          'Only cartesian coordinate system is allowed in stability analysis.' )

     GeometricStiffness = GetLogical( SolverParams, 'Geometric Stiffness', Found )
     IF (.NOT. Found ) GeometricStiffness = .FALSE.

     IF( GeometricStiffness .AND. (CurrentCoordinateSystem() /= Cartesian) ) &
          CALL Fatal( 'StressSolve', &
          'Only cartesian coordinates are allowed with geometric stiffness.' )

     IF ( StabilityAnalysis .AND. GeometricStiffness )  &
          CALL Fatal( 'StressSolve', &
          'Stability analysis and geometric stiffening can not be activated simultaneously.' )

     IF ( StabilityAnalysis .OR. GeometricStiffness ) THEN
       MinIter = 2
       MaxIter = 2
     END IF

!------------------------------------------------------------------------------
     Refactorize = GetLogical( SolverParams, 'Linear System Refactorize', Found )
     IF ( .NOT. Found ) Refactorize = .TRUE.
     IF ( Transient .AND. .NOT. Refactorize .AND. dt /= Prevdt ) THEN
        CALL ListAddLogical( SolverParams, 'Linear System Refactorize', .TRUE. )
     END IF
     ConstantSystem = GetLogical( SolverParams, 'Constant System', Found )
     ConstantBulkSystem = GetLogical( SolverParams, 'Constant Bulk System', Found )
     ConstantBulkMatrix = GetLogical( SolverParams, 'Constant Bulk Matrix', Found )
!------------------------------------------------------------------------------

     UpdateSystem = .FALSE.
     IF( .NOT. ListGetString( CurrentModel % Simulation,'Simulation Type') == 'steady state') THEN
       UpdateSystem = GetLogical( SolverParams, 'Update Transient System', Found )
       IF(UpdateSystem) THEN
         TimeVar => VariableGet( Solver % Mesh % Variables, 'Time' )            
         IF (ABS(TimeVar % Values(1) - PrevTime) > AEPS) THEN
           PrevTime = TimeVar % Values(1)
         ELSE
           UpdateSystem = .FALSE.
         END IF
       END IF
     END IF

     ModelLumping = GetLogical( SolverParams, 'Model Lumping', Found )
     IF ( ModelLumping ) THEN       
       IF(DIM /= 3) CALL Fatal('StressSolve','Model Lumping implemented only for 3D')
       FixDisplacement = GetLogical( SolverParams, 'Fix Displacement', Found )
       IF(.NOT. Found) FixDisplacement = .TRUE.
       IF(FixDisplacement) THEN
         CALL Info( 'StressSolve', 'Using six fixed displacement to compute the spring matrix' ) 
       ELSE
         CALL Info( 'StressSolve', 'Using six pure forces and moments to compute the spring matrix' ) 
       END IF
       MinIter = 6
       MaxIter = 6
       ConstantBulkSystem = .TRUE.
       CALL CoordinateIntegrals(LumpedArea, LumpedCenter, LumpedMoments, &
            Model % MaxElementNodes)
       CALL LumpedCartesianMass()
     END IF


     DO iter=1,MaxIter
       IF( StabilityAnalysis .OR. GeometricStiffness ) THEN
          SELECT CASE( iter )
          CASE( 1 )
            EigenAnalysis = .FALSE.
          CASE DEFAULT
            EigenAnalysis = OrigEigenAnalysis
          END SELECT
          CALL ListAddLogical( SolverParams, 'Eigen Analysis', EigenAnalysis )
       END IF

       at  = CPUTime()
       at0 = RealTime()

       CALL Info( 'StressSolve', ' ', Level=4 )
       CALL Info( 'StressSolve', ' ', Level=4 )
       CALL Info( 'StressSolve', '-------------------------------------',Level=4 )
       WRITE( Message, * ) 'DISPLACEMENT SOLVER ITERATION', iter
       CALL Info( 'StressSolve', Message,Level=4 )
       CALL Info( 'StressSolve', '-------------------------------------',Level=4 )
       CALL Info( 'StressSolve', ' ', Level=4 )
       CALL Info( 'StressSolve', 'Starting assembly...',Level=4 )
!------------------------------------------------------------------------------

       ConstantBulkMatrixInUse = ConstantBulkMatrix .AND. &
           ASSOCIATED(Solver % Matrix % BulkValues)

       IF ( ASSOCIATED(Solver % Matrix % BulkValues) .AND. .NOT. UpdateSystem) THEN
         IF ( ConstantBulkMatrix .OR. ConstantBulkSystem .OR. ConstantSystem ) THEN
           Solver % Matrix % DampValues = 0.0d0
           Solver % Matrix % Values = Solver % Matrix % BulkValues
         END IF

         IF ( ConstantBulkSystem .OR. ConstantSystem ) THEN
           Solver % Matrix % RHS  = Solver % Matrix % BulkRHS
         ELSE IF ( ConstantBulkMatrix ) THEN
           Solver % Matrix % RHS = 0.0_dp
         END IF

         IF ( ConstantBulkMatrix ) GO TO 1000
         IF ( ConstantBulkSystem ) GO TO 2000
         IF ( ConstantSystem )     GO TO 3000
       END IF

       CALL DefaultInitialize()

1000   CALL BulkAssembly()

2000   CALL Info( 'StressSolve', 'Assembly done', Level=4 )
       CALL BCAssembly()

3000   IF ( Transient .AND.(ConstantBulkMatrix .OR. &
           ConstantBulkSystem .OR. ConstantSystem) ) CALL AddGlobalTime()
       CALL DefaultFinishAssembly()
       CALL DefaultDirichletBCS()

       IF( ModelLumping .AND. FixDisplacement) THEN
         CALL LumpedDisplacements( Model, iter, LumpedArea, LumpedCenter)
       END IF
       CALL Info( 'StressSolve', 'Set boundaries done', Level=4 )

       ! Solve the system and check for convergence:
       !--------------------------------------------
       PrevUNorm = UNorm
       UNorm = DefaultSolve()
       IF ( Transient .AND. .NOT. Refactorize .AND. dt /= Prevdt ) THEN
         Prevdt = dt
         CALL ListAddLogical( SolverParams, 'Linear System Refactorize', .FALSE. )
       END IF

       IF ( PrevUNorm + UNorm /= 0.0d0 ) THEN
          RelativeChange = 2.0d0 * ABS( PrevUNorm - UNorm) / ( PrevUnorm + UNorm)
       ELSE
          RelativeChange = 0.0d0
       END IF

       WRITE( Message, * ) 'Result Norm   : ',UNorm
       CALL Info( 'StressSolve', Message, Level=4 )
       WRITE( Message, * ) 'Relative Change : ',RelativeChange
       CALL Info( 'StressSolve', Message, Level=4 )

       ! Update contact pressure:
       !-------------------------
       IF ( Contact ) THEN
         CALL ComputeNormalDisplacement( Displacement, &
            NormalDisplacement, DisplPerm, STDOFs )
         
         UzawaParameter = GetConstReal( SolverParams, 'Uzawa Parameter', Found )
         IF( .NOT.Found ) THEN
            WRITE( Message, * ) 'Using default value 1.0 for Uzawa parameter'
            CALL Info( 'StressSolve', Message, Level=4 )
            UzawaParameter = 1.0d0
         END IF
         
         ContactPressure = MAX( 0.0d0, ContactPressure &
              + UzawaParameter * NormalDisplacement )
       END IF

       IF ( Iter> MinIter .AND. RelativeChange < NonLinearTol ) EXIT

       IF ( CalcStress .OR. CalcStressAll ) THEN
          IF( StabilityAnalysis .AND. Iter == 1 ) THEN
             CALL ComputeStress( Displacement, NodalStress,  &
                    VonMises, DisplPerm, StressPerm )
             CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Stress' )
             CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'VonMises' )
          END IF
       END IF

       IF( ModelLumping ) THEN
         CALL LumpedSprings(iter,LumpedArea, LumpedCenter, LumpedMoments, &
             Model % MaxElementNodes)
       END IF
     END DO ! of nonlinear iter
!------------------------------------------------------------------------------

     IF ( CalcStress .OR. CalcStressAll ) THEN
        IF( .NOT. StabilityAnalysis ) THEN
           CALL ComputeStress( Displacement, NodalStress, &
                 VonMises, DisplPerm, StressPerm )
           CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'Stress' )
           CALL InvalidateVariable( Model % Meshes, Solver % Mesh, 'VonMises' )
        END IF
     END IF

     IF ( GetLogical( SolverParams, 'Adaptive Mesh Refinement', Found) ) THEN
        CALL RefineMesh( Model, Solver, Displacement, DisplPerm, &
             StressInsideResidual, StressEdgeResidual, StressBoundaryResidual )

        IF ( MeshDisplacementActive ) THEN
          StressSol => Solver % Variable
           IF ( .NOT.ASSOCIATED( Solver % Mesh, Model % Mesh ) ) &
             CALL DisplaceMesh( Solver % Mesh, StressSol % Values, 1, &
                 StressSol % Perm, StressSol % DOFs,.FALSE.)
        END IF
     END IF
 
     IF ( MeshDisplacementActive ) THEN
        CALL DisplaceMesh(Model % Mesh, Displacement, 1, &
                DisplPerm, STDOFs, .FALSE. )
     END IF

CONTAINS
 
!------------------------------------------------------------------------------
  SUBROUTINE BulkAssembly()
!------------------------------------------------------------------------------
     body_id = -1
     DO t=1,Solver % NumberOFActiveElements

       IF ( RealTime() - at0 > 1.0 ) THEN
         WRITE(Message,'(a,i3,a)' ) '   Assembly: ', INT(100.0 - 100.0 * &
          (Solver % NumberOfActiveElements-t) / &
             (1.0*Solver % NumberOfActiveElements)), ' % done'
                     
         CALL Info( 'StressSolve', Message, Level=5 )
         at0 = RealTime()
       END IF

!------------------------------------------------------------------------------

       Element => GetActiveElement(t)
       n = GetElementNOFNOdes()
       ntot = GetElementNOFDOFs()

       NodeIndexes => Element % NodeIndexes
       CALL GetElementNodes( ElementNodes )

       Equation => GetEquation()
       PlaneStress = GetLogical( Equation, 'Plane Stress',Found )

       Material => GetMaterial()
       Density(1:n) = GetReal( Material, 'Density', Found )
       IF ( .NOT. Found )  THEN
         IF ( Transient .OR. Solver % NOFEigenValues > 0 ) &
            CALL Fatal( 'StressSolve', 'No value for density found.' )
       END IF
       Damping(1:n) = GetReal( Material, 'Damping', Found )

       CALL InputTensor( HeatExpansionCoeff, Isotropic,  &
           'Heat Expansion Coefficient', Material, n, NodeIndexes )

       CALL InputTensor( ElasticModulus, Isotropic, &
           'Youngs Modulus', Material, n, NodeIndexes )

       PoissonRatio = 0.0d0
       IF ( Isotropic )  PoissonRatio(1:n) = GetReal( Material, 'Poisson Ratio' )

       ReferenceTemperature(1:n) = GetReal(Material, &
             'Reference Temperature', Found )

       IF ( .NOT. ConstantBulkMatrixInUse ) THEN
         PreStress = 0.0d0
         PreStrain = 0.0d0
         CALL ListGetRealArray( Material, 'Stress', Work, n, NodeIndexes, Found )
         IF ( Found ) THEN
            k = SIZE(Work,1)
            PreStress(1:k,1:n) = Work(1:k,1,1:n)
         END IF
         CALL ListGetRealArray( Material, 'Strain', Work, n, NodeIndexes, Found )
         IF ( Found ) THEN
            k = SIZE(Work,1)
            PreStrain(1:k,1:n) = Work(1:k,1,1:n)
         END IF
       END IF

       ! Check need for elasticity matrix rotation:
       !-------------------------------------------
       IF ( Element % BodyId /= body_id ) THEN
         body_id = Element % BodyId
         RotateC = GetLogical( Material, 'Rotate Elasticity Tensor', stat )

         IF ( RotateC ) THEN
            CALL GetConstRealArray( Material, UWrk, &
                'Material Coordinates Unit Vector 1', stat, Element )
            IF ( stat ) THEN
              Unit1(1:3) = UWrk(1:3,1)
            ELSE
              Unit1(1:3) = (/ 1.0d0, 0.0d0, 0.0d0 /)
            END IF

            UnitNorm = SQRT( SUM( Unit1(1:3) * Unit1(1:3) ) )
            IF ( UnitNorm > 0.0001 )  Unit1 = Unit1 / UnitNorm

            CALL GetConstRealArray( Material, UWrk, &
                'Material Coordinates Unit Vector 2', stat2, Element )
            IF ( stat2 ) THEN
              Unit2(1:3) = UWrk(1:3,1)
            ELSE
              Unit2(1:3) = (/ 0.0d0, 1.0d0, 0.0d0 /)
            END IF

            UnitNorm = SQRT( SUM( Unit2(1:3) * Unit2(1:3) ) )
            IF ( UnitNorm > 0.0001 )  Unit2 = Unit2 / UnitNorm

            CALL GetConstRealArray( Material, UWrk, &
                'Material Coordinates Unit Vector 3', stat3, Element )
            IF ( stat3 ) THEN
              Unit3(1:3) = UWrk(1:3,1)
            ELSE
              Unit3(1:3) = (/ 0.0d0, 0.0d0, 1.0d0 /)
            END IF

            UnitNorm = SQRT( SUM( Unit3(1:3) * Unit3(1:3) ) )
            IF ( UnitNorm > 0.0001 )  Unit3 = Unit3/UnitNorm

            IF ( stat .OR. stat2 .OR. stat3 ) THEN
              DO i = 1, 3
                TransformMatrix(1,i) = Unit1(i)
                TransformMatrix(2,i) = Unit2(i)
                TransformMatrix(3,i) = Unit3(i)
              END DO
            ELSE
              CALL Info( 'StressSolver', &
                  'No unit vectors found. Skipping rotation of C', LEVEL=8 )
            END IF
          END IF
        END IF

       ! Set body forces:
       !-----------------
       BodyForce => GetBodyForce()
       LOAD = 0.0D0
       StressLoad = 0.0d0
       StrainLoad = 0.0d0
       IF ( ASSOCIATED( BodyForce ) ) THEN
         LOAD(1,1:n)  = GetReal( BodyForce, 'Stress Bodyforce 1', Found )
         LOAD(2,1:n)  = GetReal( BodyForce, 'Stress Bodyforce 2', Found )
         LOAD(3,1:n)  = GetReal( BodyForce, 'Stress Bodyforce 3', Found )
         LOAD(4,1:n)  = GetReal( BodyForce, 'Stress Pressure', Found )

         CALL ListGetRealArray( BodyForce, 'Stress', Work, n, NodeIndexes, Found )
         IF ( Found ) THEN
            k = SIZE(Work,1)
            StressLoad(1:k,1:n) = Work(1:k,1,1:n)
         END IF

         CALL ListGetRealArray( BodyForce, 'Strain', Work, n, NodeIndexes, Found )
         IF ( Found ) THEN
            k = SIZE(Work,1)
            StrainLoad(1:k,1:n) = Work(1:k,1,1:n)
         END IF
       END IF

       ! Get element local stiffness & mass matrices:
       !---------------------------------------------
       CALL GetScalarLocalSolution( LocalTemperature, 'Temperature' )
       LocalTemperature(1:n) = LocalTemperature(1:n) - &
               ReferenceTemperature(1:n)

       IF ( .NOT. ConstantBulkMatrixInUse ) THEN
         CALL GetVectorLocalSolution( NodalDisplacement )
         IF ( Transient ) THEN
           NodalMeshVelo(3,1:n) = GetReal( Material, 'Mesh Velocity 3', Found)
           NodalMeshVelo(2,1:n) = GetReal( Material, 'Mesh Velocity 2', Found)
           NodalMeshVelo(1,1:n) = GetReal( Material, 'Mesh Velocity 1', Found)
           IF ( .NOT. Found ) THEN
             CALL GetVectorLocalSolution( NodalMeshVelo, 'Mesh Velocity' )
           END IF
         ELSE
           NodalMeshVelo   = 0.0d0
         END IF
       END IF

       SELECT CASE( CurrentCoordinateSystem() )
       CASE( Cartesian, AxisSymmetric, CylindricSymmetric )
          IF ( ConstantBulkMatrixInUse ) THEN
            CALL StressForceCompose( FORCE, LOAD, ElasticModulus, PoissonRatio,     &
              PlaneStress, Isotropic,StressLoad, StrainLoad, HeatExpansionCoeff,    &
              LocalTemperature, Element, n, ntot, ElementNodes, RotateC, TransformMatrix )
          ELSE
            CALL StressCompose( MASS, DAMP, STIFF, FORCE, LOAD, ElasticModulus,     &
               PoissonRatio, Density, Damping, PlaneStress, Isotropic,              &
               PreStress, PreStrain, StressLoad, StrainLoad, HeatExpansionCoeff,    &
               LocalTemperature, Element, n, ntot, ElementNodes, StabilityAnalysis  &
               .AND. iter>1, GeometricStiffness .AND. iter>1, NodalDisplacement,    &
               RotateC, TransformMatrix, NodalMeshVelo )
          END IF

       CASE DEFAULT
          CALL StressGeneralCompose( MASS, STIFF,FORCE, LOAD, ElasticModulus, &
             PoissonRatio,Density,PlaneStress,Isotropic,HeatExpansionCoeff,   &
             LocalTemperature, Element,n,ElementNodes )
       END SELECT
!------------------------------------------------------------------------------
!      If time dependent simulation, add mass matrix to global 
!      matrix and global RHS vector
!------------------------------------------------------------------------------
       IF ( .NOT. (ConstantBulkMatrix .OR. ConstantBulkSystem .OR. ConstantSystem) ) THEN
         IF ( Transient .AND. Solver % NOFEigenValues <= 0 )  THEN
            CALL Default2ndOrderTime( MASS, DAMP, STIFF, FORCE )
         END IF
       END IF
!------------------------------------------------------------------------------
!      Update global matrices from local matrices 
!------------------------------------------------------------------------------
       IF ( ConstantBulkMatrixInUse ) THEN
         CALL DefaultUpdateForce( FORCE, BulkUpdate=.TRUE. )
       ELSE
         CALL DefaultUpdateEquations( STIFF, FORCE, BulkUpdate=.TRUE. )

         IF ( Solver % NOFEigenValues>0 .OR. &
           ConstantBulkMatrix .OR. ConstantBulkSystem .OR. ConstantSystem ) THEN
           CALL DefaultUpdateMass( MASS )
           CALL DefaultUpdateDamp( DAMP )
         END IF
       END IF

!------------------------------------------------------------------------------
     END DO
!------------------------------------------------------------------------------
   END SUBROUTINE BulkAssembly
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!     Neumann & Newton boundary conditions
!------------------------------------------------------------------------------
   SUBROUTINE BCAssembly()
!------------------------------------------------------------------------------
     DO t = 1, Solver % Mesh % NumberOfBoundaryElements

       Element => GetBoundaryElement(t)
       IF ( .NOT. ActiveBoundaryElement() .OR. GetElementFamily() == 1 ) CYCLE
       n = GetElementNOFNodes()
       ntot = GetElementNOFDOFs()

       BC => GetBC()
       IF ( ASSOCIATED( BC ) ) THEN
!------------------------------------------------------------------------------
          CALL GetElementNodes( ElementNodes )

          LOAD  = 0.0d0
          Beta  = 0.0d0
          DampCoeff   = 0.0d0
          SpringCoeff = 0.0d0

          ! Force in given direction BC: \tau\cdot n = F:
          !----------------------------------------------
          GotForceBC = .FALSE.
          LOAD(1,1:n) = GetReal( BC, 'Force 1',Found )
          GotForceBC = GotForceBC .OR. Found
          LOAD(2,1:n) = GetReal( BC, 'Force 2',Found )
          GotForceBC = GotForceBC .OR. Found
          LOAD(3,1:n) = GetReal( BC, 'Force 3',Found )
          GotForceBC = GotForceBC .OR. Found
          Beta(1:n) =  GetReal( BC, 'Normal Force',Found )
          GotForceBC = GotForceBC .OR. Found
          CALL ListGetRealArray( BC, 'Stress', Work, &
                  n, NodeIndexes, Found )
          GotForceBC = GotForceBC .OR. Found
          StressLoad = 0.0d0
          IF ( Found ) THEN
             k = SIZE(Work,1)
             StressLoad(1:k,1:n) = Work(1:k,1,1:n)
          END IF
          DampCoeff(1:n) =  GetReal( BC, 'Damping', Found )
          GotForceBC = GotForceBC .OR. Found
          SpringCoeff(1:n) =  GetReal( BC, 'Spring', Found )
          GotForceBC = GotForceBC .OR. Found
          ContactLimit(1:n) =  GetReal( BC, 'Contact Limit', Found )
          GotForceBC = GotForceBC .OR. Found

          IF(ModelLumping .AND. .NOT. FixDisplacement) THEN
            IF(GetLogical( BC, 'Model Lumping Boundary',Found )) THEN
              CALL LumpedLoads( iter, LumpedArea, LumpedCenter, LumpedMoments, Load )
              GotForceBC = .TRUE.
            END IF
          END IF

          IF ( .NOT. GotForceBC ) CYCLE
!---------------------------------------------------------------------------
          IF( Contact ) THEN
             CALL GetScalarLocalSolution( LocalContactPressure, 'Contact Pressure' )
             Beta = Beta - LocalContactPressure
          END IF 

          NormalTangential = GetLogical( BC, 'Normal-Tangential ' // & 
            Solver % Variable % Name(1:Solver % Variable % Namelen), Found )

          SELECT CASE( CurrentCoordinateSystem() )
          CASE( Cartesian, AxisSymmetric, CylindricSymmetric )
             CALL StressBoundary( STIFF,DAMP,FORCE,LOAD,SpringCoeff,DampCoeff, &
              Beta, StressLoad, NormalTangential, Element,n,ntot,ElementNodes )
          CASE DEFAULT
             DAMP = 0.0d0
             CALL StressGeneralBoundary( STIFF,FORCE, LOAD, SpringCoeff,Beta, &
                              Element,n,ElementNodes )
          END SELECT

          IF ( .NOT. (ConstantSystem .OR. ConstantBulkSystem .OR. ConstantBulkMatrix ) ) THEN
            IF ( Transient .AND. Solver % NOFEigenValues <= 0 )  THEN
               MASS = 0.0d0
               CALL Default2ndOrderTime( MASS, DAMP, STIFF, FORCE )
            END IF
          END IF

          ! Update global matrices from local matrices:;
          !---------------------------------------------
          CALL DefaultUpdateEquations( STIFF, FORCE, BulkUpdate=ConstantSystem )
          IF ( Solver % NOFEigenValues>0 .OR. ConstantSystem.AND.Transient ) THEN
             CALL DefaultUpdateDamp( DAMP )
          END IF
!------------------------------------------------------------------------------
         END IF
      END DO
!------------------------------------------------------------------------------
   END SUBROUTINE BCAssembly
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE AddGlobalTime()
!------------------------------------------------------------------------------
     INTEGER :: i,j,k,l,n
     REAL(KIND=dp) :: FORCE(1)
     REAL(KIND=dp), POINTER :: SaveValues(:) => NULL()
     REAL(KIND=dp), ALLOCATABLE :: STIFF(:,:),MASS(:,:),DAMP(:,:),X(:),V(:),A(:)
     SAVE STIFF, MASS, DAMP, X, V, A

     IF ( .NOT.ASSOCIATED(Solver % Variable % Values, SaveValues) ) THEN
        IF ( ALLOCATED(STIFF) ) DEALLOCATE( STIFF,MASS,DAMP,V,X,A )

        n = 0
        DO i=1,Solver % Matrix % NumberOfRows
          n = MAX( n,Solver % Matrix % Rows(i+1)-Solver % Matrix % Rows(i) )
        END DO
        ALLOCATE( STIFF(1,n),MASS(1,n),DAMP(1,n),V(n),X(n),A(n) )

        SaveValues => Solver % Variable % Values
     END IF

     DO i=1,Solver % Matrix % NumberOFRows
       n = 0
       DO j=Solver % Matrix % Rows(i),Solver % Matrix % Rows(i+1)-1
         n = n + 1
         STIFF(1,n) = Solver % Matrix % Values(j)
         MASS(1,n)  = Solver % Matrix % MassValues(j)
         DAMP(1,n)  = Solver % Matrix % DampValues(j)

         X(n) = Solver % Variable % PrevValues(Solver % Matrix % Cols(j),3)
         V(n) = Solver % Variable % PrevValues(Solver % Matrix % Cols(j),4)
         A(n) = Solver % Variable % PrevValues(Solver % Matrix % Cols(j),5)
       END DO
       FORCE(1) = Solver % Matrix % RHS(i)
       Solver % Matrix % Force(i,1) = FORCE(1)
       CALL Bossak2ndOrder( n,dt,MASS,DAMP,STIFF,FORCE,X,V,A,Solver % Alpha )
       n = 0
       DO j=Solver % Matrix % Rows(i),Solver % Matrix % Rows(i+1)-1
         n = n + 1
         Solver % Matrix % Values(j) = STIFF(1,n)
       END DO
       Solver % Matrix % RHS(i) = FORCE(1)
     END DO
!------------------------------------------------------------------------------
  END SUBROUTINE AddGlobalTime
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  SUBROUTINE ComputeNormalDisplacement( Displacement, NormalDisplacement, &
       DisplPerm, STDOfs )
!------------------------------------------------------------------------------
    INTEGER :: DisplPerm(:), STDOfs
    REAL(KIND=dp) :: Displacement(:), NormalDisplacement(:)
!------------------------------------------------------------------------------
    INTEGER, PARAMETER :: MaxNodes = 100
    TYPE( Element_t ), POINTER :: Element
    TYPE( ValueList_t ), POINTER :: BC
    REAL( KIND=dp ) :: Normal(3), LocalDisplacement(3), U, V
    REAL( KIND=dp ) :: ContactLimit( MaxNodes )
    INTEGER :: i, j, k, t, n
    LOGICAL :: ContactBoundary, Found
    INTEGER, POINTER :: Visited(:)

    TYPE( Nodes_t ) :: ElementNodes
    SAVE ElementNodes

    ALLOCATE( Visited(SIZE(DisplPerm)) )
    Visited = 0

    NormalDisplacement = 0.0d0

    DO t = 1, Solver % Mesh % NumberOfBoundaryElements
       Element => GetBoundaryElement(t)
       IF ( .NOT. ActiveBoundaryElement() .OR. GetElementFamily() == 1 ) CYCLE
       n = GetElementNOFNodes()
       BC => GetBC()
       
       IF ( ASSOCIATED( BC ) ) THEN
          ContactBoundary = GetLogical( BC, 'Contact Boundary', Found ) 
          IF( .NOT.Found .OR. .NOT.ContactBoundary ) CYCLE
!------------------------------------------------------------------------------
          ContactLimit(1:n) =  GetReal( BC, 'Contact Limit', Found )
          IF( .NOT.Found ) ContactLimit = 9.9d9
             
          CALL GetElementNodes( ElementNodes )
          
          DO i = 1,n
             U = Element % TYPE % NodeU(i)
             V = Element % TYPE % NodeV(i)
             
             Normal = NormalVector( Element, ElementNodes, U, V, .TRUE. )    
             k = DisplPerm( Element % NodeIndexes(i) )
             
             LocalDisplacement = 0.0d0
             DO j = 1,STDOFs
                LocalDisplacement( j ) = Displacement( STDOFs*(k-1)+j )
             END DO
             
             NormalDisplacement( k ) = NormalDisplacement( k ) & 
                  + SUM( Normal(1:3) * LocalDisplacement(1:3) ) - ContactLimit(i)

             Visited( k ) = Visited( k ) + 1
             
          END DO
!------------------------------------------------------------------------------
       END IF
    END DO
!------------------------------------------------------------------------------
    WHERE( Visited >= 1 ) NormalDisplacement = NormalDisplacement / Visited

    DEALLOCATE( Visited )
!------------------------------------------------------------------------------
  END SUBROUTINE ComputeNormalDisplacement
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   SUBROUTINE ComputeStress( Displacement, NodalStress, &
              VonMises, DisplPerm, StressPerm )
!------------------------------------------------------------------------------
     INTEGER :: DisplPerm(:)
     INTEGER, POINTER :: StressPerm(:)
     REAL(KIND=dp) :: VonMises(:), NodalStress(:), Displacement(:)
!------------------------------------------------------------------------------
     TYPE(Nodes_t) :: Nodes
     INTEGER :: n,nd
     TYPE(Element_t), POINTER :: Element

     INTEGER :: i,j,k,l,p,q, t, dim,elem, IND(9), BodyId,EqId
     LOGICAL :: stat, CSymmetry, Isotropic, ComputeFlag
     INTEGER, POINTER :: Visited(:), Indexes(:), Permutation(:)
     REAL(KIND=dp) :: u,v,w,x,y,z,Strain(3,3),Stress(3,3),LGrad(3,3),detJ, &
          Young, Poisson, Ident(3,3), C(6,6), S(6), weight, st, Work(9), Principal(3), Relax
     REAL(KIND=dp), ALLOCATABLE :: Basis(:),dBasisdx(:,:),  FORCE(:), ForceG(:), &
        SBasis(:,:), LocalDisplacement(:,:), MASS(:,:)

     REAL(KIND=dp), POINTER :: StressTemp(:)

     TYPE(Solver_t), POINTER :: StSolver
     LOGICAL :: FirstTime = .TRUE., OptimizeBW, GlobalBubbles

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     SAVE Nodes, StSolver, ForceG, Permutation
!------------------------------------------------------------------------------

     dim = CoordinateSystemDimension()

     n = MAX( Solver % Mesh % MaxElementDOFs, Solver % Mesh % MaxElementNodes )
     ALLOCATE( Indexes(n), LocalDisplacement(3,n) )
     ALLOCATE( MASS(n,n), FORCE(6*n) )
     ALLOCATE( Basis(n), dBasisdx(n,3) )

     IF ( FirstTime .OR. Solver % Mesh % Changed ) THEN
       IF ( FirstTime ) THEN
         ALLOCATE( StSolver )
       ELSE
         DEALLOCATE( ForceG )
         CALL FreeMatrix( StSolver % Matrix )
       END IF

       StSolver = Solver
       StSolver % Variable => VariableGet( StSolver % Mesh % Variables, &
                  'StressTemp', ThisOnly=.TRUE. )
       IF ( ASSOCIATED( StSolver % Variable ) ) THEN
          Permutation => StSolver % Variable % Perm
       ELSE
          ALLOCATE( Permutation( SIZE(Solver % Variable % Perm) ) )
       END IF

       OptimizeBW = GetLogical( StSolver % Values, 'Optimize Bandwidth', Found )
       IF ( .NOT. Found ) OptimizeBW = .TRUE.

       GlobalBubbles = GetLogical(SolverParams,'Bubbles in Global System',Found )
       IF (.NOT.Found ) GlobalBubbles=.TRUE.

       StSolver % Matrix => CreateMatrix( Model, Solver, Solver % Mesh, Permutation, &
        1, MATRIX_CRS, OptimizeBW, 'Calculate Stresses', GlobalBubbles=GlobalBubbles )
       ALLOCATE( StSolver % Matrix % RHS(StSolver % Matrix % NumberOfRows) )

       ALLOCATE( ForceG(StSolver % Matrix % NumberOfRows*6) )

       IF ( .NOT. ASSOCIATED( StSolver % Variable ) ) THEN
          ALLOCATE( StressTemp(StSolver % Matrix % NumberOfRows) )
          StressTemp   = 0.0d0
          CALL VariableAdd( StSolver % Mesh % Variables, StSolver % Mesh, StSolver, &
                 'StressTemp', 1, StressTemp, StressPerm, Output=.FALSE. )
          StSolver % Variable => VariableGet( StSolver % Mesh % Variables, 'StressTemp' )
       END IF
       FirstTime = .FALSE.
     END IF

     Model % Solver => StSolver

     Ident = 0.0d0
     DO i=1,3
        Ident(i,i) = 1.0d0
     END DO

     CSymmetry = CurrentCoordinateSystem() == AxisSymmetric .OR. &
                 CurrentCoordinateSystem() == CylindricSymmetric

     IND = (/ 1, 4, 6, 4, 2, 5, 6, 5, 3 /)

     Relax = ListGetConstReal( StSolver % Values,'Nonlinear System Relaxation Factor', Found )
     IF ( .NOT. Found ) Relax = 1.0d0
     CALL ListAddConstReal( StSolver % Values,'Nonlinear System Relaxation Factor', 1.0d0 )

     NodalStress  = 0.0d0
     ForceG       = 0.0d0
     CALL DefaultInitialize()

     DO elem = 1,Solver % NumberOfActiveElements
        Element => GetActiveElement(elem, Solver)
        n  = GetElementNOFNodes()
        nd = GetElementDOFs( Indexes )

        Equation => GetEquation()

        ! Check if stresses wanted for this body:
        ! ---------------------------------------
        ComputeFlag = GetLogical( Equation, 'Calculate Stresses', Found )

        IF ( Found .AND. .NOT. ComputeFlag .OR. &
                 .NOT. Found .AND. .NOT. CalcStressAll ) CYCLE

        ! Get material parameters:
        ! ------------------------
        Material => GetMaterial()

        CALL InputTensor( HeatExpansionCoeff, Isotropic,  &
            'Heat Expansion Coefficient', Material, n, Element % NodeIndexes )

        CALL InputTensor( ElasticModulus, Isotropic, &
                'Youngs Modulus', Material, n, Element % NodeIndexes )
        PlaneStress = ListGetLogical( Equation, 'Plane Stress', stat )
        PoissonRatio(1:n) = GetReal( Material, 'Poisson Ratio', Stat )

        ! Element nodal points:
        ! ---------------------
        CALL GetElementNodes( Nodes )

        ! Displacement field at element nodal points:
        ! -------------------------------------------
        CALL GetVectorLocalSolution( LocalDisplacement, USolver=Solver )

        ReferenceTemperature(1:n) = GetReal(Material, 'Reference Temperature', Found )
        CALL GetScalarLocalSolution( LocalTemperature, 'Temperature', USolver=Solver )
        LocalTemperature(1:n) = LocalTemperature(1:n) - ReferenceTemperature(1:n)

        ! Integrate local stresses:
        ! -------------------------
        IntegStuff = GaussPoints( Element )
        Stress = 0.0d0
        MASS   = 0.0d0
        FORCE  = 0.0d0

        DO t=1,IntegStuff % n
          u = IntegStuff % u(t)
          v = IntegStuff % v(t)
          w = IntegStuff % w(t)
          Weight = IntegStuff % s(t)

          stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
             Basis, dBasisdx )

          Weight = Weight * detJ
          IF ( CSymmetry ) Weight = Weight * SUM( Basis(1:n) * Nodes % x(1:n) )

          CALL LocalStress( Stress, Strain, PoissonRatio, &
             ElasticModulus, HeatExpansionCoeff, LocalTemperature, &
              Isotropic, CSymmetry, PlaneStress, LocalDisplacement, &
                Basis, dBasisdx, Nodes, dim, n, nd )

          DO p=1,nd
            DO q=1,nd
              MASS(p,q) = MASS(p,q) + Weight*Basis(q)*Basis(p)
            END DO

            DO i=1,3
            DO j=i,3
              k = Ind( 3*(i-1)+j )
              FORCE(6*(p-1)+k) = FORCE(6*(p-1)+k) + Weight*Stress(i,j)*Basis(p)
            END DO
            END DO
          END DO
        END DO

        CALL DefaultUpdateEquations( MASS, FORCE )

        DO p=1,nd
          l = Permutation(Indexes(p))
          DO i=1,3
          DO j=i,3
             k = Ind(3*(i-1)+j)
             ForceG(6*(l-1)+k) = ForceG(6*(l-1)+k) + FORCE(6*(p-1)+k)
          END DO
          END DO
        END DO
      END DO

      DO i=1,3
      DO j=i,3
        k = IND(3*(i-1)+j)

        StSolver % Matrix % RHS = ForceG(k::6)
        st = DefaultSolve()
        DO l=1,SIZE( Permutation )
          IF ( Permutation(l) > 0 ) THEN
            NodalStress(6*(StressPerm(l)-1)+k) = StSolver % Variable % Values(Permutation(l))
          END IF
        END DO

        IF ( k == 1 ) THEN
          CALL ListAddLogical( StSolver % Values, 'UMF Factorize', .FALSE. )
          CALL ListAddInteger( StSolver % Values, 'Linear System Precondition Recompute', 100 )
        END IF
      END DO
      END DO

      CALL ListAddLogical( StSolver % Values, 'UMF Factorize', .TRUE. )
      CALL ListAddInteger( StSolver % Values, 'Linear System Precondition Recompute', 1 )

      ! Von Mises stress from the component nodal values:
      ! -------------------------------------------------
      VonMises = 0
      DO i=1,SIZE( StressPerm )
         IF ( StressPerm(i) <= 0 ) CYCLE

         p = 0
         DO j=1,3
            DO k=1,3
              p = p + 1
              q = 6 * (StressPerm(i)-1) + IND(p)
              Stress(j,k) = NodalStress(q)
            END DO
         END DO

         Stress(:,:) = Stress(:,:) - TRACE(Stress(:,:),3) * Ident/3

         DO j=1,3
            DO k=1,3
              VonMises(StressPerm(i)) = VonMises(StressPerm(i)) + Stress(j,k)**2
            END DO
         END DO
      END DO

      VonMises = SQRT( 3.0d0 * VonMises / 2.0d0 )

      DEALLOCATE( Basis, dBasisdx )
      DEALLOCATE( Indexes, LocalDisplacement, MASS, FORCE )
      CALL ListAddConstReal( StSolver % Values,'Nonlinear System Relaxation Factor', Relax )

      Model % Solver => Solver
!------------------------------------------------------------------------------
   END SUBROUTINE ComputeStress
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION TRACE( F, dim ) RESULT(t)
!------------------------------------------------------------------------------
     INTEGER :: i, dim
     REAL(KIND=dp) :: F(:,:), t

     t = 0.0d0
     DO i=1,dim
        t = t + F(i,i)
     END DO
!------------------------------------------------------------------------------
   END FUNCTION TRACE
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! Computes area, center of area and different moments
!------------------------------------------------------------------------------
   SUBROUTINE CoordinateIntegrals(Area, Center, Moments, maxnodes)

     REAL(KIND=dp) :: Area, Center(:), Moments(:,:)
     INTEGER :: maxnodes
     LOGICAL :: FoundBoundary

     REAL(KIND=dp) :: Coords(3)
     INTEGER :: power
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
     REAL(KIND=dp) :: Basis(maxnodes)
     REAL(KIND=dp) :: dBasisdx(maxnodes,3),detJ,u,v,w
     REAL(KIND=dp), DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ
     INTEGER :: N_Integ
     LOGICAL :: stat

     FoundBoundary = .FALSE.
     Area = 0.0
     Center = 0.0
     Moments = 0.0


     ! On the first round compute area and center of area.
     ! On the second round compute the square deviations from the mean.
     
     DO power = 1,2

       DO t=1,Solver % Mesh % NumberOfBoundaryElements
         Element => GetBoundaryElement(t)
         IF ( .NOT. ActiveBoundaryElement() .OR. GetElementFamily() == 1 ) CYCLE
         BC => GetBC()
         IF ( .NOT. ASSOCIATED( BC ) ) CYCLE
!------------------------------------------------------------------------------
         IF(.NOT. GetLogical( BC, 'Model Lumping Boundary',Found )) CYCLE
         
         FoundBoundary = .TRUE.
         n = GetElementNOFNodes()
         CALL GetElementNodes( ElementNodes )

         IntegStuff = GaussPoints( Element )
         U_Integ => IntegStuff % u
         V_Integ => IntegStuff % v
         W_Integ => IntegStuff % w
         S_Integ => IntegStuff % s
         N_Integ =  IntegStuff % n
         
         DO k=1,N_Integ
           u = U_Integ(k)
           v = V_Integ(k)
           w = W_Integ(k)
           
           ! Basis function values & derivatives at the integration point:
           !--------------------------------------------------------------
           stat = ElementInfo( Element, ElementNodes, u, v, w, detJ, &
               Basis, dBasisdx )
           
           s = detJ * S_Integ(k)
           IF ( CurrentCoordinateSystem() == AxisSymmetric .OR. &
               CurrentCoordinateSystem() == CylindricSymmetric ) THEN
             s = s * SUM( ElementNodes % x(1:n) * Basis(1:n) )
           END IF
           
           Coords(1) = SUM(Basis(1:n) * ElementNodes % x(1:n))
           IF (DIM > 1) THEN
             Coords(2) =  SUM(Basis(1:n) * ElementNodes % y(1:n))
           END IF
           IF (DIM > 2) THEN
             Coords(3) =  SUM(Basis(1:n) * ElementNodes % z(1:n))
           END IF
           
           IF(power == 1) THEN
             Area = Area + s
             Center(1:DIM) = Center(1:DIM) + s * Coords(1:DIM)
           ELSE
             Coords(1:DIM) = Coords(1:DIM) - Center(1:DIM) 
             DO i = 1,DIM
               DO j = 1,DIM
                 Moments(i,j) = Moments(i,j) + s * Coords(i) * Coords(j)
               END DO
             END DO
           END IF

         END DO
       END DO
         
       IF(.NOT. FoundBoundary) THEN
        CALL Fatal('StressSolve','Model lumping boudary must be defined')        
       END IF
   
       IF(power == 1) Center(1:DIM) = Center(1:DIM) / Area
     END DO

   END SUBROUTINE CoordinateIntegrals


!------------------------------------------------------------------------------
! Compute the loads resulting to pure forces or pure moments.
! Pure moments may only be computed under certain conditions that 
! should be valid for boundaries with normal in the direction of some axis.
!------------------------------------------------------------------------------

   SUBROUTINE LumpedLoads( Permutation, Area, Center, Moments, Forces )
     INTEGER :: Permutation
     REAL (KIND=dp) :: Area, Center(:), Moments(:,:), Forces(:,:)
     
     REAL (KIND=dp), POINTER :: y(:), z(:)
     REAL (KIND=dp) :: c, Eps
     LOGICAL :: isy, isz
     INTEGER :: ix,iy,iz,nx,ny,nz

     Forces = 0.0d0
     Eps = 1.0d-6

     IF(Permutation <= 3) THEN
       Forces(Permutation,1:n) = 1.0 / LumpedArea
     ELSE IF(Permutation <= 6) THEN
       ix = MOD(Permutation - 4, 3) + 1
       iy = MOD(Permutation - 3, 3) + 1
       iz = MOD(Permutation - 2, 3) + 1

       IF(Permutation == 4) THEN
         z => ElementNodes % Z
         y => ElementNodes % Y
       ELSE IF(Permutation == 5) THEN
         z => ElementNodes % X
         y => ElementNodes % Z
       ELSE IF(Permutation == 6) THEN
         z => ElementNodes % Y
         y => ElementNodes % X
       END IF

       isy = (ABS(Moments(iy,ix)) < Eps * Moments(iy,iy))
       isz = (ABS(Moments(iz,ix)) < Eps * Moments(iz,iz))

       IF(isy) THEN
         c = 1.0 / Moments(iy,iy)
         Forces(iz,1:n) = c * (y(1:n) - Center(iy))
       ELSE IF(isz) THEN
         c = -1.0 / Moments(iz,iz)
         Forces(iy,1:n) = c * (z(1:n) - Center(iz))
       ELSE 
         c = 1.0 / (Moments(iy,iy) + Moments(iz,iz) )
         Forces(iy,1:n) = -c * (z(1:n) - Center(iz))
         Forces(iz,1:n) =  c * (y(1:n) - Center(iy))
         CALL Warn('StressSolve','Moment matrix not diagonalazible!')
         PRINT *,Moments(iy,ix),Moments(iz,ix),Moments(iy,iy),Moments(iz,iz)
       END IF
     END IF
   END SUBROUTINE LumpedLoads


!------------------------------------------------------------------------------
   SUBROUTINE LumpedDisplacements( Model, Permutation, Area, Center )
!------------------------------------------------------------------------------
!  This subroutine is used to set pure translations and rotations to the 
!  chosen boundary in order to perform model lumping using fixed displacement.
!------------------------------------------------------------------------------

     TYPE(Model_t) :: Model
     REAL(KIND=dp) :: Area, Center(:)
     INTEGER :: Permutation
!------------------------------------------------------------------------------
     TYPE(Matrix_t), POINTER :: StiffMatrix
     REAL(KIND=dp), POINTER :: ForceVector(:)
     INTEGER, POINTER :: Perm(:)
     TYPE(Element_t), POINTER :: CurrentElement
     INTEGER, POINTER :: NodeIndexes(:)
     INTEGER :: i,j,k,l,n,t,ind
     LOGICAL :: GotIt
     REAL(KIND=dp) :: Coords(3), dCoords(3), dFii, dx, s
    
    !------------------------------------------------------------------------------
    
     StiffMatrix => Solver % Matrix
     ForceVector => StiffMatrix % RHS
     Perm => Solver % Variable % Perm
     
     dX   = 1.0d-2*SQRT(Area)
     dFii = 1.0d-2
     
     DO t = 1, Solver % Mesh % NumberOfBoundaryElements
       Element => GetBoundaryElement(t)
       CurrentElement => Element
       IF ( .NOT. ActiveBoundaryElement()) CYCLE
       n = GetElementNOFNodes()
       
       BC => GetBC()
       IF ( .NOT. ASSOCIATED( BC ) ) CYCLE
       
       IF(.NOT. GetLogical( BC, 'Model Lumping Boundary',Found )) CYCLE

       NodeIndexes => CurrentElement % NodeIndexes
       
       DO j=1,n
         k = Perm(NodeIndexes(j))
         IF(k == 0) CYCLE
         
         dCoords = 0.0d0
         IF(Permutation <= 3) THEN
           dCoords(Permutation) = dX
         ELSE
           Coords(1) = Solver % Mesh % Nodes % x(NodeIndexes(j))
           Coords(2) = Solver % Mesh % Nodes % y(NodeIndexes(j))
           Coords(3) = Solver % Mesh % Nodes % z(NodeIndexes(j))
           Coords = Coords - Center
           IF (Permutation == 4) THEN
             dCoords(2) = -dFii * Coords(3) 
             dCoords(3) = dFii * Coords(2)
           ELSE IF(Permutation == 5) THEN
             dCoords(1) = dFii * Coords(3) 
             dCoords(3) = -dFii * Coords(1)
           ELSE IF(Permutation == 6) THEN
             dCoords(1) = -dFii * Coords(2)
             dCoords(2) = dFii * Coords(1)
           END IF

        END IF

         DO l=1,dim
           ind = dim * (k-1) + l
           IF ( StiffMatrix % FORMAT == MATRIX_SBAND ) THEN
             CALL SBand_SetDirichlet( StiffMatrix,ForceVector,ind,dCoords(l) )             
           ELSE IF ( StiffMatrix % FORMAT == MATRIX_CRS .AND. &
              StiffMatrix % Symmetric ) THEN 
             CALL CRS_SetSymmDirichlet(StiffMatrix,ForceVector,ind,dCoords(l) )
           ELSE
             s = StiffMatrix % Values(StiffMatrix % Diag(ind))
             ForceVector(ind) = dCoords(l) * s
             CALL ZeroRow( StiffMatrix,ind )
             CALL SetMatrixElement( StiffMatrix,ind,ind,1.0d0*s )
           END IF
         END DO
       END DO
     END DO
!------------------------------------------------------------------------------
  END SUBROUTINE LumpedDisplacements
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
! At the end of each iteration assemblys one line of the Kmatrix and finally 
! invert the matrix. The displacements and the springs are taken to be the 
! average values on the surface.
!------------------------------------------------------------------------------
   SUBROUTINE LumpedSprings(Permutation,Area, Center, Moments, maxnodes)
!------------------------------------------------------------------------------
     INTEGER :: Permutation, maxnodes     
     REAL(KIND=dp) :: Area, Center(:), Moments(:,:)
!------------------------------------------------------------------------------
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff
     REAL(KIND=dp) :: Basis(maxnodes)
     REAL(KIND=dp) :: dBasisdx(maxnodes,3),detJ,u,v,w
     REAL(KIND=dp), DIMENSION(:), POINTER :: U_Integ,V_Integ,W_Integ,S_Integ
     REAL(KIND=dp) :: LocalDisp(DIM,maxnodes),Kmat(6,6), up, vp, wp, &
         xp(maxnodes), yp(maxnodes), zp(maxnodes), KmatMin(6,6), KvecAtIP(6), &
         Strain(3,3),Stress(3,3), dFii, Dx, &
         ForceAtIp(3), MomentAtIp(3), Coord(3),Normal(3)
     REAL(KIND=dp), POINTER :: NodalLoads(:), PValues(:)
     LOGICAL, POINTER :: NodeVisited(:)
     INTEGER :: N_Integ, pn
     INTEGER, POINTER :: Indexes(:)
     LOGICAL :: stat, CSymmetry, Isotropic
     CHARACTER(LEN=MAX_NAME_LEN) :: KmatFile
     TYPE(Nodes_t) :: ParentNodes
     TYPE(Element_t),POINTER :: Parent

     SAVE ParentNodes, Kmat, KmatMin, NodalLoads, NodeVisited
!------------------------------------------------------------------------------

     n = maxnodes
     ALLOCATE( ParentNodes % x(n), ParentNodes % y(n), ParentNodes % z(n))

     CSymmetry = CurrentCoordinateSystem() == CylindricSymmetric .OR. &
                 CurrentCoordinateSystem() == AxisSymmetric
    
     dFii = 1.0d-2
     dX = 1.0d-2*SQRT(Area)

     IF (Permutation == 1) THEN
       Kmat = 0.0d0       
       KmatMin = HUGE(KmatMin)
     END IF

     IF( FixDisplacement ) THEN
       IF(Permutation == 1) THEN
         n = SIZE( Displacement ) / STDOFs
         ALLOCATE( NodalLoads( STDOFs * n ), NodeVisited( n ) )
       END IF
       
       NodalLoads = 0.0d0
       PValues => Solver % Matrix % Values
       Solver % Matrix % Values => Solver % Matrix % BulkValues
       CALL MatrixVectorMultiply( Solver % Matrix, Displacement, NodalLoads)
       Solver % Matrix % Values => PValues
       
       NodeVisited = .FALSE.
       
       DO t = 1, Solver % Mesh % NumberOfBoundaryElements
         Element => GetBoundaryElement(t)
         IF ( .NOT. ActiveBoundaryElement() .OR. GetElementFamily() == 1 ) CYCLE
         
         BC => GetBC()
         IF ( .NOT. ASSOCIATED( BC ) ) CYCLE
         IF(.NOT. GetLogical( BC, 'Model Lumping Boundary',Found )) CYCLE
         
         n = GetElementNOFNodes()
         CALL GetElementNodes( ElementNodes )
         Indexes => Element % NodeIndexes
         
         DO i=1,n
           j = DisplPerm( Indexes(i) )
           IF(NodeVisited(j)) CYCLE
           NodeVisited(j) = .TRUE.
           
           Coord(1) = ElementNodes % x(i)
           Coord(2) = ElementNodes % y(i)
           Coord(3) = ElementNodes % z(i)
           Coord = Coord - Center        
           
           DO k=1,DIM
             ForceAtIP(k) = NodalLoads(3*(j-1)+k)
           END DO

           MomentAtIp(1) = -ForceAtIp(2) * Coord(3) + ForceAtIp(3) * Coord(2)
           MomentAtIp(2) = -ForceAtIp(3) * Coord(1) + ForceAtIp(1) * Coord(3)
           MomentAtIp(3) = -ForceAtIp(1) * Coord(2) + ForceAtIp(2) * Coord(1)
           
           Kmat(1:3,Permutation) = Kmat(1:3,Permutation) + ForceAtIp 
           Kmat(4:6,Permutation) = Kmat(4:6,Permutation) + MomentAtIp
         END DO
       END DO


     ELSE
       DO t = 1, Solver % Mesh % NumberOfBoundaryElements
         Element => GetBoundaryElement(t)
         IF ( .NOT. ActiveBoundaryElement() .OR. GetElementFamily() == 1 ) CYCLE
         
         BC => GetBC()
         IF ( .NOT. ASSOCIATED( BC ) ) CYCLE
         IF(.NOT. GetLogical( BC, 'Model Lumping Boundary',Found )) CYCLE
         
         n = GetElementNOFNodes()
         CALL GetElementNodes( ElementNodes )
         
         ! Get parent element & nodes:
         ! ---------------------------
         Parent => Element % BoundaryInfo % Left
         stat = ASSOCIATED( Parent )
         IF ( .NOT. stat ) stat = ALL(DisplPerm(Parent % NodeIndexes) > 0)
         IF ( .NOT. stat ) THEN
           Parent => Element % BoundaryInfo % Right
           stat = ASSOCIATED( Parent )
           IF ( stat ) stat = ALL(DisplPerm(Parent % NodeIndexes) > 0)
           IF ( .NOT. stat ) CALL Fatal( 'StressSolve', & 
               'Cannot find proper parent for side element' )
         END IF
         pn = GetElementNOFNodes( Parent )
         CALL GetElementNodes( ParentNodes, Parent )
         CALL GetVectorLocalSolution( LocalDisp, UElement=Parent )
         
         ! Get boundary nodal points in parent local coordinates:
         ! ------------------------------------------------------
         DO i = 1,n
           DO j = 1,pn
             IF ( Element % NodeIndexes(i) == Parent % NodeIndexes(j) ) THEN
               xp(i) = Parent % TYPE % NodeU(j)
               yp(i) = Parent % TYPE % NodeV(j)
               zp(i) = Parent % TYPE % NodeW(j)
               EXIT
             END IF
           END DO
         END DO
         
         IntegStuff = GaussPoints( Element )

         U_Integ => IntegStuff % u
         V_Integ => IntegStuff % v
         W_Integ => IntegStuff % w
         S_Integ => IntegStuff % s
         N_Integ =  IntegStuff % n
         
         DO k=1,N_Integ
           u = U_Integ(k)
           v = V_Integ(k)
           w = W_Integ(k)
           
           ! Basis function values & derivatives at the integration point:
           !--------------------------------------------------------------
           stat = ElementInfo( Element, ElementNodes, u, v, w, detJ, &
               Basis, dBasisdx )
           
           s = detJ * S_Integ(k)
           IF ( CurrentCoordinateSystem() == AxisSymmetric .OR. &
               CurrentCoordinateSystem() == CylindricSymmetric ) THEN
             s = s * SUM( ElementNodes % x(1:n) * Basis(1:n) )
           END IF
           
           ! The plane  elements only include the  derivatives in the direction
           ! of the plane. Therefore compute the derivatives of the displacemnt
           ! field from the parent element:
           ! -------------------------------------------------------------------
           Up = SUM( xp(1:n) * Basis(1:n) )
           Vp = SUM( yp(1:n) * Basis(1:n) )
           Wp = SUM( zp(1:n) * Basis(1:n) )
           
           stat = ElementInfo( Parent,ParentNodes, Up, Vp, Wp, detJ, &
               Basis, dBasisdx )

           DO i=1,DIM
             ForceAtIP(i) = SUM( Basis(1:pn) * LocalDisp(i,1:pn) )
           END DO
           
           MomentAtIP(1) = 0.5 * &
               ( SUM( dBasisdx(1:pn,2) * LocalDisp(3,1:pn)) &
               - SUM( dBasisdx(1:pn,3) * LocalDisp(2,1:pn)) )
           MomentAtIp(2) = 0.5 * &
               ( SUM( dBasisdx(1:pn,3) * LocalDisp(1,1:pn)) &
               - SUM( dBasisdx(1:pn,1) * LocalDisp(3,1:pn)) )
           MomentAtIp(3) = 0.5 * &
               ( SUM( dBasisdx(1:pn,1) * LocalDisp(2,1:pn)) &
               - SUM( dBasisdx(1:pn,2) * LocalDisp(1,1:pn)) )
           
           Kmat(Permutation,1:3) = Kmat(Permutation,1:3) + s * ForceAtIp
           Kmat(Permutation,4:6) = Kmat(Permutation,4:6) + s * MomentAtIp
             
           DO i = 1,dim
             IF(ABS(KmatMin(Permutation,i)) > ABS(ForceAtIp(i))) THEN
               KmatMin(Permutation,i) = ForceAtIp(i)
             END IF
             IF(ABS(KmatMin(Permutation,i+3)) > ABS(MomentAtIp(i))) THEN
               KmatMin(Permutation,i+3) = MomentAtIp(i)
             END IF
           END DO
         END DO
       END DO
     END IF



     IF(Permutation == 6) THEN
       KmatFile = ListGetString(Solver % Values,'Model Lumping Filename',stat )
       IF(.NOT. stat) KmatFile = "Kmat.dat"

       CALL Info( 'StressSolve', '-----------------------------------------', Level=4 )
       WRITE( Message, * ) 'Saving lumped elastic spring to file ', TRIM(KmatFile)
       CALL Info( 'StressSolve', Message, Level=4 )
       CALL Info( 'StressSolve', '-----------------------------------------', Level=4 )
              
       IF (FixDisplacement) THEN
         Kmat(:,1:3) = Kmat(:,1:3) / dX 
         Kmat(:,4:6) = Kmat(:,4:6) / dFii

         IF( ListGetLogical(Solver % Values,'Symmetrisize',stat)) THEN
           Kmat = (Kmat + TRANSPOSE(Kmat)) / 2.0d0
         END IF         
       ELSE
         Kmat = Kmat / Area

         ! Save the Kmatrix prior to inversion to external file
         OPEN (10, FILE= TRIM(KmatFile) // ".inv")
         DO i=1,Permutation
           WRITE(10,'(6ES17.8E3)') Kmat(i,:)
         END DO
         CLOSE(10)              

         OPEN (10, FILE= TRIM(KmatFile) // ".min-inv")
         DO i=1,Permutation
           WRITE(10,'(6ES17.8E3)') KmatMin(i,:)
         END DO
         CLOSE(10)              

         IF(ListGetLogical(Solver % Values,'Symmetrisize',stat)) THEN
           Kmat = (Kmat + TRANSPOSE(Kmat)) / 2.0d0
           KmatMin = (KmatMin + TRANSPOSE(KmatMin)) / 2.0d0
         END IF

         CALL InvertMatrix(Kmat,Permutation)
         CALL InvertMatrix(KmatMin,Permutation)

         OPEN (10, FILE= TRIM(KmatFile) // ".min" )
         DO i=1,Permutation
           WRITE(10,'(6ES17.8E3)') KmatMin(i,:)
         END DO
         CLOSE(10)
       END IF

       ! Save the Kmatrix to an external file
       OPEN (10, FILE=KmatFile)
       DO i=1,Permutation
         WRITE(10,'(6ES17.8E3)') Kmat(i,:)
       END DO
       CLOSE(10)

       ! Save the area center to an external file
       OPEN (10, FILE= TRIM(KmatFile) // ".center")
       WRITE(10,'(3ES17.8E3)') Center
       CLOSE(10)
     END IF

     IF(FixDisplacement .AND. Permutation == 6) THEN
       DEALLOCATE( NodalLoads, NodeVisited )
     END IF

   END SUBROUTINE LumpedSprings


!------------------------------------------------------------------------------
! Generalized cartesian lumped mass matrix 
!------------------------------------------------------------------------------
    
    SUBROUTINE LumpedCartesianMass() 
      
      REAL(KIND=dp) :: vol
      TYPE(GaussIntegrationPoints_t) :: IntegStuff      
      INTEGER :: iter, i, j, k, n, t, istat, mat_id, NoEigenModes
      LOGICAL :: GotIt, stat      
      REAL(KIND=dp) :: SqrtMetric,SqrtElementMetric,Amp,Dens
      REAL(KIND=dp) :: Basis(Solver % Mesh % MaxElementNodes), &
          dBasisdx(Solver % Mesh % MaxElementNodes, 3)
      REAL(KIND=dp) :: x, y, z, U, V, W, S
      REAL (KIND=DP) :: Moment0, Moment1(3), Moment2(3,3), Center(3), MassMatrix(6,6)
      CHARACTER(LEN=MAX_NAME_LEN) :: KmatFile
         
!------------------------------------------------------------------------------
! Do some initialization stuff
!------------------------------------------------------------------------------
      
      vol = 0.0d0
      Moment0 = 0.0d0
      Moment1 = 0.0d0
      Moment2 = 0.0d0
      Center = LumpedCenter

!------------------------------------------------------------------------------
! Integrate the lumped mass over the volume/area
!------------------------------------------------------------------------------
           
100   DO t = 1, Solver % NumberOfActiveElements
        Element => Solver % Mesh % Elements( Solver % ActiveElements( t ) )
        Model % CurrentElement => Element
        
        n = Element % TYPE % NumberOfNodes
        NodeIndexes => Element % NodeIndexes
        
        ElementNodes % x(1:n) = Solver % Mesh % Nodes % x(NodeIndexes(1:n))
        ElementNodes % y(1:n) = Solver % Mesh % Nodes % y(NodeIndexes(1:n))
        ElementNodes % z(1:n) = Solver % Mesh % Nodes % z(NodeIndexes(1:n))
        
        body_id = Element % BodyId
        mat_id = ListGetInteger( Model % Bodies( body_id ) % Values, &
            'Material', minv=1,maxv=Model % NumberOfMaterials )
        Material => Model % Materials(mat_id) % Values      
        Density(1:n) = ListGetReal( Material, 'Density', n, NodeIndexes(1:n) )                             
        
        IntegStuff = GaussPoints( Element )
        
        DO i=1,IntegStuff % n
          
          U = IntegStuff % u(i)
          V = IntegStuff % v(i)
          W = IntegStuff % w(i)
!------------------------------------------------------------------------------
!        Basis function values & derivatives at the integration point
!------------------------------------------------------------------------------
          stat = ElementInfo( Element,ElementNodes,U,V,W,&
              SqrtElementMetric,Basis,dBasisdx)
!------------------------------------------------------------------------------
!      Coordinatesystem dependent info
!------------------------------------------------------------------------------
          s = SqrtElementMetric * IntegStuff % s(i)          
          x = SUM(ElementNodes % x(1:n) * Basis(1:n)) - Center(1)
          y = SUM(ElementNodes % y(1:n) * Basis(1:n)) - Center(2)
          z = SUM(ElementNodes % z(1:n) * Basis(1:n)) - Center(3)

          IF ( CurrentCoordinateSystem() /= Cartesian ) THEN
            s = 2.0 * PI * x * s
          END IF
          vol =  vol + S          
          dens = SUM(Basis(1:n) * Density(1:n) )

          Moment0 = Moment0 + s * dens
          
          Moment1(1) = Moment1(1) + s * x * dens
          Moment1(2) = Moment1(2) + s * y * dens
          Moment1(3) = Moment1(3) + s * z * dens
          
          Moment2(1,1) = Moment2(1,1) + s * ( y*y + z*z)  * dens
          Moment2(2,2) = Moment2(2,2) + s * ( x*x + z*z )  * dens
          Moment2(3,3) = Moment2(3,3) + s * ( x*x + y*y ) * dens
 
          Moment2(1,2) = Moment2(1,2) - s * x * y * dens
          Moment2(1,3) = Moment2(1,3) - s * x * z * dens
          Moment2(2,3) = Moment2(2,3) - s * y * z * dens
        END DO
      END DO

      IF(Vol < AEPS) RETURN

      IF(.FALSE.) THEN
        ! One could also use the center of mass rather than center of force
        Center = Moment1 / Moment0
        GOTO 100
      END IF
      
      Moment2(2,1) = Moment2(1,2)
      Moment2(3,1) = Moment2(1,3)
      Moment2(2,3) = Moment2(3,2)

      CALL ListAddConstReal(Model % Simulation,'res: Mass',Moment0)
      
      CALL ListAddConstReal(Model % Simulation,'res: Lumped Center X',Center(1))
      CALL ListAddConstReal(Model % Simulation,'res: Lumped Center Y',Center(2))
      CALL ListAddConstReal(Model % Simulation,'res: Lumped Center Z',Center(3))
      
      CALL ListAddConstReal(Model % Simulation,'res: Moment of inertia XX',Moment2(1,1))
      CALL ListAddConstReal(Model % Simulation,'res: Moment of inertia YY',Moment2(2,2))
      CALL ListAddConstReal(Model % Simulation,'res: Moment of inertia ZZ',Moment2(3,3))
      CALL ListAddConstReal(Model % Simulation,'res: Moment of inertia XY',Moment2(1,2))
      CALL ListAddConstReal(Model % Simulation,'res: Moment of inertia XZ',Moment2(1,3))
      CALL ListAddConstReal(Model % Simulation,'res: Moment of inertia YZ',Moment2(2,3))
      
      MassMatrix = 0.0d0
      DO i= 1,3
        MassMatrix(i,i) = Moment0
      END DO
      MassMatrix(4:6,4:6) = Moment2

      ! Save the area center to an external file
      KmatFile = ListGetString(Solver % Values,'Model Lumping Filename',stat )
      IF(.NOT. stat) KmatFile = "Kmat.dat"
      OPEN (10, FILE= TRIM(KmatFile) // ".mass")
      DO i=1,6
        WRITE(10,'(6ES17.8E3)') MassMatrix(i,:)
      END DO
      CLOSE(10)

    END SUBROUTINE LumpedCartesianMass


  END SUBROUTINE StressSolver
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION StressBoundaryResidual( Model, Edge, Mesh, Quant, Perm, Gnorm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE StressLocal
     USE DefUtils
     IMPLICIT NONE
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Edge
     REAL(KIND=dp) :: Quant(:), Indicator(2), Gnorm
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes, EdgeNodes
     TYPE(Element_t), POINTER :: Element, Bndry
     INTEGER :: i,j,k,n,l,t,dim,DOFs,nd,Pn,En
     LOGICAL :: stat, Found
     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Normal(3), EdgeLength
     REAL(KIND=dp) :: u, v, w, s, detJ

     REAL(KIND=dp), ALLOCATABLE :: EdgeBasis(:), dEdgeBasisdx(:,:)
     REAL(KIND=dp), ALLOCATABLE :: x(:), y(:), z(:), ExtPressure(:)
     REAL(KIND=dp), ALLOCATABLE :: Basis(:),dBasisdx(:,:)
     REAL(KIND=dp), ALLOCATABLE :: Force(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDisplacement(:,:)
     REAL(KIND=dp), ALLOCATABLE :: ElasticModulus(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPoissonRatio(:)
     REAL(KIND=dp), ALLOCATABLE :: LocalTemp(:), LocalHexp(:,:,:)

     REAL(KIND=dp) :: Residual(3), ResidualNorm, Area
     REAL(KIND=dp) :: ForceSolved(3), Dir(3)
     REAL(KIND=dp) :: Displacement(3)
     REAL(KIND=dp) :: YoungsModulus
     REAL(KIND=dp) :: PoissonRatio
     REAL(KIND=dp) :: Grad(3,3), Strain(3,3), Stress1(3,3), Stress2(3,3)
     REAL(KIND=dp) :: Identity(3,3), YoungsAverage

     LOGICAL :: PlaneStress, Isotropic, CSymmetry = .FALSE.
     TYPE(ValueList_t), POINTER :: Material, Equation, BodyForce, BC
     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     SAVE Nodes, EdgeNodes
!------------------------------------------------------------------------------

     ! Initialize:
     ! -----------
     Gnorm = 0.0d0
     Indicator = 0.0d0

     Identity = 0.0d0
     DO i=1,3
        Identity(i,i) = 1.0d0
     END DO

     CSymmetry = CurrentCoordinateSystem() == CylindricSymmetric .OR. &
                 CurrentCoordinateSystem() == AxisSymmetric

     dim = CoordinateSystemDimension()
     DOFs = dim

!    --------------------------------------------------
     Element => Edge % BoundaryInfo % Left

     IF ( .NOT. ASSOCIATED( Element ) ) THEN
        Element => Edge % BoundaryInfo % Right
     ELSE IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) THEN
        Element => Edge % BoundaryInfo % Right
     END IF

     IF ( .NOT. ASSOCIATED( Element ) ) RETURN
     IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) RETURN

     En = GetElementNOFNodes( Edge )
     CALL GetElementNodes( EdgeNodes )

     nd = GetElementNOFDOFs( Element )
     Pn = GetElementNOFNodes( Element )
     CALL GetElementNodes( Nodes, UElement=Element )

     ALLOCATE( EdgeBasis(En), dEdgeBasisdx(En,3), x(En), y(En), z(En), &
        ExtPressure(En), Basis(nd), dBasisdx(nd,3), Force(3,En), &
        NodalDisplacement(3,nd), ElasticModulus(6,6,Pn),&
        NodalPoissonRatio(Pn), LocalTemp(nd), LocalHexp(3,3,Pn) )

     LocalTemp = 0
     LocalHexp = 0

     DO l = 1,En
       DO k = 1,Pn
          IF ( Edge % NodeIndexes(l) == Element % NodeIndexes(k) ) THEN
             x(l) = Element % TYPE % NodeU(k)
             y(l) = Element % TYPE % NodeV(k)
             z(l) = Element % TYPE % NodeW(k)
             EXIT
          END IF
       END DO
     END DO

     ! Integrate square of residual over boundary element:
     ! ---------------------------------------------------
     Indicator     = 0.0d0
     EdgeLength    = 0.0d0
     YoungsAverage = 0.0d0
     ResidualNorm  = 0.0d0

     BC => GetBC()
     IF ( .NOT. ASSOCIATED( BC ) ) RETURN

     ! Logical parameters:
     ! -------------------
     Equation => GetEquation( Element )
     PlaneStress = GetLogical( Equation, 'Plane Stress' ,Found )

     Material => GetMaterial( Element )
     NodalPoissonRatio(1:pn) = GetReal( &
                  Material, 'Poisson Ratio',Found, Element )
     CALL InputTensor( ElasticModulus, Isotropic, &
                 'Youngs Modulus', Material, Pn, Element % NodeIndexes )

     ! Given traction:
     ! ---------------
     Force = 0.0d0
     Force(1,1:En) = GetReal( BC, 'Force 1', Found )
     Force(2,1:En) = GetReal( BC, 'Force 2', Found )
     Force(3,1:En) = GetReal( BC, 'Force 3', Found )

     ! Force in normal direction:
     ! ---------------------------
     ExtPressure(1:En) = GetReal( BC, 'Normal Force', Found )

     ! If dirichlet BC for displacement in any direction given,
     ! nullify force in that directon:
     ! --------------------------------------------------------
     Dir = 1.0d0
     IF ( ListCheckPresent( BC, 'Displacement' ) )   Dir = 0
     IF ( ListCheckPresent( BC, 'Displacement 1' ) ) Dir(1) = 0
     IF ( ListCheckPresent( BC, 'Displacement 2' ) ) Dir(2) = 0
     IF ( ListCheckPresent( BC, 'Displacement 3' ) ) Dir(3) = 0

     ! Elementwise nodal solution:
     ! ---------------------------
     CALL GetVectorLocalSolution( NodalDisplacement, UElement=Element )

     ! Integration:
     ! ------------
     EdgeLength    = 0.0d0
     YoungsAverage = 0.0d0
     ResidualNorm  = 0.0d0

     IntegStuff = GaussPoints( Edge )

     DO t=1,IntegStuff % n
        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Edge, EdgeNodes, u, v, w, detJ, &
            EdgeBasis, dEdgeBasisdx )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( EdgeBasis(1:En) * EdgeNodes % x(1:En) )
           v = SUM( EdgeBasis(1:En) * EdgeNodes % y(1:En) )
           w = SUM( EdgeBasis(1:En) * EdgeNodes % z(1:En) )
   
           CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                       Symb, dSymb, u, v, w )

           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF

        Normal = NormalVector( Edge, EdgeNodes, u, v, .TRUE. )

        u = SUM( EdgeBasis(1:En) * x(1:En) )
        v = SUM( EdgeBasis(1:En) * y(1:En) )
        w = SUM( EdgeBasis(1:En) * z(1:En) )

        stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
           Basis, dBasisdx )

        ! Stress tensor on the edge:
        ! --------------------------
        CALL LocalStress( Stress1, Strain, NodalPoissonRatio, &
           ElasticModulus, LocalHExp, LocalTemp, &
           Isotropic, CSymmetry, PlaneStress, &
           NodalDisplacement, Basis, dBasisdx, Nodes, dim, pn, nd )

        ! Given force at the integration point:
        ! -------------------------------------
        Residual = MATMUL( Force(:,1:En), EdgeBasis(1:En) ) - &
          SUM( ExtPressure(1:En) * EdgeBasis(1:En) ) * Normal

        ForceSolved = MATMUL( Stress1, Normal )
        Residual = Residual - ForceSolved * Dir

        EdgeLength    = EdgeLength + s
        ResidualNorm  = ResidualNorm  + s * SUM(Residual(1:DIM) ** 2)
        YoungsAverage = YoungsAverage + &
                    s * SUM( ElasticModulus(1,1,1:Pn) * Basis(1:Pn) )
     END DO

     IF ( YoungsAverage > AEPS ) THEN
        YoungsAverage = YoungsAverage / EdgeLength
        Indicator = EdgeLength * ResidualNorm / YoungsAverage
     END IF

     DEALLOCATE( EdgeBasis, dEdgeBasisdx, x, y, z, ExtPressure, Basis, &
      dBasisdx, Force, NodalDisplacement, ElasticModulus, NodalPoissonRatio, &
      LocalTemp, LocalHexp )
!------------------------------------------------------------------------------
   END FUNCTION StressBoundaryResidual
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
  FUNCTION StressEdgeResidual( Model,Edge,Mesh,Quant,Perm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE StressLocal
     USE DefUtils
     IMPLICIT NONE

     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2)
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Edge
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes, EdgeNodes
     TYPE(Element_t), POINTER :: Element, Bndry

     INTEGER :: i,j,k,l,n,t,dim,DOFs,En,Pn, nd
     LOGICAL :: stat, Found

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)
     REAL(KIND=dp) :: Stressi(3,3,2), Jump(3), Identity(3,3)
     REAL(KIND=dp) :: Normal(3)
     REAL(KIND=dp) :: Displacement(3)
     REAL(KIND=dp) :: YoungsModulus
     REAL(KIND=dp) :: PoissonRatio
     REAL(KIND=dp) :: YoungsAverage
     REAL(KIND=dp) :: Grad(3,3), Strain(3,3), Stress1(3,3), Stress2(3,3)

     REAL(KIND=dp), ALLOCATABLE :: LocalTemp(:), LocalHexp(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: x(:), y(:), z(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDisplacement(:,:)
     REAL(KIND=dp), ALLOCATABLE :: ElasticModulus(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPoissonRatio(:)
     REAL(KIND=dp), ALLOCATABLE :: EdgeBasis(:), Basis(:), dBasisdx(:,:)

     LOGICAL :: PlaneStress, Isotropic, CSymmetry

     TYPE(ValueList_t), POINTER :: Material, Equation

     REAL(KIND=dp) :: u, v, w, s, detJ

     REAL(KIND=dp) :: Residual, ResidualNorm, EdgeLength

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     SAVE Nodes, EdgeNodes
!------------------------------------------------------------------------------

!    Initialize:
!    -----------
     dim = CoordinateSystemDimension()
     DOFs = dim

     CSymmetry = CurrentCoordinateSystem() == CylindricSymmetric .OR. &
                 CurrentCoordinateSystem() == AxisSymmetric


     Identity = 0.0d0
     Metric   = 0.0d0
     DO i = 1,3
        Metric(i,i)   = 1.0d0
        Identity(i,i) = 1.0d0
     END DO
!
!    ---------------------------------------------
     En = GetElementNOFNodes( Edge )
     CALL GetElementNodes( EdgeNodes, Edge )

     Element => Edge % BoundaryInfo % Left
     pn = GetElementNOFNodes( Element )
     nd = GetElementNOFDOFs( Element )

     Element => Edge % BoundaryInfo % Right
     nd = MAX( nd, GetElementNOFDOFs( Element ) )
     pn = MAX( pn, GetElementNOFNodes( Element ) )

     ALLOCATE( LocalTemp(nd), LocalHexp(3,3,Pn), x(En), y(En), z(En), &
      NodalDisplacement(3,nd), ElasticModulus(6,6,pn), &
      NodalPoissonRatio(pn), EdgeBasis(En), Basis(nd), dBasisdx(nd,3) )

     LocalTemp = 0
     LocalHexp = 0

!    Integrate square of jump over edge:
!    ------------------------------------
     ResidualNorm  = 0.0d0
     EdgeLength    = 0.0d0
     Indicator     = 0.0d0
     Grad          = 0.0d0
     YoungsAverage = 0.0d0

     IntegStuff = GaussPoints( Edge )

     DO t=1,IntegStuff % n

        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Edge, EdgeNodes, u, v, w, detJ, &
             EdgeBasis, dBasisdx )

        Normal = NormalVector( Edge, EdgeNodes, u, v, .FALSE. )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( EdgeBasis(1:En) * EdgeNodes % x(1:En) )
           v = SUM( EdgeBasis(1:En) * EdgeNodes % y(1:En) )
           w = SUM( EdgeBasis(1:En) * EdgeNodes % z(1:En) )

           CALL CoordinateSystemInfo( Metric, SqrtMetric, &
                       Symb, dSymb, u, v, w )
           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF

        Stressi = 0.0d0
        DO i = 1,2
           IF ( i==1 ) THEN
              Element => Edge % BoundaryInfo % Left
           ELSE
              Element => Edge % BoundaryInfo % Right
           END IF

           IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) CYCLE

           pn = GetElementNOFNodes( Element )
           nd = GetElementNOFDOFs( Element )
           CALL GetElementNodes( Nodes, Element )
           DO j = 1,en
              DO k = 1,pn
                 IF ( Edge % NodeIndexes(j) == Element % NodeIndexes(k) ) THEN
                    x(j) = Element % TYPE % NodeU(k)
                    y(j) = Element % TYPE % NodeV(k)
                    z(j) = Element % TYPE % NodeW(k)
                    EXIT
                 END IF
              END DO
           END DO

           u = SUM( EdgeBasis(1:En) * x(1:En) )
           v = SUM( EdgeBasis(1:En) * y(1:En) )
           w = SUM( EdgeBasis(1:En) * z(1:En) )

           stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
               Basis, dBasisdx )

           ! Logical parameters:
           ! -------------------
           Equation => GetEquation( Element )
           PlaneStress = GetLogical( Equation,'Plane Stress',Found )

           ! Material parameters:
           ! --------------------
           Material => GetMaterial( Element )
           NodalPoissonRatio(1:pn) = GetReal( Material, 'Poisson Ratio', Found, Element )
           CALL InputTensor( ElasticModulus, Isotropic, &
                         'Youngs Modulus', Material, pn, Element % NodeIndexes )

           ! Elementwise nodal solution:
           ! ---------------------------
           CALL GetVectorLocalSolution( NodalDisplacement, UElement=Element )

           ! Stress tensor on the edge:
           ! --------------------------
           CALL LocalStress( Stress1, Strain, NodalPoissonRatio, &
              ElasticModulus, LocalHExp, LocalTemp, Isotropic, CSymmetry, PlaneStress, &
              NodalDisplacement, Basis, dBasisdx, Nodes, dim, pn, nd )

           Stressi(:,:,i) = Stress1
        END DO

        EdgeLength  = EdgeLength + s
        Jump = MATMUL( ( Stressi(:,:,1) - Stressi(:,:,2)), Normal )
        ResidualNorm = ResidualNorm + s * SUM( Jump(1:DIM) ** 2 )

        YoungsAverage = YoungsAverage + s *  &
                    SUM( ElasticModulus(1,1,1:pn) * Basis(1:pn) )
     END DO

     YoungsAverage = YoungsAverage / EdgeLength
     Indicator = EdgeLength * ResidualNorm / YoungsAverage

     DEALLOCATE( LocalTemp, LocalHexp, x, y, z, NodalDisplacement, &
       ElasticModulus, NodalPoissonRatio, EdgeBasis, Basis, dBasisdx )
!------------------------------------------------------------------------------
   END FUNCTION StressEdgeResidual
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
   FUNCTION StressInsideResidual( Model, Element,  &
                      Mesh, Quant, Perm, Fnorm ) RESULT( Indicator )
!------------------------------------------------------------------------------
     USE StressLocal
     USE DefUtils
!------------------------------------------------------------------------------
     IMPLICIT NONE
!------------------------------------------------------------------------------
     TYPE(Model_t) :: Model
     INTEGER :: Perm(:)
     REAL(KIND=dp) :: Quant(:), Indicator(2), Fnorm
     TYPE( Mesh_t ), POINTER    :: Mesh
     TYPE( Element_t ), POINTER :: Element
!------------------------------------------------------------------------------

     TYPE(Nodes_t) :: Nodes

     INTEGER :: i,j,k,l,m,n,nd,t,dim,DOFs,I1(6),I2(6)
     INTEGER, ALLOCATABLE :: Indexes(:)

     LOGICAL :: stat, Found

     TYPE( Variable_t ), POINTER :: Var

     REAL(KIND=dp) :: SqrtMetric, Metric(3,3), Symb(3,3,3), dSymb(3,3,3,3)

     REAL(KIND=dp) :: Density
     REAL(KIND=dp) :: PoissonRatio
     REAL(KIND=dp) :: Damping
     REAL(KIND=dp) :: Displacement(3),Identity(3,3), YoungsAverage
     REAL(KIND=dp) :: Grad(3,3), Strain(3,3), Stress1(3,3), Stress2(3,3)
     REAL(KIND=dp) :: Energy

     REAL(KIND=dp), ALLOCATABLE :: ElasticModulus(:,:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDensity(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalPoissonRatio(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDamping(:)
     REAL(KIND=dp), ALLOCATABLE :: NodalDisplacement(:,:)
     REAL(KIND=dp), ALLOCATABLE :: LocalHexp(:,:,:), vec(:)
     REAL(KIND=dp), ALLOCATABLE :: Stressi(:,:,:), LocalTemp(:)
     REAL(KIND=dp), ALLOCATABLE :: Basis(:), dBasisdx(:,:)
     REAL(KIND=dp), ALLOCATABLE :: NodalForce(:,:), Veloc(:,:), Accel(:,:)

     LOGICAL :: PlaneStress, CSymmetry, Isotropic, Transient

     REAL(KIND=dp) :: u, v, w, s, detJ
     REAL(KIND=dp) :: Residual(3), ResidualNorm, Area

     TYPE(ValueList_t), POINTER :: Material, BodyForce, Equation

     TYPE(GaussIntegrationPoints_t), TARGET :: IntegStuff

     SAVE Nodes
!------------------------------------------------------------------------------
     ! Initialize:
     ! -----------
     Fnorm     = 0.0d0
     Indicator = 0.0d0

     IF ( ANY( Perm( Element % NodeIndexes ) <= 0 ) ) RETURN

     Metric = 0.0d0
     DO i=1,3
        Metric(i,i) = 1.0d0
     END DO

     dim = CoordinateSystemDimension()
     DOFs = dim 

     CSymmetry = CurrentCoordinateSystem() == CylindricSymmetric .OR. &
                 CurrentCoordinateSystem() == AxisSymmetric

     ! Element nodal points:
     ! ---------------------
     nd = GetElementNOFDOFs()
     n  = GetElementNOFNodes()
     CALL GetElementNodes( Nodes )

     ALLOCATE( ElasticModulus(6,6,nd), NodalDensity(n), NodalPoissonRatio(n), &
         NodalDamping(n), NodalDisplacement(3,nd), LocalHExp(3,3,n), vec(nd), &
         Stressi(3,3,nd), LocalTemp(nd), Basis(nd), dBasisdx(3,nd), &
         NodalForce(4,n), Veloc(3,nd), Accel(3,nd) )

     LocalTemp = 0
     LocalHexp = 0

     ! Logical parameters:
     ! -------------------
     equation => GetEquation()
     PlaneStress = GetLogical( Equation, 'Plane Stress',Found )

     ! Material parameters:
     ! --------------------
     Material => GetMaterial()

     CALL InputTensor( ElasticModulus, Isotropic, &
           'Youngs Modulus', Material, n, Element % NodeIndexes )

     NodalPoissonRatio(1:n) = GetReal( Material, 'Poisson Ratio', Found )

     ! Check for time dep.
     ! -------------------
     IF ( ListGetString( Model % Simulation, 'Simulation Type') == 'transient' ) THEN
        Transient = .TRUE.
        Var => VariableGet( Model % Variables, 'Displacement', .TRUE. )

        nd = GetElementDOFs( Indexes )

        Veloc = 0.0d0
        Accel = 0.0d0
        DO i=1,DOFs
           Veloc(i,1:nd) = Var % PrevValues(DOFs*(Var % Perm(Indexes(1:nd))-1)+i,1)
           Accel(i,1:nd) = Var % PrevValues(DOFs*(Var % Perm(Indexes(1:nd))-1)+i,2)
        END DO
        NodalDensity(1:n) = GetReal( Material, 'Density', Found )
        NodalDamping(1:n) = GetReal( Material, 'Damping', Found )
     ELSE
        Transient = .FALSE.
     END IF

     ! Elementwise nodal solution:
     ! ---------------------------
     CALL GetVectorLocalSolution( NodalDisplacement )

     ! Body Forces:
     ! ------------
     BodyForce => GetBodyForce()

     NodalForce = 0.0d0

     IF ( ASSOCIATED( BodyForce ) ) THEN
        NodalForce(1,1:n) = NodalForce(1,1:n) + GetReal( &
            BodyForce, 'Stress BodyForce 1', Found )
        NodalForce(2,1:n) = NodalForce(1,1:n) + GetReal( &
            BodyForce, 'Stress BodyForce 2', Found )
        NodalForce(3,1:n) = NodalForce(1,1:n) + GetReal( &
            BodyForce, 'Stress BodyForce 3', Found )
     END IF

     Identity = 0.0D0
     DO i = 1,dim
        Identity(i,i) = 1.0D0
     END DO
     CSymmetry = .FALSE.

     Var => VariableGet( Model % Variables, 'Stress 1' )
     IF ( ASSOCIATED( Var ) ) THEN

       ! If stress already computed:
       ! ---------------------------
       I1(1:6) = (/ 1,2,3,1,2,1 /)
       I2(1:6) = (/ 1,2,3,2,3,3 /)
       DO i=1,6
         CALL GetScalarLocalSolution(Vec(1:nd),'Stress ' // CHAR(i+ICHAR('0')))
         Stressi(I1(i),I2(i),1:nd) = Vec(1:nd)
         Stressi(I2(i),I1(i),1:nd) = Vec(1:nd)
       END DO
     ELSE
       ! Values of the stress tensor at node points:
       ! -------------------------------------------
       DO i = 1,n
         u = Element % TYPE % NodeU(i)
         v = Element % TYPE % NodeV(i)
         w = Element % TYPE % NodeW(i)

         stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
             Basis, dBasisdx )

         CALL LocalStress( Stressi(:,:,i), Strain, NodalPoissonRatio, &
                   ElasticModulus, LocalHExp, LocalTemp, Isotropic, CSymmetry, PlaneStress, &
                   NodalDisplacement, Basis, dBasisdx, Nodes, dim, n, nd )
       END DO
     END IF

     ! Integrate square of residual over element:
     ! ------------------------------------------
     ResidualNorm = 0.0d0
     Fnorm = 0.0d0
     Area = 0.0d0
     Energy = 0.0d0
     YoungsAverage = 0.0d0

     IntegStuff = GaussPoints( Element )

     DO t=1,IntegStuff % n
        u = IntegStuff % u(t)
        v = IntegStuff % v(t)
        w = IntegStuff % w(t)

        stat = ElementInfo( Element, Nodes, u, v, w, detJ, &
            Basis, dBasisdx )

        IF ( CurrentCoordinateSystem() == Cartesian ) THEN
           s = IntegStuff % s(t) * detJ
        ELSE
           u = SUM( Basis(1:n) * Nodes % x(1:n) )
           v = SUM( Basis(1:n) * Nodes % y(1:n) )
           w = SUM( Basis(1:n) * Nodes % z(1:n) )

           CALL CoordinateSystemInfo( Metric,SqrtMetric,Symb,dSymb,u,v,w )
           s = IntegStuff % s(t) * detJ * SqrtMetric
        END IF

        ! Residual of the diff.equation:
        ! ------------------------------
        Residual = 0.0d0
        DO i = 1,3
           Residual(i) = -SUM( NodalForce(i,1:n) * Basis(1:n) )

           IF ( Transient ) THEN
              Residual(i) = Residual(i) + SUM(NodalDensity(1:n)*Basis(1:n)) * &
                            SUM( Accel(i,1:nd) * Basis(1:nd) )
              Residual(i) = Residual(i) + SUM(NodalDamping(1:n)*Basis(1:n)) * &
                            SUM( Veloc(i,1:nd) * Basis(1:nd) )
           END IF

           DO j = 1,3
             Residual(i) = Residual(i) - SUM(Stressi(i,j,1:nd)*dBasisdx(1:nd,j))
           END DO
        END DO

!       IF ( CSymmetry ) THEN
!          DO k=1,3
!             Residual(1) = Residual(1) + ...
!          END DO
!       END IF

       ! Dual norm of the load:
       ! ----------------------
        DO i = 1,dim
           Fnorm = Fnorm + s * SUM( NodalForce(i,1:n) * Basis(1:n) ) ** 2
        END DO

        YoungsAverage = YoungsAverage + s*SUM( ElasticModulus(1,1,1:n) * Basis(1:n) )

        ! Energy:
        ! -------
        CALL LocalStress( Stress1, Strain, NodalPoissonRatio, &
           ElasticModulus, LocalHExp, LocalTemp, Isotropic, CSymmetry, PlaneStress, &
           NodalDisplacement, Basis, dBasisdx, Nodes, dim, n, nd )

        Energy = Energy + s*DDOTPROD(Strain,Stress1,dim) / 2.0d0

        Area = Area + s
        ResidualNorm = ResidualNorm + s * SUM( Residual(1:dim) ** 2 )
     END DO

     YoungsAverage = YoungsAverage / Area
     Fnorm = Energy
     Indicator = Area * ResidualNorm / YoungsAverage
 
     DEALLOCATE( ElasticModulus, NodalDensity, NodalPoissonRatio,  &
         NodalDamping, NodalDisplacement, LocalHExp, vec, Stressi, &
         LocalTemp, Basis, dBasisdx, NodalForce, Veloc, Accel )


CONTAINS

!------------------------------------------------------------------------------
  FUNCTION DDOTPROD(A,B,N) RESULT(C)
!------------------------------------------------------------------------------
    IMPLICIT NONE
    DOUBLE PRECISION :: A(:,:),B(:,:),C
    INTEGER :: N
!------------------------------------------------------------------------------
    INTEGER :: I,J
!------------------------------------------------------------------------------
    C = 0.0D0
    DO i = 1,N
       DO j = 1,N
          C = C + A(i,j)*B(i,j)
       END DO
    END DO
!------------------------------------------------------------------------------
  END FUNCTION DDOTPROD
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
   END FUNCTION StressInsideResidual
!------------------------------------------------------------------------------
