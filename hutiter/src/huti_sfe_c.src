
/*
 * huti_sfe_c.c - HUTIter library. Fron-ends for iterative solvers,
 *                C -version
 *
 * $Id: huti_sfe_c.src,v 1.2 2005/04/19 08:28:34 vierinen Exp $
 *
 */

#include "huti_intdefs.h"
MAKE_INCLUDE(#,include, <stdlib.h> )
MAKE_INCLUDE(#,include, <stdio.h> )
MAKE_INCLUDE(#,include, "huti_defs.h" )
MAKE_INCLUDE(#,include, "../config.h" )

extern void MAKE_F_SUBRN(HUTI_,huti_,CGSOLV,cgsolv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern void MAKE_F_SUBRN(HUTI_,huti_,CGSSOLV,cgssolv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern void MAKE_F_SUBRN(HUTI_,huti_,BICGSTABSOLV,bicgstabsolv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern void MAKE_F_SUBRN(HUTI_,huti_,QMRSOLV,qmrsolv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern void MAKE_F_SUBRN(HUTI_,huti_,TFQMRSOLV,tfqmrsolv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern void MAKE_F_SUBRN(HUTI_,huti_,GMRESSOLV,gmressolv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern void MAKE_F_SUBRN(HUTI_,huti_,BICGSTAB_2SOLV,bicgstab_2solv) ( int *ndim, int *wrkdim,
			void *xvec, void *rhsvec, int *ipar, double *dpar,
			void *work, void (*matvecsubr)(),
			void (*pcondlsubr)(), void (*pcondrsubr)(),
			void (*dotprodfun)(), double (*normfun)(),
			void (*stopcfun)() );

extern int huti_num_of_procs;

extern void PRECD_DUMMY_PCONDFUN (void *u, void *v, int *ipar);

/* BLAS routines, these definitions are only for function pointers */

extern void PRECD_BLAS_DOTPRODFUN (int *N, void *x, int *xind, void *y, int *yind);
extern void PRECD_BLAS_DOTPRODFUN_N (int *N, void *x, int *xind, void *y, int *yind);
extern void PRECD_BLAS_NORMFUN (int *N, void *x, int *xind);

/*
 *
 * HUTIter library: Front-end for conjugate gradient solver.
 *                  PRECISION_COMMENT version.
 *
 */

void MAKE_F_SUBRN(HUTI_,huti_,_CG,_cg) ( void *xvec, void *rhsvec,
		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,CGSOLV,cgsolv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );

  return;
}
  
/*
 *
 * HUTIter library: Front-end for Transpose-Free Quasi-Minimal Residual
 *	 	    solver. PRECISION_COMMENT version.
 *
 */

void MAKE_F_SUBRN(HUTI_,huti_,_TFQMR,_tfqmr) ( void *xvec, void *rhsvec,

		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,TFQMRSOLV,tfqmrsolv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );

  return;
}
  
/*
 *
 * HUTIter library: Front-end for Conjugate Gradient Squared solver.
 *	 	    PRECISION_COMMENT version.
 *
 */

void MAKE_F_SUBRN(HUTI_,huti_,_CGS,_cgs) ( void *xvec, void *rhsvec,
		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,CGSSOLV,cgssolv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );

  return;
}

/*
 *
 * HUTIter library: Front-end for Quasi-Minimal Residual solver.
 *	 	    PRECISION_COMMENT version.
 *
 */

void MAKE_F_SUBRN(HUTI_,huti_,_QMR,_qmr) ( void *xvec, void *rhsvec,
		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,QMRSOLV,qmrsolv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );
  return;
}

/*
 *
 * HUTIter library: Front-end for BiConjugate Gradient Stabilised solver.
 *	 	    PRECISION_COMMENT version.
 *
 */
void MAKE_F_SUBRN(HUTI_,huti_,_BICGSTAB,_bicgstab) ( void *xvec, void *rhsvec,
		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,BICGSTABSOLV,bicgstabsolv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );

  return;
}
  
/*
 *
 * HUTIter library: Front-end for Generalized Minimum RESidual solver.
 *	 	    PRECISION_COMMENT version.
 *
 */

void MAKE_F_SUBRN(HUTI_,huti_,_GMRES,_gmres) ( void *xvec, void *rhsvec,
		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN_N;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,GMRESSOLV,gmressolv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );

  return;
}
  
/*
 *
 * HUTIter library: Front-end for BiConjugate Gradient Stabilised (2) solver.
 *	 	    PRECISION_COMMENT version.
 *
 */
void MAKE_F_SUBRN(HUTI_,huti_,_BICGSTAB_2,_bicgstab_2) ( void *xvec, void *rhsvec,
		int *ipar, double *dpar, void *work,
		void (*matvecsubr)(),
		void (*pcondlsubr)(),
		void (*pcondrsubr)(),
		void (*dotprodfun)(),
		void (*normfun)(),
		void (*mstopfun)() )
{
  HUTI_Init();

  /* Here we take care of the "dynamic" bindings */

  if (*((int *) pcondrsubr) == 0)
    pcondrsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) pcondlsubr) == 0)
    pcondlsubr = PRECD_DUMMY_PCONDFUN;
  if (*((int *) dotprodfun) == 0)
    dotprodfun = PRECD_BLAS_DOTPRODFUN;
  if (*((int *) normfun) == 0)
    normfun = PRECD_BLAS_NORMFUN;

  MAKE_F_SUBRN(HUTI_,huti_,BICGSTAB_2SOLV,bicgstab_2solv) ( &HUTI_NDIM, &HUTI_WRKDIM, xvec, rhsvec,
                 ipar, dpar, work, matvecsubr, pcondlsubr, pcondrsubr,
                 dotprodfun, normfun, mstopfun );

  return;
}
