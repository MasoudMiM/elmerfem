






                                 delim $$
gsize 11
tdefine norm %  | fwd 10 | %
ndefine norm % || %
ndefine delta % d %
ndefine epsilon % e %
ndefine kappa % K %












                            SSppaarrssee UUsseerr''ss GGuuiiddee

                      _A _S_p_a_r_s_e _L_i_n_e_a_r _E_q_u_a_t_i_o_n _S_o_l_v_e_r

                               Version 1.3a
                               1 April 1988




                            _K_e_n_n_e_t_h _S_. _K_u_n_d_e_r_t
                      _A_l_b_e_r_t_o _S_a_n_g_i_o_v_a_n_n_i_-_V_i_n_c_e_n_t_e_l_l_i






                               Department of
               Electrical Engineering and Computer Sciences
                    University of California, Berkeley
                          Berkeley, Calif. 94720
























11::  IINNTTRROODDUUCCTTIIOONN

     _S_p_a_r_s_e_1_._3  is  a  flexible package of subroutines written in C used to
quickly and accurately solve large sparse systems of linear equations.  The
package  is  able  to handle arbitrary real and complex square matrix equa-
tions.  Besides being able to solve linear systems,  it  is  also  able  to
quickly  solve  transposed  systems, find determinants, and estimate errors
due to ill-conditioning in the system of equations and instability  in  the
computations.  _S_p_a_r_s_e also provides a test program that is able read matrix
equations from a file, solve them, and print useful information  about  the
equation and its solution.

     _S_p_a_r_s_e_1_._3  is  generally  as  fast or faster than other popular sparse
matrix packages when solving many matrices of  similar  structure.   _S_p_a_r_s_e
does not require or assume symmetry and is able to perform numerical pivot-
ing to avoid unnecessary error in the solution.  It handles its own  memory
allocation, which allows the user to forgo the hassle of providing adequate
memory.  It also has a natural, flexible, and efficient  interface  to  the
calling program.

     _S_p_a_r_s_e  was  originally  written  for use in circuit simulators and is
particularly apt at handling node- and modified-node  admittance  matrices.
The  systems  of  linear generated in a circuit simulator stem from solving
large systems of nonlinear equations using Newton's method and  integrating
large stiff systems of ordinary differential equations.  However, _S_p_a_r_s_e is
also suitable for other uses, one in particular is solving the  very  large
systems  of  linear equations resulting from the numerical solution of par-
tial differential equations.


11..11::  FFeeaattuurreess ooff SSppaarrssee11..33

     Beyond the basic capability of being able to create, factor and  solve
systems of equations, this package features several other capabilities that
enhance its utility.  These features are:

+o    Ability to handle both real and complex systems  of  equations.   Both
     types  may  resident  and  active at the same time.  In fact, the same
     matrix may alternate between being real and complex.

+o    Ability to quickly solve the transposed system.  This feature is  use-
     ful  when  computing  the  sensitivity  of a circuit using the adjoint
     method.

+o    Memory for elements in the matrix is  allocated  dynamically,  so  the
     size  of  the matrix is only limited by the amount of memory available
     to _S_p_a_r_s_e and the range of the integer data type,  which  is  used  to
     hold matrix indices.

+o    Ability  to efficiently compute the condition number of the matrix and
     an a posteriori estimate of the error caused by growth in the size  of
     the elements during the factorization.











                             -2-


+o    Much  of the matrix initialization can be performed by _S_p_a_r_s_e, provid-
     ing advantages in speed and simplified coding of the calling  program.

+o    Ability to preorder modified node admittance matrices to enhance accu-
     racy and speed.

+o    Ability to exploit sparsity in the right-hand side  vector  to  reduce
     unnecessary computation.

+o    Ability  to scale matrices prior to factoring to reduce uncertainty in
     the solution.

+o    The ability to create and build a matrix  without  knowing  its  final
     size.

+o    The  ability  to add elements, and rows and columns, to a matrix after
     the matrix has been reordered.

+o    The ability to delete rows and columns from a matrix.

+o    The ability to strip the fill-ins from a matrix.  This can improve the
     efficiency of a subsequent reordering.

+o    The ability to handle matrices that have rows and columns missing from
     their input description.

+o    Ability to output the matrix in forms readable by either by people  or
     by  the  _S_p_a_r_s_e  package.   Basic statistics on the matrix can also be
     output.

+o    By default all arithmetic operations and  number  storage  use  double
     precision.   Thus,  _S_p_a_r_s_e  usually  gives  accurate  results, even on
     highly ill-conditioned systems.  If so desired, _S_p_a_r_s_e can  be  easily
     configured to use single precision arithmetic.


11..22::  EEnnhhaanncceemmeennttss ooff SSppaarrssee11..33 oovveerr SSppaarrssee11..22

     Most  notable  of the enhancements provided by _S_p_a_r_s_e_1_._3 is that it is
considerably faster on dense matrices.  Also, external names have been made
unique  to  7 characters and the _S_p_a_r_s_e prefix sspp has been prepended to all
externally accessible names to avoid conflicts.   In  addition,  a  routine
that  efficiently estimates the condition number of a matrix has been added
and the code that estimates the growth in the factorization has been  split
off  from the actual factorization so that it is computed only when needed.

     It is now possible for the user program to store  information  in  the
matrix  elements.   It  is  also possible to provide a subroutine to _S_p_a_r_s_e
that uses that information to initialize the matrix.  This can greatly sim-
plify the user's code.

     _S_p_a_r_s_e_1_._3  has  an FORTRAN interface.  Routines written in FORTRAN can
access almost all of the features _S_p_a_r_s_e_1_._3.










                             -3-


11..33::  CCooppyyrriigghhtt IInnffoorrmmaattiioonn

     _S_p_a_r_s_e_1_._3 has been copyrighted.  Permission to use, copy, modify,  and
distribute  this software and its documentation for any purpose and without
fee is hereby granted, provided that the copyright  notice  appear  in  all
copies,  and  _S_p_a_r_s_e  and the University of California, Berkeley are refer-
enced in all documentation for the program or product in which _S_p_a_r_s_e is to
be  installed.  The authors and the University of California make no repre-
sentations as to the suitability of the software for any  purpose.   It  is
provided `as is', without express or implied warranty.





















































                             -4-


22::  PPRRIIMMEERR

22..11::  SSoollvviinngg MMaattrriixx EEqquuaattiioonnss

     _S_p_a_r_s_e  contains  a  collection  of  C subprograms that can be used to
solve linear algebraic systems of equations.   These  systems  are  of  the
form:

     bold { Ax ~=~ b }

where  $bold  A$  is  an $n times  n$ matrix, $bold x$ is the vector of $n$
unknowns and $bold b$ is the vector of $n$ right-hand side terms.   Through
out  this  package $bold A$ is denoted _M_a_t_r_i_x, $bold x$ is denoted _S_o_l_u_t_i_o_n
and $bold b$ is denoted _R_H_S (for right-hand side).  The  system  is  solved
using  LU  factorization, so the actual solution process is broken into two
steps, the factorization or  decomposition  of  the  matrix,  performed  by
_s_p_F_a_c_t_o_r_(_),  and  the  forward  and  backward  substitution,  performed  by
_s_p_S_o_l_v_e_(_).  _s_p_F_a_c_t_o_r_(_) factors the given matrix into upper and lower trian-
gular  matrices independent of the right-hand side.  Once this is done, the
solution vector can be determined efficiently for any number of  right-hand
sides without refactoring the matrix.

     This  package exploits the fact that large matrices usually are sparse
by not storing or operating on elements in the matrix that are zero.  Stor-
ing  zero  elements  is avoided by organizing the matrix into an orthogonal
linked-list.  Thus, to access an element if  only  its  indices  are  known
requires  stepping  through the list, which is slow.  This function is per-
formed by the routine _s_p_G_e_t_E_l_e_m_e_n_t_(_).  It is used to initially  enter  data
into  a  matrix  and  to  build  the  linked-list.  Because it is common to
repeatedly solve matrices with identical zero/nonzero structure, it is pos-
sible  to  reuse  the linked-list.  Thus, the linked list is left in memory
and the element values are simply cleared by _s_p_C_l_e_a_r_(_) before  the  linked-
list  is  reused.  To speed the entering of the element values into succes-
sive matrices, _s_p_G_e_t_E_l_e_m_e_n_t_(_) returns a  pointer  to  the  element  in  the
matrix.   This  pointer  can  then  be used to place data directly into the
matrix without having to traverse through the linked-list.

     The order in which the rows and columns of the matrix are factored  is
very  important.   It  directly affects the amount of time required for the
factorization and the forward and backward substitution.  It  also  affects
the  accuracy  of  the  result.  The process of choosing this order is time
consuming, but fortunately it usually only has to be  done  once  for  each
particular  matrix  structure  encountered.   When  a  matrix  with  a  new
zero/nonzero structure is to be factored, it is done by  using  _s_p_O_r_d_e_r_A_n_d_-
_F_a_c_t_o_r_(_).   Subsequent  matrices  of  the  same structure are factored with
_s_p_F_a_c_t_o_r_(_).  The latter routine  does  not  have  the  ability  to  reorder
matrix,  but  it is considerably faster.  It may be that a order chosen may
be unsuitable for subsequent factorizations.  If this is known to be true a
priori, it is possible to use _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) for the subsequent factor-
izations, with a noticeable speed penalty.  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) monitors the
numerical stability of the factorization and will modify an existing order-
ing to maintain stability.  Otherwise,  an  a  posteriori  measure  of  the
numerical  stability  of  the factorization can be computed, and the matrix
reordered if necessary.









                             -5-


     The _S_p_a_r_s_e routines allow several matrices of different structures  to
be  resident at once.  When a matrix of a new structure is encountered, the
user calls _s_p_C_r_e_a_t_e_(_).  This  routine  creates  the  basic  frame  for  the
linked-list  and  returns  a  pointer  to this frame.  This pointer is then
passed as an argument to the other _S_p_a_r_s_e routines to indicate which matrix
is to be operated on.  The number of matrices that can be kept in memory at
once is only limited by the amount of memory available to the user and  the
size  of the matrices.  When a matrix frame is no longer needed, the memory
can be reclaimed by calling _s_p_D_e_s_t_r_o_y_(_).

     A more complete discussion of sparse systems of equations, methods for
solving them, their error mechanisms, and the algorithms used in _S_p_a_r_s_e can
be found in Kundert [kundert86].  A particular emphasis is placed on matri-
ces resulting from circuit simulators.


22..22::  EErrrroorr CCoonnttrrooll

     There  are  two  separate  mechanisms that can cause errors during the
factoring and solution of a system of equations.  The first  is  ill-condi-
tioning  in  the  system.   A system of equations is ill-conditioned if the
solution is excessively sensitive to disturbances in the input data,  which
occurs  when the system is nearly singular.  If a system is ill-conditioned
then uncertainty in the result is unavoidable, even if $bold  A$  is  accu-
rately  factored  into  $bold  L$ and $bold U$.  When ill-conditioning is a
problem, the problem as stated is probably ill-posed and the system  should
be  reformulated such that it is not so ill-conditioned.  It is possible to
measure the ill-conditioning of matrix using _s_p_C_o_n_d_i_t_i_o_n_(_).  This  function
returns an estimate of the reciprocal of the condition number of the matrix
($kappa ( bold A )$) [strang80].  The condition number  can  be  used  when
computing a bound on the error in the solution using the following inequal-
ity [golub83].

   {norm delta bold x norm} over {norm bold x norm} ~<=~ kappa ( bold A)
left ( {norm delta bold A norm} over {norm bold A norm} ~+~
{norm delta bold b norm} over {norm bold b norm} right ) ~+~ "higher order terms"

where $delta bold A$ and $delta bold b$ are the uncertainties in the matrix
and right-hand side vector and are assumed small.

     The second mechanism that causes uncertainty is the build up of round-
off error.  Roundoff error can become  excessive  if  there  is  sufficient
growth  in  the  size  of the elements during the factorization.  Growth is
controlled by careful pivoting.  In _S_p_a_r_s_e, the pivoting is  controlled  by
the  relative  threshold parameter.  In conventional full matrix techniques
the pivot is chosen to be the largest element in a  column.   When  working
with  sparse  matrices  it  is  important  to choose pivots to minimize the
reduction in sparsity.  The best pivot to retain sparsity is often not  the
best  pivot  to  retain  accuracy.  Thus, some compromise must be made.  In
threshold pivoting, as used in this package, the best pivot to retain spar-
sity  is  used  unless  it is smaller than the relative threshold times the
largest element in the column.  Thus, a relative  threshold  close  to  one
emphasizes accuracy so it will produce a minimum amount of growth, unfortu-
nately it also slows the factorization.  A very  small  relative  threshold









                             -6-


emphasizes maintenance of sparsity and so speeds the factorization, but can
result in a large amount of growth.  In our experience, we have found  that
a  relative threshold of 0.001 seems to result in a satisfactory compromise
between speed and accuracy, though other authors suggest a  more  conserva-
tive value of 0.1 [duff86].

     The  growth  that  occurred  during a factorization can be computed by
taking the ratio of the largest matrix element in any stage of the  factor-
ization  to  the largest matrix element before factorization.  The two num-
bers are estimated using _s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_).  If the growth is found to  be
excessive  after  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_), then the relative threshold should be
increased and the matrix reconstructed and refactored.  Once the matrix has
been  ordered and factored without suffering too much growth, the amount of
growth that occurred should be recorded.  If, on subsequent factorizations,
as  performed  by  _s_p_F_a_c_t_o_r_(_),  the  amount of growth becomes significantly
larger, then the matrix should be reconstructed  and  reordered  using  the
same  relative  threshold  with _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).  If the growth is still
excessive, then the relative threshold should be raised again.


22..33::  BBuuiillddiinngg tthhee MMaattrriixx

     It is not necessary to specify the size of the matrix before beginning
to add elements to it.  When the compiler option EXPANDABLE is turned on it
is possible to initially specify the size of the matrix to any  size  equal
to  or smaller than the final size of the matrix.  Specifically, the matrix
size may be initially specified as zero.  If this is done then, as the ele-
ments  are entered into the matrix, the matrix is enlarged as needed.  This
feature is particularly useful in circuit simulators because it allows  the
building  of  the  matrix  as the circuit description is parsed.  Note that
once the matrix has been reordered by the routines _s_p_M_N_A___P_r_e_o_r_d_e_r_(_), _s_p_F_a_c_-
_t_o_r_(_) or _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) the size of the matrix becomes fixed and may no
longer be enlarged unless the compiler option TRANSLATE is enabled.

     The TRANSLATE option allows _S_p_a_r_s_e to translate a  non-packed  set  of
row  and  column  numbers to an internal packed set.  In other words, there
may be rows and columns  missing  from  the  external  description  of  the
matrix.   This  feature  provides two benefits.  First, if two matrices are
identical in structure, except for a few missing rows and columns  in  one,
then  the  TRANSLATE  option  allows them to be treated identically.  Simi-
larly, rows and columns may be deleted from a  matrix  after  it  has  been
built  and operated upon.  Deletion of rows and columns is performed by the
function _s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_).  Second, it allows the use of  the  functions
_s_p_G_e_t_E_l_e_m_e_n_t_(_),  _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_),  _s_p_G_e_t_Q_u_a_d_(_), and _s_p_G_e_t_O_n_e_s_(_) after the
matrix has been reordered.  These functions access the matrix by using  row
and  column  indices,  which have to be translated to internal indices once
the matrix is reordered.  Thus, when TRANSLATE is used in conjunction  with
the  EXPANDABLE  option, rows and columns may be added to a matrix after it
has been reordered.

     Another provided feature that is useful with circuit simulators is the
ability  to  add  elements to the matrix in row zero or column zero.  These
elements will have no affect on the matrix or the results.  The benefit  of
this  is that when working with a nodal formulation, grounded components do









                             -7-


not have to be treated special when building the matrix.


22..44::  IInniittiiaalliizziinngg tthhee MMaattrriixx

     Once a matrix has been factored, it is necessary to clear  the  matrix
before  it  can  be  reloaded with new values.  The straight forward way of
doing that is to call _s_p_C_l_e_a_r_(_), which sets the value of every  element  in
the  matrix to zero.  _S_p_a_r_s_e also provides a more flexible way to clear the
matrix.  Using _s_p_I_n_i_t_i_a_l_i_z_e_(_), it is possible to clear and reload at  least
part of the matrix in one step.

     _S_p_a_r_s_e  allows  the  user to keep initialization information with each
structurally nonzero matrix element.  Each element has a  pointer  that  is
set  and  used  by  the  user.   The  user can set this pointer using _s_p_I_n_-
_s_t_a_l_l_I_n_i_t_I_n_f_o_(_) and may read it using _s_p_G_e_t_I_n_i_t_I_n_f_o_(_).  The function _s_p_I_n_i_-
_t_i_a_l_i_z_e_(_)  is  a user customizable way to initialize the matrix.  Passed to
this routine is a function pointer.  _s_p_I_n_i_t_i_a_l_i_z_e_(_)  sweeps  through  every
element  in  the matrix and checks the _p_I_n_i_t_I_n_f_o pointer (the user supplied
pointer).  If the _p_I_n_i_t_I_n_f_o is NULL, which is true unless the user  changes
it  (always true for fill-ins), then the element is zeroed.  Otherwise, the
function pointer is called and passed the _p_I_n_i_t_I_n_f_o pointer as well as  the
element  pointer and the external row and column numbers, allowing the user
to initialize the matrix element and the right-hand side.

     Why _s_p_I_n_i_t_i_a_l_i_z_e_(_) would be used over _s_p_C_l_e_a_r_(_) can be illustrated  by
way  of  an  example.  Consider a circuit simulator that handles linear and
nonlinear resistors and capacitors performing a  transient  analysis.   For
the  linear  resistors,  a constant value is loaded into the matrix at each
time step and for each Newton iteration.  For the linear capacitor, a value
is loaded into the matrix that is constant over Newton iterations, but is a
function of the time step and the integration method.  The nonlinear compo-
nents  contribute  values  to the matrix that change on every time step and
Newton iteration.

     _S_p_a_r_s_e allows the user to attach a data structure to each  element  in
the  matrix.  For this example, the user might attach a structure that held
several pieces of information, such as the conductance of the linear resis-
tor,  the  capacitance of the linear capacitor, the capacitance of the non-
linear capacitor, and perhaps past values of capacitances.  The  user  also
provides  a  subroutine to _s_p_I_n_i_t_i_a_l_i_z_e_(_) that is called for each user-cre-
ated element in the matrix.  This routine would, using the  information  in
the  attached data structure, initialize the matrix element and perhaps the
right-hand side vector.

     In this example, the user supplied routine might load the linear  con-
ductance  into the matrix and multiply it by some voltage to find a current
that could be loaded into the right-hand side vector.  For the  capacitors,
the  routine  would  first  apply  an  integration method and then load the
matrix and the right-hand side.

     This approach is useful for two reasons.  First, much of the  work  of
the device code in the simulator can be off-loaded onto the matrix package.
Since there are usually many devices, this usually  results  overall  in  a









                             -8-


simpler system.  Second, the integration method can be hidden from the sim-
ulator device code.  Thus the integration method can be changed  simply  by
changing  the routine handed to _s_p_I_n_i_t_i_a_l_i_z_e_(_), resulting in a much cleaner
and more easily maintained simulator.


22..55::  IInnddiicceess

     By far the most common errors made when using _S_p_a_r_s_e  are  related  to
array  indices.  _S_p_a_r_s_e itself contributes to the problem by having several
different indexing schemes.  There are three different options that  affect
index  bounds  or the way indices are interpreted.  The first is ARRAY_OFF-
SET, which only affects array indices.  ARRAY_OFFSET  is  a  compiler  flag
that selects whether arrays start at index zero or index one.  Note that if
ARRAY_OFFSET is zero then _R_H_S[0] corresponds to row one in the  matrix  and
_S_o_l_u_t_i_o_n[0] corresponds to column one.  Further note that when ARRAY_OFFSET
is set to one, then the allocated length of the arrays handed to the _S_p_a_r_s_e
routines  should be at least the external size of the matrix plus one.  The
main utility of ARRAY_OFFSET is that it allows natural array indexing  when
_S_p_a_r_s_e  is coupled to programs in other languages.  For example; in FORTRAN
arrays always start at one whereas in C array always start at  zero.   Thus
the  first entry in a FORTRAN array corresponds to the zero'th entry in a C
array.  Setting ARRAY_OFFSET to zero allows the arrays in FORTRAN to  start
at  one  rather  than  two.   For  the rest of this discussion, assume that
ARRAY_OFFSET is set so that arrays start at one in the program  that  calls
_S_p_a_r_s_e.

     The second option that affects indices is EXPANDABLE.  When EXPANDABLE
is set false the upper bound on array and matrix  indices  is  _S_i_z_e,  where
_S_i_z_e  is  a parameter handed to _s_p_C_r_e_a_t_e_(_).  When EXPANDABLE set true, then
there is essentially no upper bound on array indices.  Indeed, the size  of
the  matrix  is  determined  by  the largest row or column number handed to
_S_p_a_r_s_e.  The upper bound on the array indices then equals  the  final  size
determined  by _S_p_a_r_s_e.  This size can be determined by calling _s_p_G_e_t_S_i_z_e_(_).

     The final option that affects indices is TRANSLATE.  This  option  was
provided to allow row and columns to be deleted, but it also allows row and
column numbers to be missing from the input description for a matrix.  This
means  that  the size of the matrix is not determined by the largest row or
column number entered into the matrix.  Rather, the size is  determined  by
the  total  number of rows or column entered.  For example, if the elements
[2,3], [5,3], and [7,2] are entered into the matrix, the internal  size  of
the  matrix  becomes  four  while the external size is seven.  The internal
size equals the number of rows and columns in the matrix while the external
size equals the largest row or column number entered into the matrix.  Note
that if a row is entered into the matrix, then its corresponding column  is
also  entered,  and  vice  versa.  The indices used in the _R_H_S and _S_o_l_u_t_i_o_n
vectors correspond to the row and column indices in the matrix.  Thus,  for
this  example,  valid  data  is expected in _R_H_S at locations 2, 3, 5 and 7.
Data at other locations is ignored.  Similarly, valid data is  returned  in
_S_o_l_u_t_i_o_n  at  locations 2, 3, 5, and 7.  The other locations are left unmo-
lested.  This shows that the length of the arrays correspond to the  exter-
nal  size  of  the  matrix.   Again, this value can be determined by _s_p_G_e_t_-
_S_i_z_e_(_).









                             -9-


22..66::  CCoonnffiigguurriinngg SSppaarrssee

     It is possible at compile-time to customize _S_p_a_r_s_e for your particular
application.  This is done by changing the compiler options, which are kept
in the personality file, ssppCCoonnffiigg..hh.  There are three  classes  of  choices
available.   First  are the _S_p_a_r_s_e options, which specify the dominant per-
sonality characteristics, such as if real and/or complex systems  of  equa-
tions are to be handled.  The second class is the _S_p_a_r_s_e constants, such as
the default pivot threshold and the amount of  memory  initially  allocated
per  matrix.   The last class is the machine constants.  These numbers must
be updated when _S_p_a_r_s_e is ported to another machine.

     As an aid in the setup and testing of _S_p_a_r_s_e a test routine  and  sev-
eral  test  matrices and their solutions have been provided.  The test rou-
tine is capable of reading files generated by _s_p_F_i_l_e_M_a_t_r_i_x_(_) and _s_p_F_i_l_e_V_e_c_-
_t_o_r_(_).

     By  default  _S_p_a_r_s_e  stores all real numbers and performs all computa-
tions using double precision arithmetic.  This can be changed  by  changing
the  definition of _s_p_R_E_A_L from ddoouubbllee to ffllooaatt.  _s_p_R_E_A_L is defined in ssppEExx--
ppoorrttss..hh.










































                            -10-


33::  IINNTTRROODDUUCCTTIIOONN TTOO TTHHEE SSPPAARRSSEE RROOUUTTIINNEESS

In this section the routines are grouped by function and briefly described.

33..11::  CCrreeaattiinngg tthhee MMaattrriixx

_s_p_C_r_e_a_t_e_(_)
     Allocates  and initializes the data structure for a matrix.  Necessar-
     ily the first routine run for any particular matrix.

_s_p_D_e_s_t_r_o_y_(_)
     Destroys the data structure for a matrix and frees the memory.

_s_p_S_e_t_R_e_a_l_(_)
_s_p_S_e_t_C_o_m_p_l_e_x_(_)
     These routines toggle a flag internal to _S_p_a_r_s_e  that  indicates  that
     the matrix is either real or complex.  This is useful if both real and
     complex matrices of identical structure are expected.


33..22::  BBuuiillddiinngg tthhee MMaattrriixx

_s_p_G_e_t_E_l_e_m_e_n_t_(_)
     Assures that the specified element exists in the matrix data structure
     and returns a pointer to it.

_s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_)
_s_p_G_e_t_Q_u_a_d_(_)
_s_p_G_e_t_O_n_e_s_(_)
     These  routines  add  a  group of four related elements to the matrix.
     _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_) adds the four elements associated with a two  termi-
     nal  admittance.  _s_p_G_e_t_Q_u_a_d_(_) is a more general routine that is useful
     for entering controlled sources to the matrix.  _s_p_G_e_t_O_n_e_s_(_)  adds  the
     four  structural  ones  to  the matrix that are often encountered with
     elements that do not have admittance representations.

_s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_)
     This function is used to delete a row and column from the matrix.


33..33::  CClleeaarriinngg tthhee MMaattrriixx

_s_p_C_l_e_a_r_(_)
     Sets every element in the matrix to zero.

_s_p_I_n_i_t_i_a_l_i_z_e_(_)
     Runs a user provided initialization routine on  each  element  in  the
     matrix.  This routine would be used in lieu of _s_p_C_l_e_a_r_(_).

_s_p_G_e_t_I_n_i_t_I_n_f_o_(_)
_s_p_I_n_s_t_a_l_l_I_n_i_t_I_n_f_o_(_)
     These  routines  allow  the  user  to install and read a user-provided
     pointer to initialization data for a particular matrix element.










                            -11-


_s_p_S_t_r_i_p_F_i_l_l_s_(_)
     This routine returns a matrix to a semi-virgin state by  removing  all
     fill-ins.   This  can  be useful if a matrix is to be reordered and it
     has changed significantly since it was previously ordered.   This  may
     be the case if a few rows and columns have been added or deleted or if
     the previous ordering was done on a matrix that was numerically  quite
     different  than  the  matrix  currently being factored.  Stripping and
     reordering a matrix may speed subsequent factorization if the  current
     ordering  is  inferior,  whereas simply reordering will generally only
     enhance accuracy and not speed.


33..44::  PPllaacciinngg DDaattaa iinn tthhee MMaattrriixx

_s_p_A_D_D___R_E_A_L___E_L_E_M_E_N_T_(_)
_s_p_A_D_D___I_M_A_G___E_L_E_M_E_N_T_(_)
_s_p_A_D_D___C_O_M_P_L_E_X___E_L_E_M_E_N_T_(_)
     Adds a value to a particular matrix element.

_s_p_A_D_D___R_E_A_L___Q_U_A_D_(_)
_s_p_A_D_D___I_M_A_G___Q_U_A_D_(_)
_s_p_A_D_D___C_O_M_P_L_E_X___Q_U_A_D_(_)
     Adds a value to a group of four matrix elements.


33..55::  IInnfflluueenncciinngg tthhee FFaaccttoorriizzaattiioonn

_s_p_M_N_A___P_r_e_o_r_d_e_r_(_)
     This routine preorders  modified  node  admittance  matrices  so  that
     _S_p_a_r_s_e  can  take  full  advantage of their structure.  In particular,
     this routine tries to remove zeros from the diagonal so that  diagonal
     pivoting can be used more successfully.

_s_p_P_a_r_t_i_t_i_o_n_(_)
     _S_p_a_r_s_e  partitions  the matrix in an attempt to make _s_p_F_a_c_t_o_r_(_) run as
     fast as possible.  The partitioning is a relatively  expensive  opera-
     tion  that  is not needed in all cases.  _s_p_P_a_r_t_i_t_i_o_n_(_) allows the user
     specify a simpler and faster partitioning.

_s_p_S_c_a_l_e_(_)
     It is sometimes desirable to scale the rows and columns of a matrix in
     to achieve a better pivoting order.  This is particularly true in mod-
     ified node admittance matrices, where the size of the  elements  in  a
     matrix  can  easily  vary  through  ten to twelve orders of magnitude.
     This routine performs scaling on a matrix.


33..66::  FFaaccttoorriinngg tthhee MMaattrriixx

_s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)
     This routine chooses a pivot order for the matrix and factors it  into
     LU  form.   It  handles  both the initial factorization and subsequent
     factorizations when a reordering is desired.










                            -12-


_s_p_F_a_c_t_o_r_(_)
     Factors a matrix that has already been ordered by  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).
     If _s_p_F_a_c_t_o_r_(_) is passed a matrix that needs ordering, it will automat-
     ically pass the matrix to _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).


33..77::  SSoollvviinngg tthhee MMaattrriixx EEqquuaattiioonn

_s_p_S_o_l_v_e_(_)
     Solves the matrix equation

          bold "A" bold x ~=~ bold b

     given the matrix $bold A$ factored into LU form and $bold b$.

_s_p_S_o_l_v_e_T_r_a_n_s_p_o_s_e_d_(_)
     When working with adjoint systems, such as in sensitivity analysis, it
     is desirable to quickly solve

          bold "A" sup roman T bold x ~=~ bold b

     Once $bold A$ has been factored into LU form, this routine can be used
     to solve the transposed system without having to suffer  the  cost  of
     factoring the matrix again.


33..88::  NNuummeerriiccaall EErrrroorr EEssttiimmaattiioonn

_s_p_C_o_n_d_i_t_i_o_n_(_)
     Estimates  the L-infinity condition number of the matrix.  This number
     is a measure of the ill-conditioning in the matrix  equation.   It  is
     also useful for making estimates of the error in the solution.

_s_p_N_o_r_m_(_)
     Returns  the  L-infinity  norm  (the  maximum  absolute row sum) of an
     unfactored matrix.

_s_p_P_s_e_u_d_o_C_o_n_d_i_t_i_o_n_(_)
     Returns the ratio of the largest pivot to the smallest pivot of a fac-
     tored  matrix.   This  is a rough indicator of ill-conditioning in the
     matrix.

_s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_)
     If passed an unfactored matrix,  this  routine  returns  the  absolute
     value  of  the  largest  element  in the matrix.  If passed a factored
     matrix, it returns an estimate of the largest element that occurred in
     any of the reduced submatrices during the factorization.  The ratio of
     these two numbers (factored/unfactored) is the growth, which  is  used
     to determine if the pivoting order is numerically satisfactory.














                            -13-


_s_p_R_o_u_n_d_o_f_f_(_)
     Returns a bound on the magnitude of the largest element in $bold E ~=~
     bold A - bold LU$, where $bold  E$  represents  error  in  the  matrix
     resulting from roundoff error during the factorization.


33..99::  MMaattrriixx OOppeerraattiioonnss

_s_p_D_e_t_e_r_m_i_n_a_n_t_(_)
     This routine simply calculates and returns the determinant of the fac-
     tored matrix.

_s_p_M_u_l_t_i_p_l_y_(_)
     This routine multiplys the matrix by a vector on the right.   This  is
     useful  for  forming  the product $ bold "Ax" ~=~ bold b $ in order to
     determine if a calculated solution is correct.

_s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_(_)
     Multiplys the transposed matrix by a vector on  the  right.   This  is
     useful for forming the product $ bold "A sup {roman T} x" ~=~ bold b $
     in order to determine if a calculated solution is correct.


33..1100::  MMaattrriixx SSttaattiissttiiccss aanndd DDooccuummeennttaattiioonn

_s_p_E_r_r_o_r_(_)
     Determines the error status of a particular matrix.  While most of the
     _S_p_a_r_s_e  routines  do  return an indication that an error has occurred,
     some do not and so _s_p_E_r_r_o_r_(_) provides the only way of uncovering these
     errors.

_s_p_W_h_e_r_e_S_i_n_g_u_l_a_r_(_)
     Returns  the  row  and  column number where the matrix was detected as
     singular or where a zero pivot was found.

_s_p_G_e_t_S_i_z_e_(_)
     A function that returns the size of the matrix.  Either  the  internal
     or  external size of the matrix is returned.  The internal size of the
     matrix is the actual size of the matrix whereas the external  size  is
     the  value of the largest row or column number.  These two numbers may
     differ if the TRANSLATE option is used.

_s_p_E_l_e_m_e_n_t_C_o_u_n_t_(_)
_s_p_F_i_l_l_i_n_C_o_u_n_t_(_)
     Functions that return the total number of elements in the matrix,  and
     the  number of fill-ins in the matrix.  These functions are useful for
     gathering statistics on matrices.
















                            -14-


_s_p_P_r_i_n_t_(_)
     This routine outputs the matrix as well as some statistics to standard
     output  in  a  format  that  is readable by people.  The matrix can be
     printed in either a compressed or standard format.   In  the  standard
     format,  a  numeric  value is given for each structurally nonzero ele-
     ment, whereas in the compressed format, only the existence or nonexis-
     tence  of  an  element is indicated.  This routine is not suitable for
     use on large matrices.

_s_p_F_i_l_e_M_a_t_r_i_x_(_)
_s_p_F_i_l_e_V_e_c_t_o_r_(_)
     These two routines send a copy of the matrix and its  right-hand  side
     vector to a file.  This file can then be read by the test program that
     is included with _S_p_a_r_s_e.  Only those elements of the matrix  that  are
     structurally nonzero are output, so very large matrices can be sent to
     a file.

_s_p_F_i_l_e_S_t_a_t_s_(_)
     This routine calculates and sends some useful statistics concerning  a
     matrix to a file.











































                            -15-


44::  SSPPAARRSSEE RROOUUTTIINNEESS

This  section  contains  a  complete  list  of the _S_p_a_r_s_e routines that are
available to the user.  Each routine is described as to  its  function  and
how to use it.  The routines are listed in alphabetic order.


____________________________________________________________

44..11::  ssppCClleeaarr(())

Sets  every  element  in  the  matrix  to  zero.  The _S_p_a_r_s_e error state is
cleared to spOKAY in this routine.
vvooiidd _s_p_C_l_e_a_r_( _M_a_t_r_i_x _)

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix that is to be cleared.

____________________________________________________________










































                            -16-


____________________________________________________________

44..22::  ssppCCoonnddiittiioonn(())

_s_p_C_o_n_d_i_t_i_o_n_(_) computes an estimate of the condition number using  a  varia-
tion  on  the LINPACK condition number estimation algorithm.  This quantity
is an measure of ill-conditioning in the matrix.  To  avoid  problems  with
overflow, the reciprocal of the condition number is returned.  If this num-
ber is small, and if the matrix is scaled such that  uncertainties  in  the
RHS  and the matrix entries are equilibrated, then the matrix is ill-condi-
tioned.  If the this number is near one, the matrix  is  well  conditioned.
This  routine  must  only  be  used  after  a  matrix  has been factored by
_s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) or _s_p_F_a_c_t_o_r_(_) and before it is cleared by  _s_p_C_l_e_a_r_(_)  or
_s_p_I_n_i_t_i_a_l_i_z_e_(_).

Unlike  the LINPACK condition number estimator, this routines returns the L
infinity condition number.  This is an artifact of Sparse placing  ones  on
the  diagonal  of  the upper triangular matrix rather than the lower.  This
difference should be of no importance.
_s_p_R_E_A_L _s_p_C_o_n_d_i_t_i_o_n_( _M_a_t_r_i_x_, _N_o_r_m_O_f_M_a_t_r_i_x_, _E_r_r_o_r _)

+o Returns:
     An estimate of the L infinity condition number of the matrix.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          The matrix for which the condition number is desired.

     _N_o_r_m_O_f_M_a_t_r_i_x  input  (spREAL)
          The L-infinity norm of  the  unfactored  matrix  as  computed  by
          _s_p_N_o_r_m_(_).

     _E_r_r_o_r  output  (iinntt **)
          Used to return the error code.

+o Possible errors:
     spSINGULAR
     spNO_MEMORY
     Error is not cleared in this routine.

+o Compiler options that must be set for this routine to exist:
     CONDITION

____________________________________________________________


















                            -17-


____________________________________________________________

44..33::  ssppCCrreeaattee(())

Allocates  and  initializes  the  data structures associated with a matrix.
This routine is necessarily  the  first  routine  run  for  any  particular
matrix.
cchhaarr **_s_p_C_r_e_a_t_e_( _S_i_z_e_, _C_o_m_p_l_e_x_, _E_r_r_o_r _)

+o Returned:
     A pointer to the matrix is returned cast into the form of a pointer to
     a character.  This pointer is then passed and used by the other matrix
     routines  to  refer  to  a particular matrix.  If an error occurs, the
     NULL pointer is returned.

+o Arguments:

     _S_i_z_e  input  (iinntt)
          Size of matrix.  When the compiler option  EXPANDABLE  is  turned
          on,  _S_i_z_e  is  used  as  a lower bound on the size of the matrix.
          _S_i_z_e must not be negative.

     _C_o_m_p_l_e_x  input  (iinntt)
          Type of matrix.  If _C_o_m_p_l_e_x is 0 then the matrix is real,  other-
          wise  the  matrix will be complex.  Note that if the routines are
          not set up to handle the type of matrix requested, then a spPANIC
          error will occur.

     _E_r_r_o_r  output  (iinntt **)
          Returns  error  flag,  needed because function _s_p_E_r_r_o_r_(_) will not
          work correctly if _s_p_C_r_e_a_t_e_(_) returns NULL.

+o Possible errors:
     spNO_MEMORY
     spPANIC

____________________________________________________________


























                            -18-


____________________________________________________________

44..44::  ssppDDeelleetteeRRoowwAAnnddCCooll(())

This function is used to delete a row and column from the matrix.  The ele-
ments  removed from the matrix are never used again and are not freed until
the matrix is destroyed and so the pointers to these elements remain valid.
vvooiidd _s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_( _M_a_t_r_i_x_, _R_o_w_, _C_o_l _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          The matrix from which the row and column are to be deleted.

     _R_o_w  input  (iinntt)
          The row to be deleted.

     _C_o_l  input  (iinntt)
          The column to be deleted.

+o Compiler options that must be set for this routine to exist:
     DELETE
     TRANSLATE

____________________________________________________________
____________________________________________________________

44..55::  ssppDDeessttrrooyy(())

Destroys a matrix frame and reclaims the memory.
vvooiidd _s_p_D_e_s_t_r_o_y_( _M_a_t_r_i_x _)

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix frame which is to be removed from memory.

____________________________________________________________

























                            -19-


____________________________________________________________

44..66::  ssppDDeetteerrmmiinnaanntt(())

This  routine  in capable of calculating the determinant of the matrix once
the LU factorization has been performed.   Hence,  only  use  this  routine
after  _s_p_F_a_c_t_o_r_(_)  or _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) and before _s_p_C_l_e_a_r_(_) or _s_p_I_n_i_t_i_a_l_-
_i_z_e_(_).  Note that the determinants of matrices can be very  large  or  very
small.   On  large  matrices,  the determinant can be far larger or smaller
than can be represented by a floating point number.  For  this  reason  the
mantissa and exponent of the determinant are returned separately.
vvooiidd _s_p_D_e_t_e_r_m_i_n_a_n_t_( _M_a_t_r_i_x_, _E_x_p_o_n_e_n_t_, _D_e_t_e_r_m_i_n_a_n_t _)
vvooiidd _s_p_D_e_t_e_r_m_i_n_a_n_t_( _M_a_t_r_i_x_, _E_x_p_o_n_e_n_t_, _D_e_t_e_r_m_i_n_a_n_t_, _i_D_e_t_e_r_m_i_n_a_n_t _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          The matrix for which the determinant is desired.

     _E_x_p_o_n_e_n_t  output  (iinntt **)
          The  logarithm  base  10 of the scale factor for the determinant.
          To find the actual determinant, Exponent should be added  to  the
          exponent of _D_e_t_e_r_m_i_n_a_n_t and _i_D_e_t_e_r_m_i_n_a_n_t.

     _D_e_t_e_r_m_i_n_a_n_t  output  (spREAL **)
          The real portion of the determinant.  If the matrix is real, then
          the magnitude of this number is scaled  to  be  greater  than  or
          equal  to  1.0 and less than 10.0. Otherwise the magnitude of the
          complex determinant will be scaled such.

     _i_D_e_t_e_r_m_i_n_a_n_t  output  (spREAL **)
          The imaginary portion of the determinant.   When  the  matrix  is
          real this pointer need not be supplied; nothing will be returned.

+o Compiler options that must be set for this routine to exist:
     DETERMINANT

+o Bugs:
     The sign of determinant may be in error if rows and columns have  been
     added or deleted from matrix.

____________________________________________________________





















                            -20-


____________________________________________________________

44..77::  ssppEElleemmeennttCCoouunntt(())

Returns the total number of structurally nonzero elements in the matrix.
iinntt _s_p_E_l_e_m_e_n_t_C_o_u_n_t_( _M_a_t_r_i_x _)

+o Returns:
     The total number of structurally nonzero elements.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix.

____________________________________________________________
____________________________________________________________

44..88::  ssppEErrrroorr(())

This function returns the error status of a matrix.
iinntt _M_a_t_r_i_x_E_r_r_o_r_( _M_a_t_r_i_x _)

+o Returned:
     The error status of the given matrix.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          The matrix for which the error status is desired.

+o Possible errors:
     spOKAY
     spILL_CONDITIONED
     spZERO_PIVOT
     spSINGULAR
     spNO_MEMORY
     spPANIC
     Error is not cleared in this routine.

____________________________________________________________






















                            -21-


____________________________________________________________

44..99::  ssppFFaaccttoorr(())

This  routine  factors the matrix into LU form and is the companion routine
to _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).  Unlike _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_), _s_p_F_a_c_t_o_r_(_) cannot change
the ordering.  Its utility is that it is considerably faster.  The standard
way to use these two routines is to first use  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)  for  the
initial  factorization.  For subsequent factorizations, _s_p_F_a_c_t_o_r_(_) is used.
If _s_p_F_a_c_t_o_r_(_) is called for the initial factorization of the  matrix,  then
it  will automatically call _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) with the default thresholds.
If _s_p_F_a_c_t_o_r_(_) finds a zero on the diagonal, it  will  terminate  early  and
complain.   This does not necessarily mean that matrix is singular.  Before
a matrix  is  condemned  as  being  singular,  it  should  be  run  through
_s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_),  which  can reorder the matrix and remove the offensive
zero from the diagonal.
iinntt _s_p_F_a_c_t_o_r_( _M_a_t_r_i_x _)

+o Returned:
     The error code is returned.  Possible errors are listed below.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix to be factored.

+o Possible errors:
     spZERO_PIVOT
     spNO_MEMORY
     spSINGULAR
     spILL_CONDITIONED

____________________________________________________________






























                            -22-


____________________________________________________________

44..1100::  ssppFFiilleeMMaattrriixx(())

Writes matrix to file in format suitable to be read back in by  the  matrix
test  program.   Normally,  _s_p_F_i_l_e_M_a_t_r_i_x_(_)  should  be  executed before the
matrix is factored, otherwise matrix is output in factored  form.   If  the
matrix  is  sent to a file without the header or data, it will be in a form
that is easily plotted by typical plotting programs.
iinntt _s_p_F_i_l_e_M_a_t_r_i_x_( _M_a_t_r_i_x_, _F_i_l_e_, _L_a_b_e_l_, _R_e_o_r_d_e_r_e_d_, _D_a_t_a_, _H_e_a_d_e_r _)

+o Returns:
     One is returned if routine was successful, otherwise zero is returned.
     The  calling  function  can query _e_r_r_n_o (the system global error vari-
     able) as to the reason why this routine failed.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix that is to be sent to file.

     _F_i_l_e  input  (cchhaarr **)
          Name of output file.

     _L_a_b_e_l  input  (cchhaarr **)
          String that is transferred to file and used as a  label.   String
          should fit on one line and have no embedded line feeds.

     _R_e_o_r_d_e_r_e_d  input  (iinntt)
          Specifies  whether the matrix should be output using the original
          order or in reordered form.  Zero specifies original order.

     _D_a_t_a  input  (iinntt)
          Indicates that the element values should be output along with the
          indices  for each element.  Element values are not output if _D_a_t_a
          is zero.  This parameter must be nonzero if matrix is to be  read
          by the _S_p_a_r_s_e test program.

     _H_e_a_d_e_r  input  (iinntt)
          If  nonzero  a  header  is  output that includes that size of the
          matrix and the label.  This parameter must be nonzero  if  matrix
          is to be read by the _S_p_a_r_s_e test program.

+o Compiler options that must be set for this routine to exist:
     DOCUMENTATION

____________________________________________________________
















                            -23-


____________________________________________________________

44..1111::  ssppFFiilleeSSttaattss(())

Appends  useful information concerning the matrix to the end of a file.  If
file does not exist, it is created.  This file should not be  the  same  as
one  used  to  hold the matrix or vector if the matrix is to be read by the
_S_p_a_r_s_e test program.  Should be executed after the matrix is factored.
iinntt _s_p_F_i_l_e_S_t_a_t_s_( _M_a_t_r_i_x_, _F_i_l_e_, _L_a_b_e_l _)

+o Returns:
     One is returned if routine was successful, otherwise zero is returned.
     The  calling  function  can query _e_r_r_n_o (the system global error vari-
     able) as to the reason why this routine failed.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix for which statistics are desired.

     _F_i_l_e  input  (cchhaarr **)
          Name of output file.

     _L_a_b_e_l  input  (cchhaarr **)
          String that is transferred to file and is used as a label. String
          should fit on one line and have no embedded line feeds.

+o Compiler options that must be set for this routine to exist:
     DOCUMENTATION

____________________________________________________________
































                            -24-


____________________________________________________________

44..1122::  ssppFFiilleeVVeeccttoorr(())

Appends the _R_H_S vector to the end of a file in a format suitable to be read
back in by the matrix test program.  If file does not exist, it is created.
To  be  compatible with the test program, if _s_p_F_i_l_e_V_e_c_t_o_r_(_) is run, it must
be run after _s_p_F_i_l_e_M_a_t_r_i_x_(_) and use the same file.
iinntt _s_p_F_i_l_e_V_e_c_t_o_r_( _M_a_t_r_i_x_, _F_i_l_e_, _R_H_S _)
iinntt _s_p_F_i_l_e_V_e_c_t_o_r_( _M_a_t_r_i_x_, _F_i_l_e_, _R_H_S_, _i_R_H_S _)

+o Returns:
     One is returned if routine was successful, otherwise zero is returned.
     The  calling  function  can query _e_r_r_n_o (the system global error vari-
     able) as to the reason why this routine failed.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix that corresponds to the vector to be output.

     _F_i_l_e  input  (cchhaarr **)
          Name of file where output is to be written.

     _R_H_S  input  (spREAL[])
          The right-hand side vector.  _R_H_S contains only the  real  portion
          of the right-hand side vector if the matrix is complex and spSEP-
          ARATED_COMPLEX_VECTORS is set true.

     _i_R_H_S  input  (spREAL[])
          Right-hand side vector,  imaginary  portion.   Not  necessary  if
          matrix is real or if spSEPARATED_COMPLEX_VECTORS is set false.

+o Compiler options that must be set for this routine to exist:
     DOCUMENTATION

____________________________________________________________


























                            -25-


____________________________________________________________

44..1133::  ssppFFiilllliinnCCoouunntt(())

Returns  the  total number of fill-ins in the matrix.  A fill-in is an ele-
ment that is originally structurally zero, but becomes nonzero  during  the
factorization.
iinntt _s_p_F_i_l_l_i_n_C_o_u_n_t_( _M_a_t_r_i_x _)

+o Returns:
     The total number of fill-ins.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix.

____________________________________________________________













































                            -26-


____________________________________________________________

44..1144::  ssppGGeettAAddmmiittttaannccee(())

Performs  same  function  as _s_p_G_e_t_E_l_e_m_e_n_t_(_) except rather than one element,
all four matrix elements for a floating admittance are reserved.  This rou-
tine  also  works  if the admittance is grounded (zero is the ground node).
This function returns a group of pointers to the four elements through _T_e_m_-
_p_l_a_t_e,  which  is  an  output.  They are used by the _s_p_A_D_D___Q_U_A_D_(_) macros to
directly access matrix elements during  subsequent  loads  of  the  matrix.
_s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_)   arranges   the   pointers   in  _T_e_m_p_l_a_t_e  so  that  the
_s_p_A_D_D___Q_U_A_D_(_) routines add the admittance to the elements  at  [_N_o_d_e_1_,_N_o_d_e_1]
and  [_N_o_d_e_2_,_N_o_d_e_2]  and  subtract  the  admittance  from  the  elements  at
[_N_o_d_e_1_,_N_o_d_e_2] and [_N_o_d_e_2_,_N_o_d_e_1]. This routine is only  to  be  used  before
_s_p_M_N_A___P_r_e_o_r_d_e_r_(_), _s_p_F_a_c_t_o_r_(_) or _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) unless the compiler flag
TRANSLATE is enabled.
iinntt _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_( _M_a_t_r_i_x_, _N_o_d_e_1_, _N_o_d_e_2_, _T_e_m_p_l_a_t_e _)

+o Returned:
     The error code is returned.  Possible errors are listed below.   _s_p_G_e_-
     _t_A_d_m_i_t_t_a_n_c_e_(_)  does  not  clear  the error state, so it is possible to
     ignore the return code of each _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_) call, and  check  for
     errors after constructing the whole matrix by calling _s_p_E_r_r_o_r_(_).

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix that admittance is to be installed.

     _N_o_d_e_1  input  (iinntt)
          One  node  number for the admittance.  _N_o_d_e_1 must be in the range
          [0.._S_i_z_e] unless either  the  TRANSLATE  or  EXPANDABLE  compiler
          flags are set true.  In either case _N_o_d_e_1 must not be negative.

     _N_o_d_e_2  input  (iinntt)
          Other node number for the admittance.  _N_o_d_e_2 must be in the range
          [0.._S_i_z_e] unless either  the  TRANSLATE  or  EXPANDABLE  compiler
          flags are set true.  In either case _N_o_d_e_2 must not be negative.

     _T_e_m_p_l_a_t_e  output  (ssttrruucctt _s_p_T_e_m_p_l_a_t_e **)
          Collection  of  pointers  to four elements that are later used to
          directly address elements.  User must supply the  template,  this
          routine will fill it.

+o Possible errors:
     spNO_MEMORY
     Error is not cleared in this routine.

+o Compiler options that must be set for this routine to exist:
     QUAD_ELEMENT

____________________________________________________________











                            -27-


____________________________________________________________

44..1155::  ssppGGeettEElleemmeenntt(())

Reserves  an  element at [_R_o_w_,_C_o_l] and returns a pointer to it.  If element
is not found then it is created and spliced into matrix.  A pointer to  the
real portion of the element is returned.  This pointer is later used by the
_s_p_A_D_D___E_L_E_M_E_N_T_(_) macros to directly access the  element.   This  routine  is
only  to  be used before _s_p_M_N_A___P_r_e_o_r_d_e_r_(_), _s_p_F_a_c_t_o_r_(_) or _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)
unless the compiler option TRANSLATE is set true.
spREAL **_s_p_G_e_t_E_l_e_m_e_n_t_( _M_a_t_r_i_x_, _R_o_w_, _C_o_l _)

+o Returned:
     Returns a pointer to the  element.   This  pointer  is  then  used  to
     directly access the element during successive builds.  Returns NULL if
     insufficient memory is available.  _s_p_G_e_t_E_l_e_m_e_n_t_(_) does not  clear  the
     error  state,  so  it  is  possible  to ignore the return code of each
     _s_p_G_e_t_E_l_e_m_e_n_t_(_) call, and check for errors after constructing the whole
     matrix by calling _s_p_E_r_r_o_r_(_).

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix that the element is to be added to.

     _R_o_w  input  (iinntt)
          Row  index for element. _R_o_w must be in the range [0.._S_i_z_e] unless
          either the TRANSLATE or EXPANDABLE compiler flags are  set  true.
          In  either  case  _R_o_w must not be negative though it may be zero.
          If zero then the element is not entered into the matrix,  but  is
          otherwise treated normally.

     _C_o_l  input  (iinntt)
          Column  index  for  element.  _C_o_l  must be in the range [0.._S_i_z_e]
          unless either the TRANSLATE or EXPANDABLE compiler flags are  set
          true.   In  either case _C_o_l must not be negative though it may be
          zero.  If zero then the element is not entered into  the  matrix,
          but is otherwise treated normally.

+o Possible errors:
     spNO_MEMORY
     Error is not cleared in this routine.

____________________________________________________________



















                            -28-


____________________________________________________________

44..1166::  ssppGGeettIInniittIInnffoo(())

With  the INITIALIZE compiler option enabled _S_p_a_r_s_e allows the user to keep
initialization information with each structurally nonzero  matrix  element.
Each  element has a pointer (referred to as _p_I_n_i_t_I_n_f_o) that is set and used
by the user.  This routine returns _p_I_n_i_t_I_n_f_o from a particular matrix  ele-
ment.
cchhaarr **_s_p_G_e_t_I_n_i_t_I_n_f_o_( _p_E_l_e_m_e_n_t _)

+o Returned:
     The user installed pointer _p_I_n_i_t_I_n_f_o.

+o Argument:

     _p_E_l_e_m_e_n_t  input  (spREAL **)
          Pointer to the element to which _p_I_n_i_t_I_n_f_o is attached.

+o Compiler options that must be set for this routine to exist:
     INITIALIZE

____________________________________________________________








































                            -29-


____________________________________________________________

44..1177::  ssppGGeettOOnneess(())

Performs  a  similar  function  to  _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_)  except that the four
reserved matrix elements are assumed to be  structural  ones  generated  by
components without admittance representations during a modified nodal anal-
ysis.  Positive ones are placed at [_P_o_s_,_E_q_n]  and  [_E_q_n_,_P_o_s]  and  negative
ones  are placed at [_N_e_g_,_E_q_n] and [_E_q_n_,_N_e_g].  This function returns a group
of pointers to the four elements through  _T_e_m_p_l_a_t_e,  which  is  an  output.
They  are  used  by the _s_p_A_D_D___Q_U_A_D_(_) macros to add the ones directly to the
matrix elements during subsequent loads of the  matrix.   This  routine  is
only  to  be used before _s_p_M_N_A___P_r_e_o_r_d_e_r_(_), _s_p_F_a_c_t_o_r_(_) or _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)
unless the compiler flag TRANSLATE is set true.
iinntt _s_p_G_e_t_O_n_e_s_( _M_a_t_r_i_x_, _P_o_s_, _N_e_g_, _E_q_n_, _T_e_m_p_l_a_t_e _)

+o Returned:
     The error code is returned.  Possible errors are listed below.   _s_p_G_e_-
     _t_O_n_e_s_(_)  does  not  clear the error state, so it is possible to ignore
     the return code of each _s_p_G_e_t_O_n_e_s_(_) call, and check for  errors  after
     constructing the whole matrix by calling _s_p_E_r_r_o_r_(_).

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix that ones are to be entered in.

     _P_o_s  input  (iinntt)
          Number  of  positive  node.   Must  be  in the range of [0.._S_i_z_e]
          unless either the options EXPANDABLE or TRANSLATE are used.  Zero
          is the ground row.  In no case may _P_o_s be less than zero.

     _N_e_g input  (iinntt)
          Number  of  negative  node.   Must  be  in the range of [0.._S_i_z_e]
          unless either the options EXPANDABLE or TRANSLATE are used.  Zero
          is the ground row.  In no case may _N_e_g be less than zero.

     _E_q_n input  (iinntt)
          Row  that  contains the branch equation.  Must be in the range of
          [1.._S_i_z_e] unless either the options EXPANDABLE or  TRANSLATE  are
          used. In no case may _E_q_n be less than one.

     _T_e_m_p_l_a_t_e  output  (ssttrruucctt _s_p_T_e_m_p_l_a_t_e **)
          Collection  of  pointers  to four elements that are later used to
          directly address elements.  User must supply the  template,  this
          routine will fill it.

+o Possible errors:
     spNO_MEMORY
     Error is not cleared in this routine.

+o Compiler options that must be set for this routine to exist:
     QUAD_ELEMENT










                            -30-


____________________________________________________________






























































                            -31-


____________________________________________________________

44..1188::  ssppGGeettQQuuaadd(())

Similar  to  _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_),  except that _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_) only handles
2-terminal components, whereas _s_p_G_e_t_Q_u_a_d_(_) handles  simple  4-terminals  as
well.  These 4-terminals are simply generalized 2-terminals with the option
of having the sense terminals different from the source and sink terminals.
_s_p_G_e_t_Q_u_a_d_(_) installs four elements into the matrix and returns their point-
ers in the _T_e_m_p_l_a_t_e structure,  which  is  an  output.   The  pointers  are
arranged  in  _T_e_m_p_l_a_t_e  such  that  when  passed to one of the _s_p_A_D_D___Q_U_A_D_(_)
macros along with an admittance, the admittance will be added to  the  ele-
ments  at  [_R_o_w_1_,_C_o_l_1]  and [_R_o_w_2_,_C_o_l_2] and subtracted from the elements at
[_R_o_w_1_,_C_o_l_2] and [_R_o_w_2_,_C_o_l_1].  The routine works fine if any of the rows and
columns are zero.  This routine is only to be used before _s_p_M_N_A___P_r_e_o_r_d_e_r_(_),
_s_p_F_a_c_t_o_r_(_) or _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) unless TRANSLATE is set true.
iinntt _s_p_G_e_t_Q_u_a_d_( _M_a_t_r_i_x_, _R_o_w_1_, _R_o_w_2_, _C_o_l_1_, _C_o_l_2_, _T_e_m_p_l_a_t_e _)

+o Returned:
     The error  code  is  returned.   Possible  errors  are  listed  below.
     _s_p_G_e_t_Q_u_a_d_(_)  does  not  clear  the  error  state, so it is possible to
     ignore the return code of each _s_p_G_e_t_Q_u_a_d_(_) call, and check for  errors
     after constructing the whole matrix by calling _s_p_E_r_r_o_r_(_).

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix that quad is to be entered in.

     _R_o_w_1  input  (iinntt)
          First  row  index  for  the  elements.  _R_o_w_1 must be in the range
          [0.._S_i_z_e] unless either  the  TRANSLATE  or  EXPANDABLE  compiler
          flags are set true.  In either case _R_o_w_1 must not be negative.

     _R_o_w_2  input  (iinntt)
          Second  row  index  for  the elements.  _R_o_w_2 must be in the range
          [0.._S_i_z_e] unless either  the  TRANSLATE  or  EXPANDABLE  compiler
          flags are set true.  In either case _R_o_w_2 must not be negative.

     _C_o_l_1  input  (iinntt)
          First  column  index for the elements.  _C_o_l_1 must be in the range
          [0.._S_i_z_e] unless either  the  TRANSLATE  or  EXPANDABLE  compiler
          flags are set true.  In either case _C_o_l_1 must not be negative.

     _C_o_l_2  input  (iinntt)
          Second  column index for the elements.  _C_o_l_2 must be in the range
          [0.._S_i_z_e] unless either  the  TRANSLATE  or  EXPANDABLE  compiler
          flags are set true.  In either case _C_o_l_2 must not be negative.

     _T_e_m_p_l_a_t_e  output  (ssttrruucctt _s_p_T_e_m_p_l_a_t_e **)
          Collection  of  pointers  to four elements that are later used to
          directly address elements.  User must supply the  template,  this
          routine will fill it.










                            -32-


+o Possible errors:
     spNO_MEMORY
     Error is not cleared in this routine.

+o Compiler options that must be set for this routine to exist:
     QUAD_ELEMENT

____________________________________________________________
____________________________________________________________

44..1199::  ssppGGeettSSiizzee(())

Returns the size of the matrix, either the internal or external size of the
matrix is returned.  The internal size is the actual  number  of  rows  and
columns  in  the  matrix.  The external size is equal to the largest row or
column number.  These numbers will be the same unless the TRANSLATE  option
is enabled.
iinntt _s_p_G_e_t_S_i_z_e_( _M_a_t_r_i_x_, _E_x_t_e_r_n_a_l _)

+o Returned:
     The size of the matrix.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix for which the size is desired.

     _E_x_t_e_r_n_a_l  input  (iinntt)
          If  _E_x_t_e_r_n_a_l  is  nonzero,  the  external  size  of the matrix is
          returned, otherwise the internal size of the matrix is  returned.

____________________________________________________________































                            -33-


____________________________________________________________

44..2200::  ssppIInniittiiaalliizzee(())

_s_p_I_n_i_t_i_a_l_i_z_e_(_) is a user customizable way to initialize the matrix.  Passed
to this routine is a function pointer.  _s_p_I_n_i_t_i_a_l_i_z_e_(_) sweeps through every
element  in  the matrix and checks the _p_I_n_i_t_I_n_f_o pointer (the user supplied
pointer).  If the _p_I_n_i_t_I_n_f_o is NULL, which is true unless the user  changes
it  (always true for fill-ins), then the element is zeroed.  Otherwise, the
function pointer is called and passed the _p_I_n_i_t_I_n_f_o pointer as well as  the
element  pointer  and the external row and column numbers allowing the user
to set the value of each element and perhaps the right-hand side vector.

The user function (_p_I_n_i_t_(_)) is expected to  return  a  nonzero  integer  if
there  is  a  fatal  error and zero otherwise.  Upon encountering a nonzero
return code, _s_p_I_n_i_t_i_a_l_i_z_e_(_) terminates and returns the error code.

The _S_p_a_r_s_e error state is cleared to spOKAY in this routine.
iinntt _s_p_I_n_i_t_i_a_l_i_z_e_( _M_a_t_r_i_x_, _p_I_n_i_t _)

+o Returns:
     The error code returned by _p_I_n_i_t.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix that is to be initialized.

     _p_I_n_i_t  input  (((**iinntt))(()))
          Pointer to a function that, given a  pointer  to  an  element,  a
          pointer  to  the  users  data structure containing initialization
          information for that element, and the row and  column  number  of
          the element, initializes it.


iinntt _p_I_n_i_t_( _p_E_l_e_m_e_n_t_, _p_I_n_i_t_I_n_f_o_, _R_o_w_, _C_o_l _)

+o Returns:
     Nonzero if fatal error, zero otherwise.

+o Arguments:

     _p_E_l_e_m_e_n_t  input  (spREAL **)
          The pointer to the real portion of the element.  The real portion
          can be accessed using either _*_p_E_l_e_m_e_n_t or _p_E_l_e_m_e_n_t_[_0_].  The imag-
          inary portion can be accessed using either _*_(_p_E_l_e_m_e_n_t_+_1_) or _p_E_l_e_-
          _m_e_n_t_[_1_].

     _p_I_n_i_t_I_n_f_o  input  (cchhaarr **)
          The user-installed pointer to the initialization data  structure.

     _R_o_w  input  (iinntt)
          The external row number of the element.










                            -34-


     _C_o_l  input  (iinntt)
          The external column number of the element.

+o Compiler options that must be set for this routine to exist:
     INITIALIZE

____________________________________________________________
____________________________________________________________

44..2211::  ssppIInnssttaallllIInniittIInnffoo(())

With  the INITIALIZE compiler option enabled _S_p_a_r_s_e allows the user to keep
initialization information with each structurally nonzero  matrix  element.
Each  element has a pointer (referred to as _p_I_n_i_t_I_n_f_o) that is set and used
by the user.  This routine installs the pointer _p_I_n_i_t_I_n_f_o into a particular
matrix element.
vvooiidd _s_p_I_n_s_t_a_l_l_I_n_i_t_I_n_f_o_( _p_E_l_e_m_e_n_t_, _p_I_n_i_t_I_n_f_o _)

+o Arguments:

     _p_E_l_e_m_e_n_t  input  (spREAL **)
          Pointer to the element to which _p_I_n_i_t_I_n_f_o is to be attached.

     _p_I_n_i_t_I_n_f_o  input  (cchhaarr **)
          The pointer _p_I_n_i_t_I_n_f_o.

+o Compiler options that must be set for this routine to exist:
     INITIALIZE

____________________________________________________________

































                            -35-


____________________________________________________________

44..2222::  ssppLLaarrggeessttEElleemmeenntt(())

If  this  routine  is  called before the matrix is factored, it returns the
absolute value of the largest element in the matrix.  If called  after  the
matrix has been factored, it returns a lower bound on the absolute value of
the largest element that occurred in any of the reduced submatrices  during
the factorization.  The ratio of these two numbers (factored/unfactored) is
the growth, which can be used to determine if the pivoting  order  is  ade-
quate.  A large growth implies that considerable error has been made in the
factorization and that it is probably a good idea to  reorder  the  matrix.
If  a  large  growth in encountered after using _s_p_F_a_c_t_o_r_(_), reconstruct the
matrix and refactor using _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).  If a large growth is encoun-
tered  after  using  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_),  refactor using _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)
with the pivot threshold increased, say to 0.1.
spREAL _s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_( _M_a_t_r_i_x _)

+o Returns:
     If matrix is unfactored, returns the magnitude of the largest  element
     in the matrix.  If the matrix is factored, a bound on the magnitude of
     the largest element in any of the reduced submatrices is returned.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix.

+o Compiler options that must be set for this routine to exist:
     STABILITY

____________________________________________________________































                            -36-


____________________________________________________________

44..2233::  ssppMMNNAA__PPrreeoorrddeerr(())

This routine massages modified node admittance matrices to improve the per-
formance  of  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).  It tries to remove structural zeros from
the diagonal by exploiting the fact that the row and column associated with
a  zero  diagonal  usually  have structural ones placed symmetrically.  For
this routine to work, the structural ones must be exactly equal  to  either
one  or  negative  one.   This routine should be used only on modified node
admittance matrices and must be executed after the matrix  has  been  built
but  before  _s_p_S_c_a_l_e_(_),  _s_p_N_o_r_m_(_), _s_p_M_u_l_t_i_p_l_y_(_), _s_p_F_a_c_t_o_r_(_), _s_p_O_r_d_e_r_A_n_d_F_a_c_-
_t_o_r_(_) or _s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_) are executed.  It should be executed  for  the
initial factorization only.
vvooiidd _s_p_M_N_A___P_r_e_o_r_d_e_r_( _M_a_t_r_i_x _)

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)

          Pointer to the matrix to be preordered.

+o Compiler options that must be set for this routine to exist:
     MODIFIED_NODAL

____________________________________________________________





































                            -37-


____________________________________________________________

44..2244::  ssppMMuullttiippllyy(())

Multiplies _M_a_t_r_i_x by _S_o_l_u_t_i_o_n on the right to find _R_H_S.  Assumes matrix has
not been factored.  This routine can be  used as a test to see if solutions
are correct.
vvooiidd _s_p_M_u_l_t_i_p_l_y_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n _)
vvooiidd _s_p_M_u_l_t_i_p_l_y_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n_, _i_R_H_S_, _i_S_o_l_u_t_i_o_n _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix.

     _R_H_S  output  (spREAL[])
          _R_H_S  is the right hand side vector.  This is what is being solved
          for.  _R_H_S contains only the real portion of the  right-hand  side
          if spSEPARATED_COMPLEX_VECTORS is set true.

     _S_o_l_u_t_i_o_n  input  (spREAL[])
          _S_o_l_u_t_i_o_n  is the vector being multiplied by the matrix.  _S_o_l_u_t_i_o_n
          contains only the real portion of that vector if spSEPARATED_COM-
          PLEX_VECTORS is set true.

     _i_R_H_S  output  (spREAL[])
          _i_R_H_S  is  the  imaginary  portion of the right hand side. This is
          what is being solved for.  It is only necessary to supply _i_R_H_S if
          the  matrix  is  complex  and  spSEPARATED_COMPLEX_VECTORS is set
          true.

     _i_S_o_l_u_t_i_o_n  input  (spREAL[])
          _i_S_o_l_u_t_i_o_n is the imaginary portion of the vector being multiplied
          by the matrix.  It is only necessary to supply _i_R_H_S if the matrix
          is complex and spSEPARATED_COMPLEX_VECTORS is set true.

+o Compiler options that must be set for this routine to exist:
     MULTIPLICATION

____________________________________________________________























                            -38-


____________________________________________________________

44..2255::  ssppMMuullttTTrraannssppoosseedd(())

Multiplies transposed _M_a_t_r_i_x by _S_o_l_u_t_i_o_n on the right to find _R_H_S.  Assumes
matrix has not been factored.  This routine can be used as a test to see if
solutions are correct.
vvooiidd _s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n _)
vvooiidd _s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n_, _i_R_H_S_, _i_S_o_l_u_t_i_o_n _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix.

     _R_H_S  output  (spREAL[])
          _R_H_S is the right hand side vector.  This is what is being  solved
          for.   _R_H_S  contains only the real portion of the right-hand side
          if spSEPARATED_COMPLEX_VECTORS is set true.

     _S_o_l_u_t_i_o_n  input  (spREAL[])
          _S_o_l_u_t_i_o_n is the vector being multiplied by the matrix.   _S_o_l_u_t_i_o_n
          contains only the real portion of that vector if spSEPARATED_COM-
          PLEX_VECTORS is set true.

     _i_R_H_S  output  (spREAL[])
          _i_R_H_S is the imaginary portion of the right  hand  side.  This  is
          what is being solved for.  It is only necessary to supply _i_R_H_S if
          the matrix is  complex  and  spSEPARATED_COMPLEX_VECTORS  is  set
          true.

     _i_S_o_l_u_t_i_o_n  input  (spREAL[])
          _i_S_o_l_u_t_i_o_n is the imaginary portion of the vector being multiplied
          by the matrix.  It is only necessary to supply _i_R_H_S if the matrix
          is complex and spSEPARATED_COMPLEX_VECTORS is set true.

+o Compiler options that must be set for this routine to exist:
     MULTIPLICATION
     TRANSPOSE

____________________________________________________________






















                            -39-


____________________________________________________________

44..2266::  ssppNNoorrmm(())

Computes  and  returns  the  L-infinity norm of an unfactored matrix.  This
number is used in computing the condition number of the matrix.   It  is  a
fatal error to pass this routine a factored matrix.
spREAL _s_p_N_o_r_m_( _M_a_t_r_i_x _)

+o Returns:
     The largest absolute row sum (the L-infinity norm) of the matrix.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix.

+o Compiler options that must be set for this routine to exist:
     CONDITION

____________________________________________________________
____________________________________________________________

44..2277::  ssppOOrrddeerrAAnnddFFaaccttoorr(())

This  routine  chooses  a pivot order for the matrix and factors it into LU
form.  It handles both the initial factorization and subsequent  factoriza-
tions  when a reordering or threshold pivoting is desired.  This is handled
in a manner that is transparent to the user.
iinntt _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_( _M_a_t_r_i_x_, _R_H_S_, _T_h_r_e_s_h_o_l_d_, _A_b_s_o_l_u_t_e_T_h_r_e_s_h_o_l_d_, _D_i_a_g_P_i_v_o_t_-
_i_n_g _)

+o Returned:
     The error code is returned.  Possible errors are listed below.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix to be factored.

     _R_H_S  input  (spREAL[])
          Representative  _R_H_S  vector  that  is  used to determine pivoting
          order when the right-hand side vector is sparse.  If  a  term  in
          _R_H_S  is  zero,  it is assumed that it will usually be zero.  Con-
          versely, a nonzero term in _R_H_S indicates that the term will often
          be  nonzero.   If  _R_H_S is a NULL pointer then the right-hand side
          vector is assumed to be full and it is not used when  determining
          the pivoting order.

     _T_h_r_e_s_h_o_l_d  input  (spREAL)
          This  is  the  pivot  threshold, which should be between zero and
          one.  If it is one then the pivoting method becomes complete piv-
          oting, which is very slow and tends to fill up the matrix.  If it
          is set close to zero the pivoting method becomes strict Markowitz









                            -40-


          with  no  threshold.   The  pivot  threshold is used to eliminate
          pivot candidates that would cause  excessive  element  growth  if
          they  were  used.  Element growth is the cause of roundoff error,
          which can occur even in well-conditioned matrices.   Setting  the
          threshold  large  will  reduce element growth and roundoff error,
          but setting it too large will cause execution time to  be  exces-
          sive  and  will  result  in  a large number of fill-ins.  If this
          occurs, accuracy can actually be degraded because  of  the  large
          number of operations required on the matrix due to the large num-
          ber of fill-ins.  A good value for diagonal pivoting seems to  be
          0.001 while a good value for complete pivoting appears to be 0.1.
          The default is chosen by giving a value larger than one  or  less
          than  or  equal  to  zero.   Once the pivot threshold is set, the
          value becomes the new default for later calls  to  _s_p_O_r_d_e_r_A_n_d_F_a_c_-
          _t_o_r.   The threshold value should be increased and the matrix re-
          solved if growth is found to be excessive.   Changing  the  pivot
          threshold  does  not improve performance on matrices where growth
          is low, as is often the case with ill-conditioned matrices.   The
          default value of _T_h_r_e_s_h_o_l_d was choosen for use with nearly diago-
          nally dominant matrices such as node-  and  modified-node  admit-
          tance  matrices.   For  these  matrices it is usually best to use
          diagonal pivoting.  For matrices without a strong diagonal, it is
          usually best to use a larger threshold, such as 0.01 or 0.1.

     _A_b_s_o_l_u_t_e_T_h_r_e_s_h_o_l_d  input  (spREAL)
          The absolute magnitude an element must have to be considered as a
          pivot candidate, except as a last resort.  This number should  be
          set significantly smaller than the smallest diagonal element that
          is is expected to be placed in the matrix.  If there is  no  rea-
          sonable  prediction  for  the lower bound on these elements, then
          _A_b_s_o_l_u_t_e_T_h_r_e_s_h_o_l_d should be set to  zero.   _A_b_s_o_l_u_t_e_T_h_r_e_s_h_o_l_d  is
          used  to reduce the possibility of choosing as a pivot an element
          that has suffered heavy cancellation and as a result mainly  con-
          sists  of  roundoff error.  Note that if _A_b_s_o_l_u_t_e_T_h_r_e_s_h_o_l_d is set
          too large, it could drastically increase  the  time  required  to
          factor and solve the matrix.  _A_b_s_o_l_u_t_e_T_h_r_e_s_h_o_l_d should be nonneg-
          ative.  If  no  element  in  the  matrix  is  larger  than  _A_b_s_o_-
          _l_u_t_e_T_h_r_e_s_h_o_l_d, the warning spILL_CONDITIONED is returned.

     _D_i_a_g_P_i_v_o_t_i_n_g  input  (int)
          A  flag indicating that pivot selection should be confined to the
          diagonal if possible.  If _D_i_a_g_P_i_v_o_t_i_n_g is nonzero and  if  DIAGO-
          NAL_PIVOTING is enabled pivots will be chosen only from the diag-
          onal unless there are  no  diagonal  elements  that  satisfy  the
          threshold  criteria.   Otherwise, the entire reduced submatrix is
          searched when looking for a  pivot.   The  diagonal  pivoting  in
          _S_p_a_r_s_e is efficient and well refined, while the complete pivoting
          is not.  For symmetric and near symmetric matrices, it is best to
          use  diagonal pivoting because it results in the best performance
          when reordering the matrix and when factoring the matrix  without
          ordering.   If  there  is a considerable amount of nonsymmetry in
          the matrix, then complete pivoting may result in a  better  equa-
          tion  ordering  simply because there are more pivot candidates to
          choose from.  A better  ordering  results  in  faster  subsequent









                            -41-


          factorizations.   However,  the  initial  pivot selection process
          takes considerably longer for complete pivoting.

+o Possible errors:
     spNO_MEMORY
     spSINGULAR
     spILL_CONDITIONED

____________________________________________________________
____________________________________________________________

44..2288::  ssppPPaarrttiittiioonn(())

This routine determines the cost to factor each row using both  direct  and
indirect  addressing  and  decides, on a row-by-row basis, which addressing
mode is fastest.  This information is used in _s_p_F_a_c_t_o_r_(_) to speed the  fac-
torization.

When factoring a previously ordered matrix using _s_p_F_a_c_t_o_r_(_), fISparse oper-
ates on a row-at-a-time basis.  For speed, on  each  step,  the  row  being
updated  is  copied  into a full vector and the operations are performed on
that vector.  This can be  done  one  of  two  ways,  either  using  direct
addressing  or  indirect addressing.  Direct addressing is fastest when the
matrix is relatively dense and indirect addressing is best when the  matrix
is  quite  sparse.   The user selects the type of partition used with _M_o_d_e.
If _M_o_d_e is set to spDIRECT_PARTITION, then the all rows are placed  in  the
direct  addressing partition.  Similarly, if _M_o_d_e is set to spINDIRECT_PAR-
TITION, then the all rows are placed in the indirect addressing  partition.
By  setting  _M_o_d_e to spAUTO_PARTITION, the user allows _S_p_a_r_s_e to select the
partition for each row individually.  _s_p_F_a_c_t_o_r_(_) generally runs  faster  if
_S_p_a_r_s_e is allowed to choose its own partitioning, however choosing a parti-
tion is expensive.  The time required to choose a partition is of the  same
order of the cost to factor the matrix.  If you plan to factor a large num-
ber of matrices with the same structure, it is best to  let  _S_p_a_r_s_e  choose
the  partition.   Otherwise,  you  should choose the partition based on the
predicted density of the matrix.  By default  (i.e.,  if  _s_p_P_a_r_t_i_t_i_o_n_(_)  is
never called), _S_p_a_r_s_e chooses the partition for each row individually.
vvooiidd _s_p_P_a_r_t_i_t_i_o_n_( _M_a_t_r_i_x_, _M_o_d_e _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix to be partitioned.

     _M_o_d_e  input  (iinntt)
          Mode  must  be  one  of  three special codes: spDIRECT_PARTITION,
          spINDIRECT_PARTITION, or spAUTO_PARTITION.

____________________________________________________________














                            -42-


____________________________________________________________

44..2299::  ssppPPrriinntt(())

Formats and send the matrix to standard output.  Some elementary statistics
are also output.  The matrix is output in a format that is readable by peo-
ple.  This routine should not be used on large matrices.
vvooiidd _s_p_P_r_i_n_t_( _M_a_t_r_i_x_, _P_r_i_n_t_R_e_o_r_d_e_r_e_d_, _D_a_t_a_, _H_e_a_d_e_r _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix to be printed.

     _P_r_i_n_t_R_e_o_r_d_e_r_e_d  input  (iinntt)
          Indicates whether the matrix should be printed out in its  origi-
          nal  form,  as input by the user, or whether it should be printed
          in its reordered form, as used internally by the matrix routines.
          A  zero indicates that the matrix should be printed as inputed, a
          one indicates that it should be printed reordered.

     _D_a_t_a  input  (iinntt)
          Boolean flag that when false indicates that output should be com-
          pressed  such  that  only  the  existence of an element should be
          indicated rather than giving the actual value.  Thus 10 times  as
          many elements can be printed on a row.  A zero indicates that the
          matrix should be printed compressed.  A one  signifies  that  the
          matrix should be printed in all its glory.

     _H_e_a_d_e_r  input  (iinntt)
          A  flag indicating that extra information should be printed, such
          as row and column numbers.

+o Compiler options that must be set for this routine to exist:
     DOCUMENTATION

____________________________________________________________


























                            -43-


____________________________________________________________

44..3300::  ssppPPsseeuuddooCCoonnddiittiioonn(())

Computes the magnitude of the ratio of the largest to the smallest  pivots.
This  quantity  is an indicator of ill-conditioning in the matrix.  If this
ratio is large, and if the matrix is scaled such that uncertainties in  the
right-hand  side  vector  and the matrix entries are equilibrated, then the
matrix is ill-conditioned.  However, a small  ratio  does  not  necessarily
imply  that the matrix is well-conditioned.  This routine must only be used
after a matrix has been factored by _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)  or  _s_p_F_a_c_t_o_r_(_)  and
before  it  is cleared by _s_p_C_l_e_a_r_(_) or _s_p_I_n_i_t_i_a_l_i_z_e_(_).  The pseudocondition
is faster to compute than the condition number calculated by _s_p_C_o_n_d_i_t_i_o_n_(_),
but is not as informative.
spREAL  _s_p_P_s_e_u_d_o_C_o_n_d_i_t_i_o_n_( _M_a_t_r_i_x _)

+o Returns:
     The  magnitude of the ratio of the largest to smallest pivot used dur-
     ing previous factorization.  If  the  matrix  was  singular,  zero  is
     returned.

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix.

+o Compiler options that must be set for this routine to exist:
     PSEUDOCONDITION

____________________________________________________________

































                            -44-


____________________________________________________________

44..3311::  ssppRRoouunnddooffff(())

Returns a bound on the magnitude of the largest element in $bold E ~=~ bold
A - bold LU$, where $bold E$ represents error in the matrix resulting  from
roundoff during the factorization.
spREAL  _s_p_R_o_u_n_d_o_f_f_( _M_a_t_r_i_x_, _R_h_o _)

+o Returns:
     Returns a bound on the magnitude of the largest element in $bold E ~=~
     bold A - bold LU$.

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix.  Matrix must be factored.

     _R_h_o  input  (spREAL)
          The bound on the magnitude of the largest element in any  of  the
          reduced submatrices.  This is the number computed by the function
          _s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_) when given a factored matrix.  If this  number
          is negative, the bound will be computed automatically.

+o Compiler options that must be set for this routine to exist:
     STABILITY

____________________________________________________________



































                            -45-


____________________________________________________________

44..3322::  ssppSSccaallee(())

This  function  scales  the  matrix to enhance the possibility of finding a
good pivoting order.  Note that scaling enhances accuracy of  the  solution
only  if it affects the pivoting order, so it only makes sense to scale the
matrix before _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).  There are several things  to  take  into
account  when  choosing  the  scale  factors.  First, the scale factors are
directly multiplied times the elements in the matrix.  To prevent roundoff,
each scale factor should be equal to an integer power of the number base of
the machine.  Since most machines operate in base two, scale factors should
be  a  power  of  two.   Second,  the matrix should be scaled such that the
matrix of element uncertainties is equilibrated.  Third, this function mul-
tiplies  the  scale factors times the elements, so if one row tends to have
uncertainties 1000 times smaller than the other rows, then its scale factor
should  be  1024, not 1/1024.  Fourth, to save time, this function does not
scale rows or columns if their scale factors are equal to one.   Thus,  the
scale  factors  should be normalized to the most common scale factor.  Rows
and columns should be normalized separately.  For example, if the  size  of
the  matrix is 100 and 10 rows tend to have uncertainties near 1e-6 and the
remaining 90 have uncertainties near 1e-12, then the scale factor  for  the
10  should be 1/1,048,576 and the scale factors for the remaining 90 should
be 1. Fifth, since this routine directly operates on the matrix, it is nec-
essary  to apply the scale factors to the _R_H_S and _S_o_l_u_t_i_o_n vectors.  It may
be easier to simply use _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) on a scaled matrix to choose the
pivoting order, and then throw away the matrix.  Subsequent factorizations,
performed with _s_p_F_a_c_t_o_r_(_), will not need to have the _R_H_S and _S_o_l_u_t_i_o_n  vec-
tors descaled.
vvooiidd _s_p_S_c_a_l_e_( _M_a_t_r_i_x_, _R_H_S___S_c_a_l_e_F_a_c_t_o_r_s_, _S_o_l_u_t_i_o_n_S_c_a_l_e_F_a_c_t_o_r_s _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to the matrix to be scaled.

     _R_H_S___S_c_a_l_e_F_a_c_t_o_r_s  input  (spREAL[])
          The  array  of  RHS scale factors.  These factors scale the rows.
          All scale factors are real-valued.

     _S_o_l_u_t_i_o_n_S_c_a_l_e_F_a_c_t_o_r_s  input  (spREAL[])
          The array of Solution scale factors.   These  factors  scale  the
          columns.  All scale factors are real-valued.

+o Compiler options that must be set for this routine to exist:
     SCALING

____________________________________________________________















                            -46-


____________________________________________________________

44..3333::  ssppSSeettCCoommpplleexx(())

The  type  of the matrix may then be toggled back and forth between complex
and real.  This function changes the type of matrix to  complex.   For  the
matrix to be set complex, the compiler option spCOMPLEX must be set true.
vvooiidd _s_p_S_e_t_C_o_m_p_l_e_x_( _M_a_t_r_i_x _)

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)

          The matrix that is to be to be complex.

____________________________________________________________
____________________________________________________________

44..3344::  ssppSSeettRReeaall(())

The  type  of the matrix may then be toggled back and forth between complex
and real.  This function changes the type  of  matrix  to  real.   For  the
matrix to be set real, the compiler option REAL must be set true.
vvooiidd _s_p_S_e_t_R_e_a_l_( _M_a_t_r_i_x _)

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          The matrix that is to be real.

____________________________________________________________
































                            -47-


____________________________________________________________

44..3355::  ssppSSoollvvee(())

Performs  the forward and backward elimination to find the unknown _S_o_l_u_t_i_o_n
vector from _R_H_S and the factored matrix.
vvooiidd _s_p_S_o_l_v_e_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n _)
vvooiidd _s_p_S_o_l_v_e_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n_, _i_R_H_S_, _i_S_o_l_u_t_i_o_n _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix.

     _R_H_S  input  (spREAL[])
          _R_H_S is the input data array, the  right-hand  side  vector.   _R_H_S
          contains  only  the real portion of the right-hand side vector if
          spSEPARATED_COMPLEX_VECTORS is set true.  _R_H_S is undisturbed  and
          may be reused for other solves.

     _S_o_l_u_t_i_o_n  output  (spREAL[])
          _S_o_l_u_t_i_o_n  is the output data array, the unknown vector. This rou-
          tine is constructed such that _R_H_S and _S_o_l_u_t_i_o_n can  be  the  same
          array.   _S_o_l_u_t_i_o_n  contains  only the real portion of the unknown
          vector if spSEPARATED_COMPLEX_VECTORS is set true.

     _i_R_H_S  input  (spREAL[])
          _i_R_H_S is the imaginary portion of the input data array, the right-
          hand  side vector. This data is undisturbed and may be reused for
          other solves.  This argument is unnecessary if the matrix is real
          or spSEPARATED_COMPLEX_VECTORS is set false.

     _i_S_o_l_u_t_i_o_n  output  (spREAL[])
          _i_S_o_l_u_t_i_o_n  is  the  imaginary  portion  of the output data array.
          This routine is constructed such that _i_R_H_S and _i_S_o_l_u_t_i_o_n  can  be
          the  same  array.   This argument is unnecessary if the matrix is
          real or spSEPARATED_COMPLEX_VECTORS is set false.

____________________________________________________________
























                            -48-


____________________________________________________________

44..3366::  ssppSSoollvveeTTrraannssppoosseedd(())

Performs the forward and backward elimination to find the unknown  _S_o_l_u_t_i_o_n
vector  from _R_H_S and the transposed factored matrix. This routine is useful
when performing sensitivity analysis on a circuit using the adjoint method.
vvooiidd _s_p_S_o_l_v_e_T_r_a_n_s_p_o_s_e_d_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n _)
vvooiidd _s_p_S_o_l_v_e_T_r_a_n_s_p_o_s_e_d_( _M_a_t_r_i_x_, _R_H_S_, _S_o_l_u_t_i_o_n_, _i_R_H_S_, _i_S_o_l_u_t_i_o_n _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix.

     _R_H_S  input  (spREAL[])
          _R_H_S  is  the  input  data array, the right-hand side vector.  _R_H_S
          contains only the real portion of the right-hand side  vector  if
          spSEPARATED_COMPLEX_VECTORS  is set true.  _R_H_S is undisturbed and
          may be reused for other solves.

     _S_o_l_u_t_i_o_n  output  (spREAL[])
          _S_o_l_u_t_i_o_n is the output data array, the unknown vector. This  rou-
          tine  is  constructed  such that _R_H_S and _S_o_l_u_t_i_o_n can be the same
          array.  _S_o_l_u_t_i_o_n contains only the real portion  of  the  unknown
          vector if spSEPARATED_COMPLEX_VECTORS is set true.

     _i_R_H_S  input  (spREAL[])
          _i_R_H_S is the imaginary portion of the input data array, the right-
          hand side vector. This data is undisturbed and may be reused  for
          other  solves.   This  parameter  is unnecessary if the matrix is
          real or spSEPARATED_COMPLEX_VECTORS is set false.

     _i_S_o_l_u_t_i_o_n  output  (spREAL[])
          _i_S_o_l_u_t_i_o_n is the imaginary portion  of  the  output  data  array.
          This  routine  is constructed such that _i_R_H_S and _i_S_o_l_u_t_i_o_n can be
          the same array.  This parameter is unnecessary if the  matrix  is
          real or spSEPARATED_COMPLEX_VECTORS is set false.

+o Compiler options that must be set for this routine to exist:
     TRANSPOSE

____________________________________________________________




















                            -49-


____________________________________________________________

44..3377::  ssppSSttrriippFFiillllss(())

_s_p_S_t_r_i_p_F_i_l_l_s_(_)  strips  all  accumulated  fill-ins  from a matrix.  This is
often a useful thing to do before reordering a matrix to help  insure  that
subsequent factorizations will be as efficient as possible.
vvooiidd _s_p_S_t_r_i_p_F_i_l_l_s_( _M_a_t_r_i_x _)

+o Argument:

     _M_a_t_r_i_x  input  (cchhaarr **)
          The matrix to be stripped.

+o Compiler options that must be set for this routine to exist:
     STRIP

____________________________________________________________
____________________________________________________________

44..3388::  ssppWWhheerreeSSiinngguullaarr(())

This  function  returns  the  row  and  column  number where the matrix was
detected as singular or where a zero pivot was found.
vvooiidd _s_p_W_h_e_r_e_S_i_n_g_u_l_a_r_( _M_a_t_r_i_x_, _R_o_w_, _C_o_l _)

+o Arguments:

     _M_a_t_r_i_x  input  (cchhaarr **)
          Pointer to matrix.

     _R_o_w  output  (iinntt **)
          The row number.

     _R_o_w  output  (iinntt **)
          The column number.

____________________________________________________________

























                            -50-


55::  MMAACCRROO FFUUNNCCTTIIOONNSS These macro functions are used to  quickly  enter  data
into  the matrix using pointers.  These pointers are originally acquired by
the user from _s_p_G_e_t_E_l_e_m_e_n_t_(_),  _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_),  _s_p_G_e_t_Q_u_a_d_(_),  and  _s_p_G_e_-
_t_O_n_e_s_(_)  during  the initial loading of the matrix.  These macros work cor-
rectly even if the elements they are to add data to are in  row  or  column
zero.

     The  macros  reside  in  the file ssppEExxppoorrttss..hh.  To use them, this file
must be included in the file of the calling routine and that  routine  must
be written in C.
____________________________________________________________

55..11::  ssppAADDDD__RREEAALL__EELLEEMMEENNTT(())

Macro  function  that  adds  a  real value to an element in the matrix by a
pointer.
_s_p_A_D_D___R_E_A_L___E_L_E_M_E_N_T_( _p_E_l_e_m_e_n_t _, _R_e_a_l _)

+o Arguments:

     _p_E_l_e_m_e_n_t  input  (spREAL **)
          A pointer to the element to which _R_e_a_l is to be added.

     _R_e_a_l  input  (spREAL)
          The real value that is to be added to the element.

____________________________________________________________
____________________________________________________________

55..22::  ssppAADDDD__IIMMAAGG__EELLEEMMEENNTT(())

Macro function that adds a imaginary value to an element in the matrix by a
pointer.
_s_p_A_D_D___I_M_A_G___E_L_E_M_E_N_T_( _p_E_l_e_m_e_n_t _, _I_m_a_g _)

+o Arguments:

     _p_E_l_e_m_e_n_t  input  (spREAL **)
          A pointer to the element to which _I_m_a_g is to be added.

     _I_m_a_g  input  (spREAL)
          The imaginary value that is to be added to the element.

____________________________________________________________



















                            -51-


____________________________________________________________

55..33::  ssppAADDDD__CCOOMMPPLLEEXX__EELLEEMMEENNTT(())

Macro  function  that adds a complex value to an element in the matrix by a
pointer.
_s_p_A_D_D___C_O_M_P_L_E_X___E_L_E_M_E_N_T_( _p_E_l_e_m_e_n_t_, _R_e_a_l_, _I_m_a_g _)

+o Arguments:

     _p_E_l_e_m_e_n_t  input  (spREAL  **)
          A pointer to the element to which _R_e_a_l and _I_m_a_g are to be  added.

     _R_e_a_l  input  (spREAL)
          The real value that is to be added to the element.

     _I_m_a_g  input  (spREAL)
          The imaginary value that is to be added to the element.

____________________________________________________________
____________________________________________________________

55..44::  ssppAADDDD__RREEAALL__QQUUAADD(())

Macro  that  adds  a real value to the four elements specified by _T_e_m_p_l_a_t_e.
The value is added to the first two elements in  _T_e_m_p_l_a_t_e,  and  subtracted
from the last two.
_s_p_A_D_D___R_E_A_L___Q_U_A_D_( _T_e_m_p_l_a_t_e_, _R_e_a_l _)

+o Arguments:

     _T_e_m_p_l_a_t_e  input  (ssttrruucctt _s_p_T_e_m_p_l_a_t_e)
          Data structure containing the pointers to four matrix elements.

     _R_e_a_l  input  (spREAL)
          Real value to be added to the elements.

____________________________________________________________

























                            -52-


____________________________________________________________

55..55::  ssppAADDDD__IIMMAAGG__QQUUAADD(())

Macro  that  adds an imaginary value to the four elements specified by _T_e_m_-
_p_l_a_t_e.  The value is added to the first two elements in _T_e_m_p_l_a_t_e, and  sub-
tracted from the last two.
_s_p_A_D_D___I_M_A_G___Q_U_A_D_( _T_e_m_p_l_a_t_e_, _I_m_a_g _)

+o Arguments:

     _T_e_m_p_l_a_t_e  input  (ssttrruucctt _s_p_T_e_m_p_l_a_t_e)
          Data structure containing the pointers to four matrix elements.

     _I_m_a_g  input  (spREAL)
          Imaginary value to be added to the elements.

____________________________________________________________
____________________________________________________________

55..66::  ssppAADDDD__CCOOMMPPLLEEXX__QQUUAADD(())

Macro that adds a complex value to the four elements specified by _T_e_m_p_l_a_t_e.
The value is added to the first two elements in  _T_e_m_p_l_a_t_e,  and  subtracted
from the last two.
_s_p_A_D_D___C_O_M_P_L_E_X___Q_U_A_D_( _T_e_m_p_l_a_t_e_, _R_e_a_l_, _I_m_a_g _)

+o Arguments:

     _T_e_m_p_l_a_t_e  input  (ssttrruucctt _s_p_T_e_m_p_l_a_t_e)
          Data structure containing the pointers to four matrix elements.

     _R_e_a_l  input  (spREAL)
          Real value to be added to the elements.

     _I_m_a_g  input  (spREAL)
          Imaginary value to be added to the elements.

____________________________________________________________
























                            -53-


66::  CCOONNFFIIGGUURRIINNGG SSPPAARRSSEE

     _S_p_a_r_s_e  has  a extensive set of options and parameters that can be set
at compile time to alter the personality of the  program.   They  also  are
used  to  eliminate routines that are not needed so as to reduce the amount
of memory required to hold the object code.  These options  and  parameters
consist of macros definitions and are contained in the file ssppCCoonnffiigg..hh.  To
configure _S_p_a_r_s_e, ssppCCoonnffiigg..hh must be edited and then _S_p_a_r_s_e must be  recom-
piled.

     Some  terminology  should  be defined.  The Markowitz row count is the
number of non-zero elements in a row excluding the one being considered  as
pivot.  There is one Markowitz row count for every row.  The Markowitz col-
umn count is defined similarly for columns.  The Markowitz product  for  an
element is the product of its row and column counts. It is a measure of how
much work would be required on the next step of the factorization  if  that
element  were  chosen to be pivot.  A small Markowitz product is desirable.
For a more detailed explanation, see Kundert [kundert86].


66..11::  SSppaarrssee OOppttiioonnss

REAL

This specifies that the routines are expected to  handle  real  systems  of
equations.   The  routines  can be compiled to handle both real and complex
systems at the same time, but there is a slight speed and memory  advantage
if the routines are complied to handle only real systems of equations.


spCOMPLEX

This specifies that the routines will be complied to handle complex systems
of equations.


EXPANDABLE

Setting this compiler flag true makes the matrix expandable before  it  has
been  reordered.   If the matrix is expandable, then if an element is added
that would be considered out of bounds in the current matrix, the  size  of
the matrix is increased to hold that element.  As a result, the size of the
matrix need not be known before the matrix is built.   The  matrix  can  be
allocated  with  size zero and expanded.  It is possible to expand the size
of a matrix after it is been reordered if TRANSLATE and EXPANDABLE are both
set true.

















                            -54-


TRANSLATE

This  option  allows  the set of external row and column numbers to be non-
packed.  In other words, the row and column numbers need not be contiguous.
The  priced  paid  for this flexibility is that when TRANSLATE is set true,
the time required to initially build the matrix will be greater because the
external  row  and  column  number must be translated into internal equiva-
lents.  This translation brings about other benefits  though.   First,  the
_s_p_G_e_t_E_l_e_m_e_n_t_(_),  _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_),  _s_p_G_e_t_Q_u_a_d_(_),  and _s_p_G_e_t_O_n_e_s_(_) routines
may be used after the matrix has been  factored.   Further,  elements,  and
even rows and columns, may be added to the matrix, and rows and columns may
be deleted from the matrix, after it has been reordered.   Note  that  when
the  set  of row and column number is not a packed set, neither are the _R_H_S
and _S_o_l_u_t_i_o_n vectors.  Thus the size of these vectors must be at  least  as
large  as the external size, which is the value of the largest given row or
column numbers.


INITIALIZE

Causes the _s_p_I_n_i_t_i_a_l_i_z_e_(_), _s_p_G_e_t_I_n_i_t_I_n_f_o_(_),  and  _s_p_I_n_s_t_a_l_l_I_n_i_t_I_n_f_o_(_)  rou-
tines  to be compiled.  These routines allow the user to store and read one
pointer in each nonzero element in the matrix.  _s_p_I_n_i_t_i_a_l_i_z_e_(_) then calls a
user  specified  function  for  each  structural nonzero in the matrix, and
includes this pointer as well as the external row  and  column  numbers  as
arguments.  This allows the user to write custom matrix and right-hand side
vector initialization routines.


DIAGONAL_PIVOTING

Many matrices, and in particular node- and modified-node admittance  matri-
ces, tend to be nearly symmetric and nearly diagonally dominant.  For these
matrices, it is a good idea to select pivots from the diagonal.  With  this
option  enabled,  this  is  exactly what happens, though if no satisfactory
pivot can be found on the diagonal, an off-diagonal pivot will be used.  If
this  option  is disabled, _S_p_a_r_s_e does not preferentially search the diago-
nal.  Because of this, _S_p_a_r_s_e has  a  wider  variety  of  pivot  candidates
available,  and so presumably fewer fill-ins will be created.  However, the
initial pivot selection process will take considerably longer.  If  working
with node admittance matrices, or other matrices with a strong diagonal, it
is probably best to use DIAGONAL_PIVOTING for two reasons.  First, accuracy
will  be  better because pivots will be chosen from the large diagonal ele-
ments, thus reducing the chance of growth and hence, roundoff.   Second,  a
near optimal ordering will be chosen quickly.  If the class of matrices you
are working with does not have a strong diagonal, do not use  DIAGONAL_PIV-
OTING,  but  consider  using a larger threshold.  When DIAGONAL_PIVOTING is
turned off, the  following  options  and  constants  are  not  used:  MODI-
FIED_MARKOWITZ, MAX_MARKOWITZ_TIES, and TIES_MULTIPLIER.














                            -55-


ARRAY_OFFSET

This  determines  whether  arrays  start  at an index of zero or one.  This
option is necessitated by the fact that standard C convention dictates that
arrays  begin  with an index of zero but the standard mathematic convention
states that arrays begin with an index of one.  So if you prefer  to  start
your arrays with zero, or you're calling _S_p_a_r_s_e from some other programming
language, use an ARRAY_OFFSET of 0.  Otherwise, use an ARRAY_OFFSET  of  1.
Note  that  if you use an offset of one, the arrays that you pass to _S_p_a_r_s_e
must have an allocated length of one plus the external size of the  matrix.
ARRAY_OFFSET must be either 0 or 1, no other offsets are valid.


spSEPARATED_COMPLEX_VECTORS

This specifies the format for complex vectors.  If this is set false then a
complex vector is made up of one double sized array of spREALs in which the
real  and  imaginary numbers are placed alternately in the array.  In other
words,  the  first  entry  would  be  _C_o_m_p_l_e_x_[_1_]_._R_e_a_l,  then   comes   _C_o_m_-
_p_l_e_x_[_1_]_._I_m_a_g, then _C_o_m_p_l_e_x_[_2_]_._R_e_a_l, etc.  If spSEPARATED_COMPLEX_VECTORS is
set true, then each complex vector is represented by two arrays of spREALs,
one with the real terms, the other with the imaginary.


MODIFIED_MARKOWITZ

This  specifies that the modified Markowitz method of pivot selection is to
be used.  The modified Markowitz method differs from standard Markowitz  in
two  ways.   First, under modified Markowitz, the search for a pivot can be
terminated early if a adequate (in terms of sparsity)  pivot  candidate  is
found.   Thus, when using modified Markowitz, the initial factorization can
be faster, but at the expense of a suboptimal pivoting order that may  slow
subsequent  factorizations.   The  second difference is in the way modified
Markowitz breaks Markowitz ties.  When two or more elements are pivot  can-
didates  and they all have the same Markowitz product, then the tie is bro-
ken by choosing the element that is best numerically.  The numerically best
element is the one with the largest ratio of its magnitude to the magnitude
of the largest element in the same column, excluding itself.  The  modified
Markowitz method results in marginally better accuracy.


DELETE

This  specifies  that  the  _s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_) routine should be compiled.
Note that for this routine to be compiled, both DELETE and TRANSLATE should
be set true.


STRIP

This specifies that the _s_p_S_t_r_i_p_F_i_l_l_s_(_) routine should be compiled.












                            -56-


MODIFIED_NODAL

This  specifies that the _s_p_M_N_A___P_r_e_o_r_d_e_r_(_), the routine that preorders modi-
fied node admittance matrices, should be compiled.  This routine results in
greater speed and accuracy if used with this type of matrix.


QUAD_ELEMENT

This  specifies  that  the  routines that allow four related elements to be
entered into the matrix at once should be compiled.  The routines  affected
by QUAD_ELEMENT are _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_), _s_p_G_e_t_Q_u_a_d_(_), and _s_p_G_e_t_O_n_e_s_(_).


TRANSPOSE

This  specifies  that  _s_p_S_o_l_v_e_T_r_a_n_s_p_o_s_e_(_)  and  perhaps _s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_(_),
which operate on the matrix as if it was transposed, should be compiled.


SCALING

This specifies that the routine that performs scaling on the matrix  should
be  complied.  Scaling is not strongly supported.  The routine to scale the
matrix is provided, but no routines are provided to scale and  descale  the
_R_H_S  and  _S_o_l_u_t_i_o_n vectors.  It is suggested that if scaling is desired, it
only be performed when the pivot order is being chosen, which  is  done  in
_s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).   This,  and when the condition number of the matrix is
calculated with _s_p_C_o_n_d_i_t_i_o_n_(_), are the only times scaling  has  an  effect.
The scaling may then either be removed from the solution by the user or the
scaled factored matrix may simply be thrown away.


DOCUMENTATION

This specifies  that  routines  that  are  used  to  document  the  matrix,
_s_p_P_r_i_n_t_(_),  _s_p_F_i_l_e_M_a_t_r_i_x_(_),  _s_p_F_i_l_e_V_e_c_t_o_r_(_),  and  _s_p_F_i_l_e_S_t_a_t_s_(_), should be
compiled.


DETERMINANT

This specifies that the _s_p_D_e_t_e_r_m_i_n_a_n_t_(_) routine should be complied.




















                            -57-


STABILITY

This specifies that _s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_) and _s_p_R_o_u_n_d_o_f_f_(_) should be compiled.
These  routines  are  used to check the stability (and hence the quality of
the pivoting) of the factorization by computing a bound on the size of  the
element is the matrix $bold E ~=~ bold A - bold LU$.  If this bound is very
high after applying _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_), then the pivot threshold should  be
raised.   If  the  bound increases greatly after using _s_p_F_a_c_t_o_r_(_), then the
matrix should probably be reordered.


CONDITION

This specifies that _s_p_C_o_n_d_i_t_i_o_n_(_) and _s_p_N_o_r_m_(_), the code  that  computes  a
good estimate of the condition number of the matrix, should be compiled.


PSEUDOCONDITION

This specifies that _s_p_P_s_e_u_d_o_C_o_n_d_i_t_i_o_n_(_), the code that computes a crude and
easily fooled indicator of the ill-conditioning in the  matrix,  should  be
compiled.


MULTIPLICATION

This  specifies  that _s_p_M_u_l_t_i_p_l_y_(_) and perhaps _s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_(_), the rou-
tines that multiply an unfactored matrix by a vector, should be compiled.


FORTRAN

This specifies that the FORTRAN interface to Sparse1.3 should be  compiled.
The  ARRAY_OFFSET  option  should  be set to NO when interfacing to FORTRAN
programs.


DEBUG

This specifies that additional error checking should be compiled.  The type
of  errors  checked  are those that are common when the matrix routines are
first integrated into a user's program.  Once the routines have been  inte-
grated in and are running smoothly, this option should be turned off.  With
DEBUG enabled, _S_p_a_r_s_e is very defensive.  If a  _S_p_a_r_s_e  routine  is  called
improperly,  a  message will be printed describing the file and line number
where the error was found and execution is aborted.  One thing that  _S_p_a_r_s_e
is particularly picky about is calling certain functions after an error has
occurred.   If  an  error  has  occurred,  do  not  call  _s_p_M_N_A___P_r_e_o_r_d_e_r_(_),
_s_p_S_c_a_l_e_(_),  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_),  _s_p_F_a_c_t_o_r_(_),  _s_p_S_o_l_v_e_(_),  or  _s_p_S_o_l_v_e_T_r_a_n_s_-
_p_o_s_e_d_(_) until the error has been cleared by _s_p_C_l_e_a_r_(_) or _s_p_I_n_i_t_i_a_l_i_z_e_(_).













                            -58-


66..22::  SSppaarrssee CCoonnssttaannttss

     These constants are used throughout the sparse matrix routines.   They
should be set to suit the type of matrices being solved.


DEFAULT_THRESHOLD

The  threshold  used  if  the  user  enters an invalid threshold.  Also the
threshold used by _s_p_F_a_c_t_o_r_(_) when calling _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_).  The  default
threshold should not be less than or equal to zero nor larger than one.


DIAG_PIVOTING_AS_DEFAULT

This  indicates  whether _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_) should use diagonal pivoting as
default.  This issue only arises when  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)  is  called  from
_s_p_F_a_c_t_o_r_(_).


SPACE_FOR_ELEMENTS

This  number multiplied by the size of the matrix equals the number of ele-
ments for which memory is initially allocated in _s_p_C_r_e_a_t_e_(_).


SPACE_FOR_FILL_INS

This number multiplied by the size of the matrix equals the number of  ele-
ments for which memory is initially allocated and specifically reserved for
fill-ins in _s_p_C_r_e_a_t_e_(_).


ELEMENTS_PER_ALLOCATION

The number of matrix elements requested from the  _m_a_l_l_o_c  utility  on  each
call  to  it.   Setting  this  value greater than one reduces the amount of
overhead spent in this system call.


MINIMUM_ALLOCATED_SIZE

The minimum allocated size of a matrix.  Note that this does not limit  the
minimum  size  of  a  matrix.  This just prevents having to resize a matrix
many times if the matrix is expandable, large and allocated with  an  esti-
mated size of zero.  This number must not be less than one.


EXPANSION_FACTOR

The  minimum  increase  in  the  allocated  size  of  the matrix when it is
expanded.  This number must be greater  than  one  but  shouldn't  be  much
larger than two.










                            -59-


MAX_MARKOWITZ_TIES

This number is used for two slightly different things, both of which relate
to the search for the best pivot.  First, it is the maximum number of  ele-
ments  that  are  Markowitz tied that will be sifted through when trying to
find the one that is numerically the best.  Second,  it  creates  an  upper
bound on how large a Markowitz product can be before it eliminates the pos-
sibility of early termination of the pivot search.  In other words, if  the
product  of the smallest Markowitz product yet found and TIES_MULTIPLIER is
greater than MAX_MARKOWITZ_TIES, then no  early  termination  takes  place.
Set  MAX_MARKOWITZ_TIES  to some small value if no early termination of the
pivot search  is  desired.  An  array  of  spREALs  is  allocated  of  size
MAX_MARKOWITZ_TIES so it must be positive and shouldn't be too large.


TIES_MULTIPLIER

Specifies the number of Markowitz ties that are allowed to occur before the
search for the pivot is terminated early.  Set to some large  value  if  no
early  termination  of  the pivot search is desired.  This number is multi-
plied by the Markowitz product to determine how many ties are required  for
early  termination.   This means that more elements will be searched before
early termination if a large number of fill-ins could be created by accept-
ing  what  is  currently considered the best choice for the pivot.  Setting
this number to zero effectively eliminates all pivoting,  which  should  be
avoided.  This number must be positive.


DEFAULT_PARTITION

Which  partition  mode  is used by _s_p_P_a_r_t_i_t_i_o_n_(_) as default.  Possibilities
include:

     spDIRECT_PARTITION  -- each row used direct addressing, best for a few
          relatively dense matrices.

     spINDIRECT_PARTITION  -- each row used indirect addressing, best for a
          few very sparse matrices.

     spAUTO_PARTITION  -- direct or indirect addressing is chosen on a row-
          by-row  basis, carries a large overhead, but speeds up both dense
          and sparse matrices, best if there is a large number of  matrices
          that can use the same ordering.


PRINTER_WIDTH

Gives  the number of characters printable in one page width.  Set to 80 for
terminals and 132 for line printers.














                            -60-


66..33::  MMaacchhiinnee CCoonnssttaannttss

These numbers -m-u-s-t-be updated when the program is ported to a new  machine.


MACHINE_RESOLUTION

This  is  the smallest positive real double precision number $epsilon$ such
that $ 1 ~ + ~ epsilon ~ != ~ 1 $.


LARGEST_REAL

The largest positive real number representable by a ddoouubbllee.


SMALLEST_REAL

The smallest positive real number representable by a ddoouubbllee.


LARGEST_SHORT_INTEGER

The largest positive integer representable by a sshhoorrtt.


LARGEST_LONG_INTEGER

The largest positive integer representable by a lloonngg.


































                            -61-


77::  EEXXPPOORRTTSS

77..11::  EErrrroorr CCooddeess

     Errors are indicated with a integer error  code.   Macros  definitions
for  these  error codes are set up and placed in the file ssppMMaattrriixx..hh.  They
may be imported into the users program to give readable names to the possi-
ble matrix errors.  The possible error codes and there corresponding macros
are:


spOKAY  --  0

No error has occurred.

spSMALL_PIVOT  --  1

When reordering the matrix, no element was found which satisfies the  abso-
lute  threshold  criteria.  The largest element in the matrix was chosen as
pivot.  Nonfatal.

spZERO_DIAG  --  2

Fatal error.  A zero was encountered on the diagonal of the  matrix.   This
does  not  necessarily  imply that the matrix is singular.  When this error
occurs, the matrix should be reconstructed and factored  using  _s_p_O_r_d_e_r_A_n_d_-
_F_a_c_t_o_r_(_).

spSINGULAR  --  3

Fatal error.  Matrix is singular, so no unique solution exists.

spNO_MEMORY  --  4

Fatal error.  Indicates that not enough memory is available from the system
to handle the matrix.

spPANIC  --  5

Fatal error indicating that the routines are being asked  to  do  something
nonsensical  or  something they are not prepared for.  This error may occur
when the matrix is specified to be real and the routines are  not  compiled
for  real  matrices,  or when the matrix is specified to be complex and the
routines are not compiled to handle complex matrices.

spFATAL  --  2

Not an error flag, but rather the dividing line between  fatal  errors  and
warnings.














                            -62-


77..22::  DDaattaa SSttrruuccttuurreess

     There  is  only  one  data structure that may need to be imported from
_S_p_a_r_s_e by the user.  This data structure is used to hold pointers  to  four
related elements in matrix.  It is used in conjunction with the routines
     _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_)
     _s_p_G_e_t_O_n_e_s_(_)
     _s_p_G_e_t_Q_u_a_d_(_)

_s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_),  _s_p_G_e_t_O_n_e_s_(_),  and _s_p_G_e_t_Q_u_a_d_(_) stuff the structure which
is later used by the _s_p_A_D_D___Q_U_A_D_(_) macros.  It is also possible for the user
to collect four pointers returned by _s_p_G_e_t_E_l_e_m_e_n_t_(_) and stuff them into the
template.  The _s_p_A_D_D___Q_U_A_D_(_) macros add a value into _E_l_e_m_e_n_t_1  and  _E_l_e_m_e_n_t_2
and subtract the value from _E_l_e_m_e_n_t_3 and _E_l_e_m_e_n_t_4.  The structure is:

ssttrruucctt _s_p_T_e_m_p_l_a_t_e
{    spREAL    *_E_l_e_m_e_n_t_1;
     spREAL    *_E_l_e_m_e_n_t_2;
     spREAL    *_E_l_e_m_e_n_t_3_N_e_g_a_t_e_d;
     spREAL    *_E_l_e_m_e_n_t_4_N_e_g_a_t_e_d;
};










































                            -63-


88::  FFOORRTTRRAANN CCOOMMPPAATTIIBBIILLIITTYY

     The  _S_p_a_r_s_e_1_._3  package  contains routines that interface to a calling
program written in FORTRAN.  Almost every  externally  available  _S_p_a_r_s_e_1_._3
routine  has  a counterpart defined with the same name except that the `sp'
prefix is changed to `sf'.  The _s_p_A_D_D___E_L_E_M_E_N_T_(_) and _s_p_A_D_D___Q_U_A_D_(_) macros are
also replaced with the _s_f_A_d_d_1_(_) and _s_f_A_d_d_4_(_) functions.

     Any interface between two languages is going to have portibility prob-
lems, this one is no exception.  To ease porting the FORTRAN interface file
to different operating systems, the names of the interface functions can be
easily redefined (search for  `Routine  Renaming'  in  ssppFFoorrttrraann..cc).   When
interfacing  to  a FORTRAN program, the FORTRAN option should be set to YES
and the ARRAY_OFFSET option should be set  to  NO  (see  ssppCCoonnffiigg..hh).   For
details  on  the  return  value and argument list of a particular interface
routine, see the file ssppFFoorrttrraann..cc.

     A simple example of a FORTRAN program that calls _S_p_a_r_s_e follows.













































                            -64-


EExxaammppllee::
           integer matrix, error, sfCreate, sfGetElement, spFactor
           integer element(10)
           double precision rhs(4), solution(4)
     c
     c create matrix
           matrix = sfCreate(4,0,error)
     c
     c reserve elements
           element(1) = sfGetElement(matrix,1,1)
           element(2) = sfGetElement(matrix,1,2)
           element(3) = sfGetElement(matrix,2,1)
           element(4) = sfGetElement(matrix,2,2)
           element(5) = sfGetElement(matrix,2,3)
           element(6) = sfGetElement(matrix,3,2)
           element(7) = sfGetElement(matrix,3,3)
           element(8) = sfGetElement(matrix,3,4)
           element(9) = sfGetElement(matrix,4,3)
           element(10) = sfGetElement(matrix,4,4)
     c
     c clear matrix
           call sfClear(matrix)
     c
     c load matrix
           call sfAdd1Real(element(1), 2d0)
           call sfAdd1Real(element(2), -1d0)
           call sfAdd1Real(element(3), -1d0)
           call sfAdd1Real(element(4), 3d0)
           call sfAdd1Real(element(5), -1d0)
           call sfAdd1Real(element(6), -1d0)
           call sfAdd1Real(element(7), 3d0)
           call sfAdd1Real(element(8), -1d0)
           call sfAdd1Real(element(9), -1d0)
           call sfAdd1Real(element(10), 3d0)
           call sfprint(matrix, .false., .false., .true.)
           rhs(1) = 34d0
           rhs(2) = 0d0
           rhs(3) = 0d0
           rhs(4) = 0d0
     c
     c factor matrix
           error = sfFactor(matrix)
     c
     c solve matrix
           call sfSolve(matrix, rhs, solution)
           write (6, 10) solution(1), solution(2), solution(3), solution(4)
        10 format (f 10.2)
           end















                            -65-


99::  SSPPAARRSSEE TTEESSTT PPRROOGGRRAAMM

     The _S_p_a_r_s_e package includes a test program that is able to read matrix
equations  from  text  files  and  print  their  solution along with matrix
statistics and timing information.  The program  can  also  generate  files
containing stripped versions of the unfactored and factored matrix suitable
for plotting using standard plotting programs, such as the UNIX  graph  and
plot commands.

The _S_p_a_r_s_e test program is invoked using the following syntax.

     ssppaarrssee [_o_p_t_i_o_n_s] [_f_i_l_e_1] [_f_i_l_e_2] ...

     l l lw(4.5i).  Options: --ss   T{ Print solution only.  T} --rr _x T{ Use _x
     as relative threshold.  T} --aa _x T{ Use _x as absolute threshold.  T} --nn
     _n T{  Print  first  _n  terms  of  solution  vector.  T} --ii _n T{ Repeat
     build/factor/solve _n times for better timing results.  T} --bb _n T{  Use
     column  _n of matrix as right-hand side vector.  T} --pp   T{ Create plot
     files ``_f_i_l_e_n_a_m_e..bbeeff'' and ``_f_i_l_e_n_a_m_e..aafftt''.  T} --cc   T{ Use  complete
     (as  opposed  to  diagonal) pivoting.  T} --xx   T{ Treat real matrix as
     complex with imaginary part zero.  T} --tt   T{ Solve transposed system.
     T} --uu   T{ Print usage message.  T}


The  presence  of  certain  options is dependent on whether the appropriate
_S_p_a_r_s_e option has been enabled.

If no input files are specified, ssppaarrssee reads from the standard input.  The
syntax of the input file is as follows.  The matrix begins with one line of
arbitrary text that acts as the label, followed by a line with the  integer
size  of  the  matrix  and  either the rreeaall or ccoommpplleexx keywords.  After the
header is an arbitrary number of lines that describe the structural  nonze-
ros  in  the  matrix.  These lines have the form _r_o_w _c_o_l_u_m_n _d_a_t_a, where _r_o_w
and _c_o_l_u_m_n are integers and _d_a_t_a is either one real number for real  matri-
ces  or  a  real/imaginary  pair of numbers for complex matrices.  Only one
structural nonzero is described per line and the section ends  when  either
_r_o_w  or _c_o_l_u_m_n are zero.  Following the matrix, an optional right-hand side
vector can be described.  The vector is given one  element  per  line,  the
number  of  element must equal the size of the matrix.  Only one matrix and
one vector are allowed per file, and the vector, if given, must follow  the
matrix.






















                            -66-


EExxaammppllee::
     mat0  --  Simple matrix.
     4    real
     1    1    2.0
     1    2    -1.0
     2    1    -1.0
     2    2    3.0
     2    3    -1.0
     3    2    -1.0
     3    3    3.0
     3    4    -1.0
     4    3    -1.0
     4    4    3.0
     0    0    0.0
     34.0
     0.0
     0.0
     0.0













































                            -67-


1100::  SSPPAARRSSEE FFIILLEESS

     The  following  is a list of the files contained in the _S_p_a_r_s_e package
and a brief description of their contents.  Of the files,  only  ssppCCoonnffiigg..hh
is expected to be modified by the user and only ssppMMaattrriixx..hh need be imported
into the program that calls _S_p_a_r_s_e.


ssppAAlllloocc..cc

This file contains the routines for  allocating  and  deallocating  objects
associated with the matrices, including the matrices themselves.

+o User accessible functions contained in this module:
     _s_p_C_r_e_a_t_e_(_)
     _s_p_D_e_s_t_r_o_y_(_)
     _s_p_E_r_r_o_r_(_)
     _s_p_W_h_e_r_e_S_i_n_g_u_l_a_r_(_)
     _s_p_G_e_t_S_i_z_e_(_)
     _s_p_S_e_t_R_e_a_l_(_)
     _s_p_S_e_t_C_o_m_p_l_e_x_(_)
     _s_p_F_i_l_l_i_n_C_o_u_n_t_(_)
     _s_p_E_l_e_m_e_n_t_C_o_u_n_t_(_)


ssppBBuuiilldd..cc

This file contains the routines for clearing and loading the matrix.

+o User accessible functions contained in this module:
     _s_p_C_l_e_a_r_(_)
     _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_)
     _s_p_G_e_t_E_l_e_m_e_n_t_(_)
     _s_p_G_e_t_I_n_i_t_I_n_f_o_(_)
     _s_p_G_e_t_O_n_e_s_(_)
     _s_p_G_e_t_Q_u_a_d_(_)
     _s_p_I_n_i_t_i_a_l_i_z_e_(_)
     _s_p_I_n_s_t_a_l_l_I_n_i_t_I_n_f_o_(_)


ssppCCoonnffiigg..hh

This file contains the options that are used to customize the package.  For
example, it is possible to specify whether only real or complex systems  of
equations  are  to  be  solved.  Also included in this file are the various
constants used by the _S_p_a_r_s_e package, such as the  amount  of  memory  ini-
tially allocated for each matrix and the largest real number represented by
the machine.  The user is expected to modify this file to maximize the per-
formance of the routines with his/her matrices.














                            -68-


ssppDDeeffss..hh

This  module  contains common data structure definitions and macros for the
sparse matrix routines.  These definitions are meant to remain hidden  from
the program that calls the sparse matrix routines.


ssppDDoocc

This  reference  manual.  ssppDDoocc contains the manual in a form that is read-
able on-line and ssppDDoocc..mmss contains the manual in a form  that  is  suitable
for input into the text formatting program _t_r_o_f_f using the -ms macros.


ssppFFaaccttoorr..cc

This file contains the routines for factoring matrices into LU form.

+o User accessible functions contained in this module:
     _s_p_F_a_c_t_o_r_(_)
     _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)
     _s_p_P_a_r_t_i_t_i_o_n_(_)









































                            -69-


ssppFFoorrttrraann..cc

This  file  contains  the  routines  for interfacing _S_p_a_r_s_e_1_._3 to a program
written in FORTRAN.  The function and argument lists  of  the  routines  in
this  file are almost identical to their C equivalents except that they are
suitable for calling from a FORTRAN program.  The names of  these  routines
use the `sf' prefix to distinguish them from their C counterparts.

+o User accessible functions contained in this module:
     _s_f_A_d_d_1_C_o_m_p_l_e_x_(_)
     _s_f_A_d_d_1_I_m_a_g_(_)
     _s_f_A_d_d_1_R_e_a_l_(_)
     _s_f_A_d_d_4_C_o_m_p_l_e_x_(_)
     _s_f_A_d_d_4_I_m_a_g_(_)
     _s_f_A_d_d_4_R_e_a_l_(_)
     _s_f_C_l_e_a_r_(_)
     _s_f_C_o_n_d_i_t_i_o_n_(_)
     _s_f_C_r_e_a_t_e_(_)
     _s_f_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_)
     _s_f_D_e_s_t_r_o_y_(_)
     _s_f_D_e_t_e_r_m_i_n_a_n_t_(_)
     _s_f_E_l_e_m_e_n_t_C_o_u_n_t_(_)
     _s_f_E_r_r_o_r_(_)
     _s_f_F_a_c_t_o_r_(_)
     _s_f_F_i_l_e_M_a_t_r_i_x_(_)
     _s_f_F_i_l_e_S_t_a_t_s_(_)
     _s_f_F_i_l_e_V_e_c_t_o_r_(_)
     _s_f_F_i_l_l_i_n_C_o_u_n_t_(_)
     _s_f_G_e_t_A_d_m_i_t_t_a_n_c_e_(_)
     _s_f_G_e_t_E_l_e_m_e_n_t_(_)
     _s_f_G_e_t_O_n_e_s_(_)
     _s_f_G_e_t_Q_u_a_d_(_)
     _s_f_G_e_t_S_i_z_e_(_)
     _s_f_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_)
     _s_f_M_N_A___P_r_e_o_r_d_e_r_(_)
     _s_f_M_u_l_t_T_r_a_n_s_p_o_s_e_d_(_)
     _s_f_M_u_l_t_i_p_l_y_(_)
     _s_f_N_o_r_m_(_)
     _s_f_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)
     _s_f_P_a_r_t_i_t_i_o_n_(_)
     _s_f_P_r_i_n_t_(_)
     _s_f_P_s_e_u_d_o_C_o_n_d_i_t_i_o_n_(_)
     _s_f_R_o_u_n_d_o_f_f_(_)
     _s_f_S_c_a_l_e_(_)
     _s_f_S_e_t_C_o_m_p_l_e_x_(_)
     _s_f_S_e_t_R_e_a_l_(_)
     _s_f_S_o_l_v_e_(_)
     _s_f_S_o_l_v_e_T_r_a_n_s_p_o_s_e_d_(_)
     _s_f_S_t_r_i_p_F_i_l_l_s_(_)
     _s_f_W_h_e_r_e_S_i_n_g_u_l_a_r_(_)













                            -70-


ssppMMaattrriixx..hh

This  file contains definitions that are useful to the calling program.  In
particular, this file contains error keyword definitions, some macro  func-
tions  that  are used to quickly enter data into the matrix, the definition
of a data structure that acts as a template for entering  admittances  into
the matrix, and the type declarations of the various _S_p_a_r_s_e functions.


ssppOOuuttppuutt..cc

This file contains the output-to-file and output-to-screen routines for the
matrix package.  They are capable of outputting the matrix in either a form
readable by people or a form readable by the _S_p_a_r_s_e test program.

+o User accessible functions contained in this module:
     _s_p_F_i_l_e_M_a_t_r_i_x_(_)
     _s_p_F_i_l_e_S_t_a_t_s_(_)
     _s_p_F_i_l_e_V_e_c_t_o_r_(_)
     _s_p_P_r_i_n_t_(_)


ssppRReevviissiioonn

The  history  of updates for the program.  This file also includes ordering
information for the _S_p_a_r_s_e package.


ssppSSoollvvee..cc

This module contains the forward and backward substitution routines.

+o User accessible functions contained in this module:
     _s_p_S_o_l_v_e_(_)
     _s_p_S_o_l_v_e_T_r_a_n_s_p_o_s_e_d_(_)


ssppTTeesstt..cc

This module contains a test program for the sparse matrix routines.  It  is
able to read matrices from files and solve them.  Because of the large num-
ber of options and capabilities built into _S_p_a_r_s_e, it is impossible to have
one test routine thoroughly exercise _S_p_a_r_s_e.  Thus, emphasis is on exercis-
ing as many capabilities as is reasonable while  also  providing  a  useful
tool.


















                            -71-


ssppUUttiill..cc

This module contains various optional utility routines.

+o User accessible functions contained in this module:
     _s_p_C_o_n_d_i_t_i_o_n_(_)
     _s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_)
     _s_p_D_e_t_e_r_m_i_n_a_n_t_(_)
     _s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_)
     _s_p_M_N_A___P_r_e_o_r_d_e_r_(_)
     _s_p_M_u_l_t_i_p_l_y_(_)
     _s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_(_)
     _s_p_N_o_r_m_(_)
     _s_p_P_s_e_u_d_o_C_o_n_d_i_t_i_o_n_(_)
     _s_p_R_o_u_n_d_o_f_f_(_)
     _s_p_S_c_a_l_e_(_)
     _s_p_S_t_r_i_p_F_i_l_l_s_(_)


MMaakkeeffiillee

This  file is used in conjunction with the UNIX program mmaakkee to compile the
matrix routines and their test program.


mmaakkee..ccoomm

This file is used to automatically compile _S_p_a_r_s_e under the  VMS  operating
system.  It needs to modified slightly before being used, see the installa-
tion notes.

































                            -72-


RREEFFEERREENNCCEESS

[duff86]       I. S. Duff, A. M. Erisman, J. K. Reid.  _D_i_r_e_c_t  _M_e_t_h_o_d_s  _f_o_r
               _S_p_a_r_s_e _M_a_t_r_i_c_e_s.  Oxford University Press, 1986.

[golub86]      G.  H.  Golub, C. F. V. Van Loan.  _M_a_t_r_i_x _C_o_m_p_u_t_a_t_i_o_n_s.  The
               Johns Hopkins University Press, 1983.

[kundert86]    Kenneth S. Kundert.  Sparse matrix techniques.   In  _C_i_r_c_u_i_t
               _A_n_a_l_y_s_i_s_,  _S_i_m_u_l_a_t_i_o_n  _a_n_d  _D_e_s_i_g_n,  Albert Ruehli (editor).
               North-Holland, 1986.

[strang80]     Gilbert Strang.  _L_i_n_e_a_r _A_l_g_e_b_r_a _a_n_d _I_t_s _A_p_p_l_i_c_a_t_i_o_n_s.   Aca-
               demic Press, 1980.


               AAcckknnoowwlleeddggeemmeennttss

     We  would  like  to  acknowledge  and thank the those people that con-
tributed ideas that were incorporated into _S_p_a_r_s_e.   In  particular,  Jacob
White,  Kartikeya Mayaram, Don Webber, Tom Quarles, Howard Ko and Beresford
Parlett.












































                             TTaabbllee ooff CCoonntteennttss


1:  Introduction  . . . . . . . . . . . . . . . . . . . . . . . . . . .   1
     1.1:  Features of Sparse1.3  . . . . . . . . . . . . . . . . . . .   1
     1.2:  Enhancements of Sparse1.3 over Sparse1.2 . . . . . . . . . .   2
     1.3:  Copyright Information  . . . . . . . . . . . . . . . . . . .   3
2:  Primer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.1:  Solving Matrix Equations . . . . . . . . . . . . . . . . . .   4
     2.2:  Error Control  . . . . . . . . . . . . . . . . . . . . . . .   5
     2.3:  Building the Matrix  . . . . . . . . . . . . . . . . . . . .   6
     2.4:  Initializing the Matrix  . . . . . . . . . . . . . . . . . .   7
     2.5:  Indices  . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     2.6:  Configuring Sparse . . . . . . . . . . . . . . . . . . . . .   9
3:  Introduction to the Sparse Routines . . . . . . . . . . . . . . . .  10
     3.1:  Creating the Matrix  . . . . . . . . . . . . . . . . . . . .  10
     3.2:  Building the Matrix  . . . . . . . . . . . . . . . . . . . .  10
     3.3:  Clearing the Matrix  . . . . . . . . . . . . . . . . . . . .  10
     3.4:  Placing Data in the Matrix . . . . . . . . . . . . . . . . .  11
     3.5:  Influencing the Factorization  . . . . . . . . . . . . . . .  11
     3.6:  Factoring the Matrix . . . . . . . . . . . . . . . . . . . .  11
     3.7:  Solving the Matrix Equation  . . . . . . . . . . . . . . . .  12
     3.8:  Numerical Error Estimation . . . . . . . . . . . . . . . . .  12
     3.9:  Matrix Operations  . . . . . . . . . . . . . . . . . . . . .  13
     3.10:  Matrix Statistics and Documentation . . . . . . . . . . . .  13
4:  Routines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
     4.1:  _s_p_C_l_e_a_r_(_)  . . . . . . . . . . . . . . . . . . . . . . . . .  15
     4.2:  _s_p_C_o_n_d_i_t_i_o_n_(_)  . . . . . . . . . . . . . . . . . . . . . . .  16
     4.3:  _s_p_C_r_e_a_t_e_(_) . . . . . . . . . . . . . . . . . . . . . . . . .  17
     4.4:  _s_p_D_e_l_e_t_e_R_o_w_A_n_d_C_o_l_(_)  . . . . . . . . . . . . . . . . . . . .  18
     4.5:  _s_p_D_e_s_t_r_o_y_(_)  . . . . . . . . . . . . . . . . . . . . . . . .  18
     4.6:  _s_p_D_e_t_e_r_m_i_n_a_n_t_(_)  . . . . . . . . . . . . . . . . . . . . . .  19
     4.7:  _s_p_E_l_e_m_e_n_t_C_o_u_n_t_(_) . . . . . . . . . . . . . . . . . . . . . .  20
     4.8:  _s_p_E_r_r_o_r_(_)  . . . . . . . . . . . . . . . . . . . . . . . . .  20
     4.9:  _s_p_F_a_c_t_o_r_(_) . . . . . . . . . . . . . . . . . . . . . . . . .  21
     4.10:  _s_p_F_i_l_e_M_a_t_r_i_x_(_)  . . . . . . . . . . . . . . . . . . . . . .  22
     4.11:  _s_p_F_i_l_e_S_t_a_t_s_(_) . . . . . . . . . . . . . . . . . . . . . . .  23
     4.12:  _s_p_F_i_l_e_V_e_c_t_o_r_(_)  . . . . . . . . . . . . . . . . . . . . . .  24
     4.13:  _s_p_F_i_l_l_i_n_C_o_u_n_t_(_) . . . . . . . . . . . . . . . . . . . . . .  25
     4.14:  _s_p_G_e_t_A_d_m_i_t_t_a_n_c_e_(_) . . . . . . . . . . . . . . . . . . . . .  26
     4.15:  _s_p_G_e_t_E_l_e_m_e_n_t_(_)  . . . . . . . . . . . . . . . . . . . . . .  27
     4.16:  _s_p_G_e_t_I_n_i_t_I_n_f_o_(_) . . . . . . . . . . . . . . . . . . . . . .  28
     4.17:  _s_p_G_e_t_O_n_e_s_(_) . . . . . . . . . . . . . . . . . . . . . . . .  30
     4.18:  _s_p_G_e_t_Q_u_a_d_(_) . . . . . . . . . . . . . . . . . . . . . . . .  32
     4.19:  _s_p_G_e_t_S_i_z_e_(_) . . . . . . . . . . . . . . . . . . . . . . . .  32
     4.20:  _s_p_I_n_i_t_i_a_l_i_z_e_(_)  . . . . . . . . . . . . . . . . . . . . . .  34
     4.21:  _s_p_I_n_s_t_a_l_l_I_n_i_t_I_n_f_o_(_) . . . . . . . . . . . . . . . . . . . .  34
     4.22:  _s_p_L_a_r_g_e_s_t_E_l_e_m_e_n_t_(_)  . . . . . . . . . . . . . . . . . . . .  35
     4.23:  _s_p_M_N_A___P_r_e_o_r_d_e_r_(_)  . . . . . . . . . . . . . . . . . . . . .  36
     4.24:  _s_p_M_u_l_t_i_p_l_y_(_)  . . . . . . . . . . . . . . . . . . . . . . .  37
     4.25:  _s_p_M_u_l_t_T_r_a_n_s_p_o_s_e_d_(_)  . . . . . . . . . . . . . . . . . . . .  38
     4.26:  _s_p_N_o_r_m_(_)  . . . . . . . . . . . . . . . . . . . . . . . . .  39
     4.27:  _s_p_O_r_d_e_r_A_n_d_F_a_c_t_o_r_(_)  . . . . . . . . . . . . . . . . . . . .  39
     4.28:  _s_p_P_a_r_t_i_t_i_o_n_(_) . . . . . . . . . . . . . . . . . . . . . . .  41












     4.29:  _s_p_P_r_i_n_t_(_) . . . . . . . . . . . . . . . . . . . . . . . . .  42
     4.30:  _s_p_P_s_e_u_d_o_C_o_n_d_i_t_i_o_n_(_) . . . . . . . . . . . . . . . . . . . .  43
     4.31:  _s_p_R_o_u_n_d_o_f_f_(_)  . . . . . . . . . . . . . . . . . . . . . . .  44
     4.32:  _s_p_S_c_a_l_e_(_) . . . . . . . . . . . . . . . . . . . . . . . . .  45
     4.33:  _s_p_S_e_t_C_o_m_p_l_e_x_(_)  . . . . . . . . . . . . . . . . . . . . . .  46
     4.34:  _s_p_S_e_t_R_e_a_l_(_) . . . . . . . . . . . . . . . . . . . . . . . .  46
     4.35:  _s_p_S_o_l_v_e_(_) . . . . . . . . . . . . . . . . . . . . . . . . .  47
     4.36:  _s_p_S_o_l_v_e_T_r_a_n_s_p_o_s_e_d_(_) . . . . . . . . . . . . . . . . . . . .  48
     4.37:  _s_p_S_t_r_i_p_F_i_l_l_s_(_)  . . . . . . . . . . . . . . . . . . . . . .  49
     4.38:  _s_p_W_h_e_r_e_S_i_n_g_u_l_a_r_(_) . . . . . . . . . . . . . . . . . . . . .  49
5:  Macro Functions . . . . . . . . . . . . . . . . . . . . . . . . . .  50
     5.1:  _s_p_A_D_D___R_E_A_L___E_L_E_M_E_N_T_(_) . . . . . . . . . . . . . . . . . . . .  50
     5.2:  _s_p_A_D_D___I_M_A_G___E_L_E_M_E_N_T_(_) . . . . . . . . . . . . . . . . . . . .  50
     5.3:  _s_p_A_D_D___C_O_M_P_L_E_X___E_L_E_M_E_N_T_(_)  . . . . . . . . . . . . . . . . . .  51
     5.4:  _s_p_A_D_D___R_E_A_L___Q_U_A_D_(_)  . . . . . . . . . . . . . . . . . . . . .  51
     5.5:  _s_p_A_D_D___I_M_A_G___Q_U_A_D_(_)  . . . . . . . . . . . . . . . . . . . . .  52
     5.6:  _s_p_A_D_D___C_O_M_P_L_E_X___Q_U_A_D_(_) . . . . . . . . . . . . . . . . . . . .  52
6:  Configuring _S_p_a_r_s_e  . . . . . . . . . . . . . . . . . . . . . . . .  53
     6.1:  Sparse Options . . . . . . . . . . . . . . . . . . . . . . .  53
     6.2:  Sparse Constants . . . . . . . . . . . . . . . . . . . . . .  58
     6.3:  Machine Constants  . . . . . . . . . . . . . . . . . . . . .  60
7:  Exports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  61
     7.1:  Error Codes  . . . . . . . . . . . . . . . . . . . . . . . .  61
     7.2:  Data Structures  . . . . . . . . . . . . . . . . . . . . . .  62
8:  FORTRAN Compatibility . . . . . . . . . . . . . . . . . . . . . . .  63
9:  _S_p_a_r_s_e Test Program . . . . . . . . . . . . . . . . . . . . . . . .  65
10:  _S_p_a_r_s_e Files . . . . . . . . . . . . . . . . . . . . . . . . . . .  67
References  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  72
































