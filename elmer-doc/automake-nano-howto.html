<html><head>
  <title>Autotools nano-HOWTO</title>
  <link rel="stylesheet" href="elmer.css" />
<!-- <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> -->
</head>
<body>

<h1>Autotools nano-HOWTO</h1>

<p>(c)
2005 Juha Vierinen
&lt;juha.vierinen(#parsethis%#]csc.fi&gt;</p>

<h2>Building autotools managed
software</h2>


<p>The normal way is this:</p>

<pre>./configure ; make ; make install<br/></pre>

<p>
Usually there are also many custom options provided by the package
maintainer. The help option usually lists these.
</p>

<pre>./configure --help<br/></pre>

<p>
Eg. the following will install the software into the home directory of
the user instead of the default location (/usr or /usr/local).
</p>

<pre>./configure --prefix=/home/user<br/></pre>

<p>
Common environment variables are CFLAGS, CXXFLAGS, FFLAGS, FCFLAGS,
LIBS and LDFLAGS. These are processed and tested by configure and added
to the flags that configure comes up with. For example:
</p>

<pre>export CFLAGS="-O42 -g --funny-compiler-flag -I/hard/to/guess/directory" <br/>./configure ; make <span class="comment"># will usually use your CFLAGS for compiling</span><br/></pre>

<p>
On more obscure (ie. AIX or OSX) platforms, you will often have to come
up with CFLAGS and
LDFLAGS that will give the right libraries. Sometimes, a package might
also
include custom arguments to do this as well eg.:
</p>

<pre>./configure --with-blas="-L/home/user -lblas"<br/>./configure --with-blas="/opt/supafastblaswithstripesandachrometailpipe.a"<br/></pre>

<h2>Automake provided default
targets</h2>

<p>The commonly used targets are:</p>

<pre>make <span class="comment"># Compile everything.</span><br/>make clean <span class="comment"># Remove all objects, temporary files and such.</span><br/>make distclean <span class="comment"># Remove automatically generated autoconf/automake files.</span><br/>make dist <span class="comment"># Create a tar.gz file containing source ready for distribution.</span><br/>make install <span class="comment"># Install software to you kit.</span><br/></pre>

<p>Other useful targets:</p>

<pre>make tags <span class="comment"># Generate etags files for the source.</span><br/>make dist-zip <span class="comment"># Create a zip file (great for windows people)</span><br/>make uninstall <span class="comment"># Uninstall the files installed with make install</span><br/>make check <span class="comment"># Run tests bundled with the project</span><br/></pre>

<h2>The anatomy of a automake and
autoconf governed project</h2>

<pre>autogen.sh <span class="comment"># Semi-standard script for generating the configure <br/> # script and possibly the Makefile.in files</span><br/>configure.[in,ac] <span class="comment"># The template used for producing configure</span><br/>Makefile.in <span class="comment"># Autoconf makefile template</span><br/>Makefile.am <span class="comment"># Automake makefile template</span><br/></pre>

<h2>Maintaining an autoconf project</h2>

<p>
If only autoconf is used, then Makefile.in is the file to
edit. Autoconf variables appear as @VARIABLE@ like definitions (these
are replaced with values found by the configure script). It is
also possible to use autoconf definitions in Makefile.am files, this
is especially useful for situations where automake functionality runs
short. A snippet of Makefile.in can look like:
</p>

<pre>screensave.@SHEXT@: screensave.@OBJEXT@<br/>	@CC@ @SH_LDFLAGS@ -o $@ $&lt; @LIBS@<br/></pre>

<p>
When making modifications to the makefiles, you should run autogen.sh,
or aclocal;automake;autoheader;autoconf in a corrct order. There is
also a maintainer mode available that automatically regenerates the
makefiles when necessary. This is enabled by default, but is usually
switched of with the AM_MAINTAINER_MODE macro, but can be re-enabled
by giving the <code>--enable-maintainer-mode</code>
flag to <code>./configure</code>.
</p>

<p>
The end result of both autoconf and automake is a set of portable
Makefiles, which should be kept in mind when creating
definitions.
</p>

<h2>Maintaining an
autoconf+automake project</h2>

<p>
If automake is used, the file to edit is Makefile.am. You can also mix
custom Makefile directives in here, but stick with automake
definitions whenever possible, as it will save a lot of time. A simple
Makefile.am could look like this:
</p>

<pre>bin_PROGRAMS=hello<br/>hello_SOURCES=hello.c hello.h someotherfile.f waytoocomplex.cpp<br/></pre>

<h2>Commands</h2>

<pre>autoscan <span class="comment"># Scan your source code to detect which tests might be needed and <br/> # create a configure.scan, which can be used as a basis of <br/>	# configure.in.</span><br/>autoheader <span class="comment"># Scan configure.in and create a config.h.in file, that will </span><br/> <span class="comment"># </span><span class="comment">be used as a basis of your config.h (if you use one)</span><br/>automake <span class="comment"># Go through configure.in and Makefile.am files and create </span><br/> <span class="comment"># Makefile.in files.</span><br/>autoconf <span class="comment"># Go through configure.in and create the configure script.</span><br/></pre>

<p>
Still can't figure out what to run and in which order? Try running
automake, aclocal, autoconf and autoheader in random combinations, and
you'll usually end up with something useful after a couple of
iterations. When you get a feeling of what is needed, write it down
into autogen.sh, so you'll remember it next time.
</p>

<h2>Writing custom tests</h2>

<p>
You can write tests directly into configure.in. The language is an
obscure macro-language called M4, which expands to Bourne shell
script. So you basically write in a mixture of sh and M4. Eg.
</p>

<pre>AC_MSG_CHECKING([for answer to meaning of life]) <span class="comment"># M4 function call</span><br/>answer="42" <span class="comment"># sh variable assignment</span><br/>AC_MSG_RESULT($answer) <span class="comment"># M4 function call</span><br/></pre>

<p>
Even writing modular and reusable M4+sh is possible, just take a look
at the autoconf source for the default AC_* macros.
</p>

<p>
If you intend to write a lot of tests, it is beneficial to write them
into separate .m4 files. This has an advantage of keeping configure.in
more understandable. Eg. you might have a file acx_blas.m4 that
contains a routine that gives a BLAS library as an argument to
./configure:
</p>

<pre>AC_DEFUN([ACX_BLAS], <br/>[<br/>acx_blas_ok=no<br/><br/>AC_ARG_WITH(blas,<br/>	[AC_HELP_STRING([--with-blas=&lt;lib&gt;], [use BLAS library &lt;lib&gt;])])<br/>case $with_blas in<br/>	yes | "") ;;<br/>	no) acx_blas_ok=disable ;;<br/>	-* | */* | *.a | *.so | *.so.* | *.o) BLAS_LIBS="$with_blas" ;;<br/>	*) BLAS_LIBS="-l$with_blas" ;;<br/>esac<br/><br/><span class="comment"># Get fortran symbol name of sgemm (a blas routine).</span><br/>AC_FC_FUNC(sgemm)<br/><br/>acx_blas_save_LIBS="$LIBS"<br/>LIBS="$LIBS $FCLIBS $FLIBS"<br/><br/><span class="comment"># First, check BLAS_LIBS environment variable</span><br/>if test "x$BLAS_LIBS" != x; then<br/>	save_LIBS="$LIBS"; LIBS="$BLAS_LIBS $LIBS"<br/>	AC_MSG_CHECKING([for $sgemm in $BLAS_LIBS])<br/>	AC_TRY_LINK_FUNC($sgemm, [acx_blas_ok=yes], [BLAS_LIBS=""])<br/>	AC_MSG_RESULT($acx_blas_ok)<br/>	LIBS="$save_LIBS"<br/>fi<br/><span class="comment"># restore the libs variable</span><br/>LIBS=$acx_blas_save_LIBS<br/>])<br/></pre>

<p>
This can be then added to configure.in like this:
</p>

<pre>sinclude([acx_blas.m4])<br/>ACX_BLAS<br/>LIBS="$BLAS_LIBS $FLIBS"<br/></pre>

<h2>CVS and autotools</h2>

<p>
CVS and autotools is an evil combination. AM_MAINTAINER_MODE is the
key many of the problems with mixed up timestamps, but there are other
things to know as well.
</p>

<p>
CVS updates often break autotools managed files files beyond
repair. This can be seen as weird errors in while using make. One way
to proceed might be to re-run configure to create everything -- or if
even configure is broken a </p>

<pre>rm configure ; cvs update configure ; ./configure <br/></pre>

<p>will be a sure fix.</p>

<p>
Alternatively, you can regenerate the configure yourself, if you have
autotools installed:
</p>

<pre>sh autogen.sh ; ./configure <br/></pre>

<h2>Troubleshooting</h2>

<p>
When a test fails and configure fails to give a reasonable explanation
of what went wrong (the usual case), searching config.log will often
give more detailed information about what went wrong.
</p>

<h2>More information</h2>

<p>
The best way to learn is to study (ie. steal) code from others -- just
search for projects that use the same libraries and programming
languages that you do. Still, reference guides are also useful, luckily
the
documentation that comes with automake and autoconf is extremely good:
</p>

<p><a href="http://www.gnu.org/software/autoconf/manual/index.html">Autoconf
manual</a></p>

<p><a href="http://www.gnu.org/software/automake/manual/index.html">Automake
manual</a></p>

<p>
There is also a semi-official autoconf macro index contains a wide
range of tests. They might not be perfect, but usually are a good
starting point.
</p>

<p><a href="http://autoconf-archive.cryp.to/macros-by-category.html">Autoconf
macro archive</a></p>

<p>
Another useful reference is the code itself. Need to know a shell
variable
that is produced by some test? Look it up from the
autoconf/lib/autoconf directory of autoconf source.
</p>

<h2>Misc</h2>

<p>autoproject is a tool that
creates a skeleton automake and autoconf managed project.</p>

<p><a href="http://directory.fsf.org/All_Packages_in_Directory/autoproject.html">Autoproject</a></p>

</body></html>
