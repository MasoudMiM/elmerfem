<html>
<head>

<title>Autotools nano-HOWTO</title>
</head>

(c) 2005 Juha Vierinen <juha.vierinen("#parse&this%#]csc.fi>

<h2>Building autotools managed software</h2>

<p>The normal way is this:</p>

<pre>
./configure ; make ; make install
</pre>

<p>
Usually there are also many custom options provided by the package
maintainer. The help option usually lists these.
</p>

<pre>
./configure --help
</pre>

<p>
Eg. the following will install the software into the home directory of
the user instead of the default location (/usr or /usr/local).
</p>

<pre>
./configure --prefix=/home/user
</pre>

<p>
Common environment variables are CFLAGS, CXXFLAGS, FFLAGS, FCFLAGS,
LIBS and LDFLAGS. These are processed and tested by configure and added
to the flags that configure comes up with. For example:
</p>

<pre>
export CFLAGS="-O42 -g --funny-compiler-flag -I/hard/to/guess/directory" 
./configure ; make  # will usually use your CFLAGS for compiling
</pre>

<p>
On more obscure (ie. AIX or OSX) platforms, you will often have to come up with CFLAGS and
LDFLAGS that will give the right libraries. Sometimes, a package might also
include custom arguments to do this as well eg.:
</p>

<pre>
./configure --with-blas="-L/home/user -lblas"
./configure --with-blas="/a/very/odd/place/supafastblaswithstripesandachrometailpipe.a"
</pre>


<h2>Automake provided default targets</h2>

<p>The commonly used targets are:</p>

<pre>
make           # Compile everything.
make clean     # Remove all objects, temporary files and such.
make distclean # Remove automatically generated autoconf/automake files.
make dist      # Create a tar.gz file containing source ready for distribution.
make install   # Install software to you kit.
</pre>

<p>Other useful targets:</p>

<pre>
make tags      #  Generate etags files for the source.
make dist-zip  # Create a zip file (great for windows people)
make uninstall # Uninstall the files installed with make install
make check     # Run tests bundled with the project
</pre>

<h2>The anatomy of a automake and autoconf governed project</h2>

<pre>
autogen.sh        # Semi-standard script for generating the configure script and possibly the Makefile.in files
configure.[in,ac] # The template used for producing configure
Makefile.in       # Autoconf makefile template
Makefile.am       # Automake makefile template
</pre>

<h2>Maintaining an autoconf project</h2>

<p>
If only autoconf is used, then Makefile.in is the file to
edit. Autoconf variables appear as @VARIABLE@ like definitions (these
are replaced with values found by the configure script). It is
also possible to use autoconf definitions in Makefile.am files, this
is especially useful for situations where automake functionality runs
short. A snippet of Makefile.in can look like:
</p>

<pre>
screensave.@SHEXT@: screensave.@OBJEXT@
	@CC@ @SH_LDFLAGS@ -o $@ $< @LIBS@
</pre>

<p>
When making modifications to the makefiles, you should run autogen.sh,
or aclocal;automake;autoheader;autoconf in a corrct order. There is
also a maintainer mode available that automatically regenerates the
makefiles when necessary. This is enabled by default, but is usually
switched of with the AM_MAINTAINER_MODE macro, but can be re-enabled
by giving the <code>--enable-maintainer-mode</code> flag to <code>./configure</code>.
</p>

<p>
The end result of both autoconf and automake is a set of portable
Makefiles, which should be kept in mind when creating
definitions.
</p>

<h2>Maintaining an autoconf+automake project</h2>

<p>
If automake is used, the file to edit is Makefile.am. You can also mix
custom Makefile directives in here, but stick with automake
definitions whenever possible, as it will save a lot of time. A simple
Makefile.am could look like this:
</p>

<pre>
bin_PROGRAMS=hello
hello_SOURCES=hello.c hello.h someotherfile.f waytoocomplex.cpp
</pre>

Commands
--------

autoscan   # Scan your source code to detect which tests might be needed and create a  configure.scan, which can be used as a basis of configure.in.
autoheader # Scan configure.in and create a config.h.in file, that will be used as a basis of your config.h (if you use one)
automake   # Go through configure.in and Makefile.am files and create Makefile.in files.
autoconf   # Go through configure.in and create the configure script.

Still can't figure out what to run and in which order? Try running
automake, aclocal, autoconf and autoheader in random combinations, and
you'll usually end up with something useful after a couple of
iterations. When you get a feeling of what is needed, write it down
into autogen.sh, so you'll remember it next time.

Writing custom tests
--------------------

You can write tests directly into configure.in. The language is an
obscure macro-language called M4, which expands to Bourne shell
script. So you basically write in a mixture of sh and M4. Eg.

AC_MSG_CHECKING([for answer to meaning of life]) # M4 function call
answer="42"                                      # sh variable assignment
AC_MSG_RESULT($answer)                           # M4 function call

Even writing modular and reusable M4+sh is possible, just take a look
at the autoconf source for the default AC_* macros.

If you intend to write a lot of tests, it is beneficial to write them
into separate .m4 files. This has an advantage of keeping configure.in
more understandable. Eg. you might have a file acx_blas.m4 that
contains a routine that gives a BLAS library as an argument to ./configure:

AC_DEFUN([ACX_BLAS], 
[
acx_blas_ok=no

AC_ARG_WITH(blas,
	[AC_HELP_STRING([--with-blas=<lib>], [use BLAS library <lib>])])
case $with_blas in
	yes | "") ;;
	no) acx_blas_ok=disable ;;
	-* | */* | *.a | *.so | *.so.* | *.o) BLAS_LIBS="$with_blas" ;;
	*) BLAS_LIBS="-l$with_blas" ;;
esac

# Get fortran symbol name of sgemm (a blas routine).
AC_FC_FUNC(sgemm)

acx_blas_save_LIBS="$LIBS"
LIBS="$LIBS $FCLIBS $FLIBS"

# First, check BLAS_LIBS environment variable
if test "x$BLAS_LIBS" != x; then
	save_LIBS="$LIBS"; LIBS="$BLAS_LIBS $LIBS"
	AC_MSG_CHECKING([for $sgemm in $BLAS_LIBS])
	AC_TRY_LINK_FUNC($sgemm, [acx_blas_ok=yes], [BLAS_LIBS=""])
	AC_MSG_RESULT($acx_blas_ok)
	LIBS="$save_LIBS"
fi
# restore the libs variable
LIBS=$acx_blas_save_LIBS
])

This can be then added to configure.in like this:

sinclude([acx_blas.m4])
ACX_BLAS
LIBS="$BLAS_LIBS $FLIBS"

CVS and autotools
-----------------

CVS and autotools is an evil combination. AM_MAINTAINER_MODE is the
key many of the problems with mixed up timestamps, but there are other
things to know as well.

CVS updates often break autotools managed files files beyond
repair. This can be seen as weird errors in while using make. One way
to proceed might be to re-run configure to create everything -- or if
even configure is broken a 

rm configure ; cvs update configure ; ./configure 

will be a sure fix.

Alternatively, you can regenerate the configure yourself, if you have
autotools installed:

sh autogen.sh ; ./configure 

Troubleshooting
---------------

When a test fails and configure fails to give a reasonable explanation
of what went wrong (the usual case), searching config.log will often
give more detailed information about what went wrong.

More information
----------------

The best way to learn is to study (ie. steal) code from others -- just
search for projects that use the same libraries and programming
languages that you do. Still, reference guides are also useful, luckily the
documentation that comes with automake and autoconf is extremely good:

http://www.gnu.org/software/autoconf/manual/index.html
http://www.gnu.org/software/automake/manual/index.html

There is also a semi-official autoconf macro index contains a wide
range of tests. They might not be perfect, but usually are a good
starting point.

http://autoconf-archive.cryp.to/macros-by-category.html

Another useful reference is the code itself. Need to know a shell variable
that is produced by some test? Look it up from the
autoconf/lib/autoconf directory of autoconf source.

Misc
----

autoproject is a tool that creates a skeleton automake and autoconf managed project.

http://directory.fsf.org/All_Packages_in_Directory/autoproject.html

